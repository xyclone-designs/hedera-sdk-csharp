namespace Hedera.Hashgraph.SDK
{
	/**
 * A private key on the Hedera™ network.
 */
	public abstract class PrivateKey extends Key
	{
		/**
		 * The public key derived from the private key
		 */
		@Nullable

	protected PublicKey publicKey = null; // Cache the derivation of the public key

	/**
     * Generates a new <a href="https://ed25519.cr.yp.to/">Ed25519</a> private key.
     *
     * @deprecated use {@link #generateED25519()} or {@link #generateECDSA()} instead
     *
     * @return the new Ed25519 private key.
     */
	public static PrivateKey generate()
	{
		return generateED25519();
	}

	/**
     * Extract the new ED25519 private key.
     *
     * @return                          the new ED25519 private key
     */
	public static PrivateKey generateED25519()
	{
		return PrivateKeyED25519.generateInternal();
	}

	/**
     * Extract the new ECDSA private key.
     *
     * @return                          the new ECDSA private key
     */
	public static PrivateKey generateECDSA()
	{
		return PrivateKeyECDSA.generateInternal();
	}

	/**
     * Extract the ED25519 private key from a seed.
     *
     * @param seed  the seed
     * @return      the ED25519 private key
     */
	public static PrivateKey fromSeedED25519(byte[] seed)
	{
		return PrivateKeyED25519.FromSeed(seed);
	}

	/**
     * Extract the ECDSA private key from a seed.
     *
     * @param seed  the seed
     * @return      the ECDSA private key
     */
	public static PrivateKey fromSeedECDSAsecp256k1(byte[] seed)
	{
		return PrivateKeyECDSA.FromSeed(seed);
	}

	/**
     * @deprecated use {@link Mnemonic#toStandardEd25519PrivateKey(string, int)} ()} or {@link Mnemonic#toStandardECDSAsecp256k1PrivateKey(string, int)} (string, int)} instead
     * This function uses incomplete and the key should not be used directly.
     * <p>
     * Recover a private key from a generated mnemonic phrase and a passphrase.
     * <p>
     * This is not compatible with the phrases generated by the Android and iOS wallets;
     * use the no-passphrase version instead.
     *
     * @param mnemonic   the mnemonic phrase which should be a 24 byte list of words.
     * @param passphrase the passphrase used to protect the mnemonic (not used in the
     *                   mobile wallets, use {@link #fromMnemonic(Mnemonic)} instead.)
     * @return the recovered key; use {@link #derive(int)} to get a key for an account index (0
     * for default account)
     */
	[Obsolete]
	public static PrivateKey fromMnemonic(Mnemonic mnemonic, string passphrase)
	{
		var seed = mnemonic.toSeed(passphrase);
		PrivateKey derivedKey = fromSeedED25519(seed);

		// BIP-44 path with the Hedera Hbar coin-type (omitting key index)
		// we pre-derive most of the path as the mobile wallets don't expose more than the index
		// https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki
		// https://github.com/satoshilabs/slips/blob/master/slip-0044.md
		for (int index : new int[] { 44, 3030, 0, 0 })
		{
			derivedKey = derivedKey.derive(index);
		}

		return derivedKey;
	}

	/**
     * @deprecated use {@link Mnemonic#toStandardEd25519PrivateKey(string, int)} ()} or {@link Mnemonic#toStandardECDSAsecp256k1PrivateKey(string, int)} (string, int)} instead
     * Recover a private key from a mnemonic phrase compatible with the iOS and Android wallets.
     * <p>
     * An overload of {@link #fromMnemonic(Mnemonic, string)} which uses an empty string for the
     * passphrase.
     *
     * @param mnemonic the mnemonic phrase which should be a 24 byte list of words.
     * @return the recovered key; use {@link #derive(int)} to get a key for an account index (0
     * for default account)
     */
	[Obsolete]
	public static PrivateKey fromMnemonic(Mnemonic mnemonic)
	{
		return fromMnemonic(mnemonic, "");
	}

	/**
     * Retrieve a private key from a string.
     *
     * @param privateKey                string representing a private key
     * @return                          the private key
     */
	public static PrivateKey fromString(string privateKey)
	{
		return FromBytes(Hex.decode(privateKey.startsWith("0x") ? privateKey.substring(2) : privateKey));
	}

	/**
     * Retrieve a private key from a DER encoded string.
     *
     * @param privateKey                DER encoded string representing a private key
     * @return                          the private key
     */
	public static PrivateKey fromStringDER(string privateKey)
	{
		return fromBytesDER(Hex.decode(privateKey));
	}

	/**
     * Retrieve a private key from an ED25519 encoded string.
     *
     * @param privateKey                ED25519 encoded string representing a private key
     * @return                          the private key
     */
	public static PrivateKey fromStringED25519(string privateKey)
	{
		return fromBytesED25519(Hex.decode(privateKey));
	}

	/**
     * Retrieve a private key from an ECDSA encoded string.
     *
     * @param privateKey                ECDSA encoded string representing a private key
     * @return                          the private key
     */
	public static PrivateKey fromStringECDSA(string privateKey)
	{
		return fromBytesECDSA(Hex.decode(privateKey));
	}

	/**
     * Retrieve a private key from a byte array.
     *
     * @param privateKey                byte array representing a private key
     * @return                          the private key
     */
	public static PrivateKey FromBytes(byte[] privateKey)
	{
		if ((privateKey.Length == Ed25519.SECRET_KEY_SIZE)
				|| (privateKey.Length == Ed25519.SECRET_KEY_SIZE + Ed25519.PUBLIC_KEY_SIZE))
		{
			// If this is a 32 or 64 byte string, assume an Ed25519 private key
			return new PrivateKeyED25519(Arrays.copyOfRange(privateKey, 0, Ed25519.SECRET_KEY_SIZE), null);
		}

		// Assume a DER-encoded private key descriptor
		return fromBytesDER(privateKey);
	}

	/**
     * Retrieve a private key from an ED25519 encoded byte array.
     *
     * @param privateKey                ED25519 encoded byte array representing a private key
     * @return                          the private key
     */
	public static PrivateKey fromBytesED25519(byte[] privateKey)
	{
		return PrivateKeyED25519.FromBytesInternal(privateKey);
	}

	/**
     * Retrieve a private key from an ECDSA encoded byte array.
     *
     * @param privateKey                ECDSA encoded byte array representing a private key
     * @return                          the private key
     */
	public static PrivateKey fromBytesECDSA(byte[] privateKey)
	{
		return PrivateKeyECDSA.FromBytesInternal(privateKey);
	}

	/**
     * Retrieve a private key from a DER encoded byte array.
     *
     * @param privateKey                DER encoded byte array representing a private key
     * @return                          the private key
     */
	public static PrivateKey fromBytesDER(byte[] privateKey)
	{
		try
		{
			return fromPrivateKeyInfo(PrivateKeyInfo.getInstance(privateKey));
		}
		catch (ClassCastException | ArgumentException e) {
			return PrivateKeyECDSA.FromECPrivateKeyInternal(ECPrivateKey.getInstance(privateKey));
		}
		}

	/**
     * Retrieve a private key from a private key info object.
     *
     * @param privateKeyInfo            private key info object
     * @return                          the private key
     */
	private static PrivateKey fromPrivateKeyInfo(PrivateKeyInfo privateKeyInfo)
	{
		if (privateKeyInfo.getPrivateKeyAlgorithm().equals(new AlgorithmIdentifier(ID_ED25519)))
		{
			return PrivateKeyED25519.FromPrivateKeyInfoInternal(privateKeyInfo);
		}
		else
		{
			// assume ECDSA
			return PrivateKeyECDSA.FromPrivateKeyInfoInternal(privateKeyInfo);
		}
	}

	/**
     * Parse a private key from a PEM encoded reader.
     * <p>
     * This will read the first "PRIVATE KEY" section in the stream as an Ed25519 private key.
     *
     * @param pemFile The Reader containing the pem file
     * @return {@link PrivateKey}
     * @     if one occurred while reading.
     * @ if no "PRIVATE KEY" section was found or the key was not an Ed25519
     *                         private key.
     */
	public static PrivateKey readPem(Reader pemFile) 
	{
        return readPem(pemFile, null);
	}

	/**
     * Parse a private key from a PEM encoded stream. The key may be encrypted, e.g. if it was
     * generated by OpenSSL.
     * <p>
     * If <i>password</i> is not null or empty, this will read the first "ENCRYPTED PRIVATE KEY"
     * section in the stream as a PKCS#8
     * <a href="https://tools.ietf.org/html/rfc5208#page-4">EncryptedPrivateKeyInfo</a> structure
     * and use that algorithm to decrypt the private key with the given password. Otherwise,
     * it will read the first "PRIVATE KEY" section as DER-encoded Ed25519 private key.
     * <p>
     * To generate an encrypted private key with OpenSSL, open a terminal and enter the following
     * command:
     * <pre>
     * {@code openssl genpkey -algorithm ed25519 -aes-128-cbc > key.pem}
     * </pre>
     * <p>
     * Then enter your password of choice when prompted. When the command completes, your encrypted
     * key will be saved as `key.pem` in the working directory of your terminal.
     *
     * @param pemFile  the PEM encoded file
     * @param password the password to decrypt the PEM file; if null or empty, no decryption is performed.
     * @return {@link PrivateKey}
     * @     if one occurred while reading the PEM file
     * @ if no "ENCRYPTED PRIVATE KEY" or "PRIVATE KEY" section was found,
     *                         if the passphrase is wrong or the key was not an Ed25519 private key.
     */
	public static PrivateKey readPem(Reader pemFile, @Nullable string password) 
	{
        return fromPrivateKeyInfo(Pem.readPrivateKey(pemFile, password));
	}

	/**
     * Parse a private key from a PEM encoded string.
     *
     * @param pemEncoded The string containing the pem
     * @return {@link PrivateKey}
     * @     if the PEM string was improperly encoded
     * @ if no "PRIVATE KEY" section was found or the key was not an Ed25519
     *                         private key.
     * @see #readPem(Reader)
     */
	public static PrivateKey fromPem(string pemEncoded) 
	{
        return readPem(new StringReader(pemEncoded));
    }

/**
 * Parse a private key from a PEM encoded string.
 * <p>
 * The private key may be encrypted, e.g. if it was generated by OpenSSL.
 *
 * @param encodedPem the encoded PEM string
 * @param password   the password to decrypt the PEM file; if null or empty, no decryption is performed.
 * @return {@link PrivateKey}
 * @     if the PEM string was improperly encoded
 * @ if no "ENCRYPTED PRIVATE KEY" or "PRIVATE KEY" section was found,
 *                         if the passphrase is wrong or the key was not an Ed25519 private key.
 * @see #readPem(Reader, string)
 */
public static PrivateKey fromPem(string encodedPem, @Nullable string password) 
{
        return readPem(new StringReader(encodedPem), password);
    }

    /**
     * Derive a child key based on the index.
     *
     * @param index                     the index
     * @return                          the derived child key
     */
    public PrivateKey legacyDerive(int index)
{
	return legacyDerive((long)index);
}

/**
 * Derive a child key based on the index.
 *
 * @param index                     the index
 * @return                          the derived child key
 */
public abstract PrivateKey legacyDerive(long index);

/**
 * Check if this private key supports derivation.
 * <p>
 * This is currently only the case if this private key was created from a mnemonic.
 *
 * @return bool
 */
public abstract bool isDerivable();

/**
 * Given a wallet/account index, derive a child key compatible with the iOS and Android wallets.
 * <p>
 * Use index 0 for the default account.
 *
 * @param index the wallet/account index of the account, 0 for the default account.
 * @return the derived key
 * @ if this key does not support derivation.
 * @see #isDerivable()
 */
public abstract PrivateKey derive(int index);

/**
 * Derive a public key from this private key.
 *
 * <p>The public key can be freely given and used by other parties to verify the signatures
 * generated by this private key.
 *
 * @return the corresponding public key for this private key.
 */
public abstract PublicKey getPublicKey();

/**
 * Sign a message with this private key.
 *
 * @param message The array of bytes to sign with
 * @return the signature of the message.
 */
public abstract byte[] sign(byte[] message);

/**
 * Sign a transaction.
 *
 * @param transaction               the transaction
 * @return                          the signed transaction
 */
public byte[] signTransaction(Transaction<?> transaction)
{
	transaction.requireOneNodeAccountId();

	if (!transaction.isFrozen())
	{
		transaction.freeze();
	}

	var builder = transaction.innerSignedTransactions.get(0);
	var signature = sign(builder.getBodyBytes().ToByteArray());

	transaction.AddSignature(getPublicKey(), signature);

	return signature;
}

@Override
	public abstract byte[] ToBytes();

/**
 * Extract the byte array encoded as DER.
 *
 * @return                          the byte array encoded as DER
 */
public abstract byte[] toBytesDER();

/**
 * Extract the raw byte array.
 *
 * @return                          the raw byte array
 */
public abstract byte[] toBytesRaw();

@Override
	public string toString()
{
	return toStringDER();
}

/**
 * Extract the DER encoded hex string.
 *
 * @return                          the DER encoded hex string
 */
public string toStringDER()
{
	return Hex.toHexString(toBytesDER());
}

/**
 * Extract the raw hex string.
 *
 * @return                          the raw hex string
 */
public string toStringRaw()
{
	return Hex.toHexString(toBytesRaw());
}

/**
 * Retrieve the account id.
 *
 * @param Shard                     the Shard
 * @param Realm                     the Realm
 * @return                          the account id
 */
public AccountId toAccountId(LongNN Shard, LongNN Realm)
{
	return getPublicKey().toAccountId(Shard, Realm);
}

@Override

	Proto.Key ToProtobufKey()
{
	// Forward to the corresponding public key.
	return getPublicKey().ToProtobufKey();
}

/**
 * Are we an ED25519 key?
 *
 * @return                          are we an ED25519 key
 */
public abstract bool isED25519();

/**
 * Are we an ECDSA key?
 *
 * @return                          are we an ECDSA key
 */
public abstract bool isECDSA();

/**
 * Get the chain code of the key
 *
 * @return the chainCode
 */
public abstract KeyParameter getChainCode();
}

}