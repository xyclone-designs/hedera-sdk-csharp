// SPDX-License-Identifier: Apache-2.0
using Java.Io;
using Java.Util;
using Javax.Annotation;
using Org.BouncyCastle.Asn1.Pkcs;
using Org.BouncyCastle.Asn1.Sec;
using Org.BouncyCastle.Asn1.X509;
using Org.BouncyCastle.Crypto.Parameters;
using Org.BouncyCastle.Math.EC.Rfc8032;
using Org.BouncyCastle.Util.Encoders;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Text;
using static Hedera.Hashgraph.SDK.BadMnemonicReason;
using static Hedera.Hashgraph.SDK.ExecutionState;
using static Hedera.Hashgraph.SDK.FeeAssessmentMethod;
using static Hedera.Hashgraph.SDK.FeeDataType;
using static Hedera.Hashgraph.SDK.FreezeType;
using static Hedera.Hashgraph.SDK.FungibleHookType;
using static Hedera.Hashgraph.SDK.HbarUnit;
using static Hedera.Hashgraph.SDK.HookExtensionPoint;
using static Hedera.Hashgraph.SDK.NetworkName;
using static Hedera.Hashgraph.SDK.NftHookType;

namespace Hedera.Hashgraph.SDK.Keys
{
    /// <summary>
    /// A private key on the Hederaâ„¢ network.
    /// </summary>
    public abstract class PrivateKey : Key
    {
        /// <summary>
        /// The public key derived from the private key
        /// </summary>
        protected PublicKey publicKey = null; // Cache the derivation of the public key
        /// <summary>
        /// Generates a new <a href="https://ed25519.cr.yp.to/">Ed25519</a> private key.
        /// </summary>
        /// <returns>the new Ed25519 private key.</returns>
        /// <remarks>@deprecateduse {@link #generateED25519()} or {@link #generateECDSA()} instead</remarks>
        public static PrivateKey Generate()
        {
            return GenerateED25519();
        }

        /// <summary>
        /// Extract the new ED25519 private key.
        /// </summary>
        /// <returns>                         the new ED25519 private key</returns>
        public static PrivateKey GenerateED25519()
        {
            return PrivateKeyED25519.GenerateInternal();
        }

        /// <summary>
        /// Extract the new ECDSA private key.
        /// </summary>
        /// <returns>                         the new ECDSA private key</returns>
        public static PrivateKey GenerateECDSA()
        {
            return PrivateKeyECDSA.GenerateInternal();
        }

        /// <summary>
        /// Extract the ED25519 private key from a seed.
        /// </summary>
        /// <param name="seed">the seed</param>
        /// <returns>     the ED25519 private key</returns>
        public static PrivateKey FromSeedED25519(byte[] seed)
        {
            return PrivateKeyED25519.FromSeed(seed);
        }

        /// <summary>
        /// Extract the ECDSA private key from a seed.
        /// </summary>
        /// <param name="seed">the seed</param>
        /// <returns>     the ECDSA private key</returns>
        public static PrivateKey FromSeedECDSAsecp256k1(byte[] seed)
        {
            return PrivateKeyECDSA.FromSeed(seed);
        }

        /// <summary>
        /// </summary>
        /// <param name="mnemonic">the mnemonic phrase which should be a 24 byte list of words.</param>
        /// <param name="passphrase">the passphrase used to protect the mnemonic (not used in the
        ///                   mobile wallets, use {@link #fromMnemonic(Mnemonic)} instead.)</param>
        /// <returns>the recovered key; use {@link #derive(int)} to get a key for an account index (0
        /// for default account)</returns>
        /// <remarks>
        /// @deprecateduse {@link Mnemonic#toStandardEd25519PrivateKey(String, int)} ()} or {@link Mnemonic#toStandardECDSAsecp256k1PrivateKey(String, int)} (String, int)} instead
        /// This function uses incomplete and the key should not be used directly.
        /// <p>
        /// Recover a private key from a generated mnemonic phrase and a passphrase.
        /// <p>
        /// This is not compatible with the phrases generated by the Android and iOS wallets;
        /// use the no-passphrase version instead.
        /// </remarks>
        public static PrivateKey FromMnemonic(Mnemonic mnemonic, string passphrase)
        {
            var seed = mnemonic.ToSeed(passphrase);
            PrivateKey derivedKey = FromSeedED25519(seed);

            // BIP-44 path with the Hedera Hbar coin-type (omitting key index)
            // we pre-derive most of the path as the mobile wallets don't expose more than the index
            // https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki
            // https://github.com/satoshilabs/slips/blob/master/slip-0044.md
            foreach (int index in new int[]
            {
                44,
                3030,
                0,
                0
            }

            )
            {
                derivedKey = derivedKey.Derive(index);
            }

            return derivedKey;
        }

        /// <summary>
        /// </summary>
        /// <param name="mnemonic">the mnemonic phrase which should be a 24 byte list of words.</param>
        /// <returns>the recovered key; use {@link #derive(int)} to get a key for an account index (0
        /// for default account)</returns>
        /// <remarks>
        /// @deprecateduse {@link Mnemonic#toStandardEd25519PrivateKey(String, int)} ()} or {@link Mnemonic#toStandardECDSAsecp256k1PrivateKey(String, int)} (String, int)} instead
        /// Recover a private key from a mnemonic phrase compatible with the iOS and Android wallets.
        /// <p>
        /// An overload of {@link #fromMnemonic(Mnemonic, String)} which uses an empty string for the
        /// passphrase.
        /// </remarks>
        public static PrivateKey FromMnemonic(Mnemonic mnemonic)
        {
            return FromMnemonic(mnemonic, "");
        }

        /// <summary>
        /// Retrieve a private key from a string.
        /// </summary>
        /// <param name="privateKey">string representing a private key</param>
        /// <returns>                         the private key</returns>
        public static PrivateKey FromString(string privateKey)
        {
            return FromBytes(Hex.Decode(privateKey.StartsWith("0x") ? privateKey.Substring(2) : privateKey));
        }

        /// <summary>
        /// Retrieve a private key from a DER encoded string.
        /// </summary>
        /// <param name="privateKey">DER encoded string representing a private key</param>
        /// <returns>                         the private key</returns>
        public static PrivateKey FromStringDER(string privateKey)
        {
            return FromBytesDER(Hex.Decode(privateKey));
        }

        /// <summary>
        /// Retrieve a private key from an ED25519 encoded string.
        /// </summary>
        /// <param name="privateKey">ED25519 encoded string representing a private key</param>
        /// <returns>                         the private key</returns>
        public static PrivateKey FromStringED25519(string privateKey)
        {
            return FromBytesED25519(Hex.Decode(privateKey));
        }

        /// <summary>
        /// Retrieve a private key from an ECDSA encoded string.
        /// </summary>
        /// <param name="privateKey">ECDSA encoded string representing a private key</param>
        /// <returns>                         the private key</returns>
        public static PrivateKey FromStringECDSA(string privateKey)
        {
            return FromBytesECDSA(Hex.Decode(privateKey));
        }

        /// <summary>
        /// Retrieve a private key from a byte array.
        /// </summary>
        /// <param name="privateKey">byte array representing a private key</param>
        /// <returns>                         the private key</returns>
        public static PrivateKey FromBytes(byte[] privateKey)
        {
            if ((privateKey.Length == Ed25519.SECRET_KEY_SIZE) || (privateKey.Length == Ed25519.SECRET_KEY_SIZE + Ed25519.PUBLIC_KEY_SIZE))
            {

                // If this is a 32 or 64 byte string, assume an Ed25519 private key
                return new PrivateKeyED25519(Array.CopyOfRange(privateKey, 0, Ed25519.SECRET_KEY_SIZE), null);
            }


            // Assume a DER-encoded private key descriptor
            return FromBytesDER(privateKey);
        }

        /// <summary>
        /// Retrieve a private key from an ED25519 encoded byte array.
        /// </summary>
        /// <param name="privateKey">ED25519 encoded byte array representing a private key</param>
        /// <returns>                         the private key</returns>
        public static PrivateKey FromBytesED25519(byte[] privateKey)
        {
            return PrivateKeyED25519.FromBytesInternal(privateKey);
        }

        /// <summary>
        /// Retrieve a private key from an ECDSA encoded byte array.
        /// </summary>
        /// <param name="privateKey">ECDSA encoded byte array representing a private key</param>
        /// <returns>                         the private key</returns>
        public static PrivateKey FromBytesECDSA(byte[] privateKey)
        {
            return PrivateKeyECDSA.FromBytesInternal(privateKey);
        }

        /// <summary>
        /// Retrieve a private key from a DER encoded byte array.
        /// </summary>
        /// <param name="privateKey">DER encoded byte array representing a private key</param>
        /// <returns>                         the private key</returns>
        public static PrivateKey FromBytesDER(byte[] privateKey)
        {
            try
            {
                return FromPrivateKeyInfo(PrivateKeyInfo.GetInstance(privateKey));
            }
            catch (ClassCastException e)
            {
                return PrivateKeyECDSA.FromECPrivateKeyInternal(ECPrivateKey.GetInstance(privateKey));
            }
            catch (ArgumentException e)
            {
                return PrivateKeyECDSA.FromECPrivateKeyInternal(ECPrivateKey.GetInstance(privateKey));
            }
        }

        /// <summary>
        /// Retrieve a private key from a private key info object.
        /// </summary>
        /// <param name="privateKeyInfo">private key info object</param>
        /// <returns>                         the private key</returns>
        private static PrivateKey FromPrivateKeyInfo(PrivateKeyInfo privateKeyInfo)
        {
            if (privateKeyInfo.PrivateKeyAlgorithm().Equals(new AlgorithmIdentifier(ID_ED25519)))
            {
                return PrivateKeyED25519.FromPrivateKeyInfoInternal(privateKeyInfo);
            }
            else
            {

                // assume ECDSA
                return PrivateKeyECDSA.FromPrivateKeyInfoInternal(privateKeyInfo);
            }
        }

        /// <summary>
        /// Parse a private key from a PEM encoded reader.
        /// <p>
        /// This will read the first "PRIVATE KEY" section in the stream as an Ed25519 private key.
        /// </summary>
        /// <param name="pemFile">The Reader containing the pem file</param>
        /// <returns>{@link PrivateKey}</returns>
        /// <exception cref="IOException">if one occurred while reading.</exception>
        /// <exception cref="BadKeyException">if no "PRIVATE KEY" section was found or the key was not an Ed25519
        ///                         private key.</exception>
        public static PrivateKey ReadPem(Reader pemFile)
        {
            return ReadPem(pemFile, null);
        }

        /// <summary>
        /// Parse a private key from a PEM encoded stream. The key may be encrypted, e.g. if it was
        /// generated by OpenSSL.
        /// <p>
        /// If <i>password</i> is not null or empty, this will read the first "ENCRYPTED PRIVATE KEY"
        /// section in the stream as a PKCS#8
        /// <a href="https://tools.ietf.org/html/rfc5208#page-4">EncryptedPrivateKeyInfo</a> structure
        /// and use that algorithm to decrypt the private key with the given password. Otherwise,
        /// it will read the first "PRIVATE KEY" section as DER-encoded Ed25519 private key.
        /// <p>
        /// To generate an encrypted private key with OpenSSL, open a terminal and enter the following
        /// command:
        /// <pre>
        /// {@code openssl genpkey -algorithm ed25519 -aes-128-cbc > key.pem}
        /// </pre>
        /// <p>
        /// Then enter your password of choice when prompted. When the command completes, your encrypted
        /// key will be saved as `key.pem` in the working directory of your terminal.
        /// </summary>
        /// <param name="pemFile">the PEM encoded file</param>
        /// <param name="password">the password to decrypt the PEM file; if null or empty, no decryption is performed.</param>
        /// <returns>{@link PrivateKey}</returns>
        /// <exception cref="IOException">if one occurred while reading the PEM file</exception>
        /// <exception cref="BadKeyException">if no "ENCRYPTED PRIVATE KEY" or "PRIVATE KEY" section was found,
        ///                         if the passphrase is wrong or the key was not an Ed25519 private key.</exception>
        public static PrivateKey ReadPem(Reader pemFile, string password)
        {
            return FromPrivateKeyInfo(Pem.ReadPrivateKey(pemFile, password));
        }

        /// <summary>
        /// Parse a private key from a PEM encoded string.
        /// </summary>
        /// <param name="pemEncoded">The String containing the pem</param>
        /// <returns>{@link PrivateKey}</returns>
        /// <exception cref="IOException">if the PEM string was improperly encoded</exception>
        /// <exception cref="BadKeyException">if no "PRIVATE KEY" section was found or the key was not an Ed25519
        ///                         private key.</exception>
        /// <remarks>@see#readPem(Reader)</remarks>
        public static PrivateKey FromPem(string pemEncoded)
        {
            return ReadPem(new StringReader(pemEncoded));
        }

        /// <summary>
        /// Parse a private key from a PEM encoded string.
        /// <p>
        /// The private key may be encrypted, e.g. if it was generated by OpenSSL.
        /// </summary>
        /// <param name="encodedPem">the encoded PEM string</param>
        /// <param name="password">the password to decrypt the PEM file; if null or empty, no decryption is performed.</param>
        /// <returns>{@link PrivateKey}</returns>
        /// <exception cref="IOException">if the PEM string was improperly encoded</exception>
        /// <exception cref="BadKeyException">if no "ENCRYPTED PRIVATE KEY" or "PRIVATE KEY" section was found,
        ///                         if the passphrase is wrong or the key was not an Ed25519 private key.</exception>
        /// <remarks>@see#readPem(Reader, String)</remarks>
        public static PrivateKey FromPem(string encodedPem, string password)
        {
            return ReadPem(new StringReader(encodedPem), password);
        }

        /// <summary>
        /// Derive a child key based on the index.
        /// </summary>
        /// <param name="index">the index</param>
        /// <returns>                         the derived child key</returns>
        public virtual PrivateKey LegacyDerive(int index)
        {
            return LegacyDerive((long)index);
        }

        /// <summary>
        /// Derive a child key based on the index.
        /// </summary>
        /// <param name="index">the index</param>
        /// <returns>                         the derived child key</returns>
        public abstract PrivateKey LegacyDerive(long index);
        /// <summary>
        /// Check if this private key supports derivation.
        /// <p>
        /// This is currently only the case if this private key was created from a mnemonic.
        /// </summary>
        /// <returns>bool</returns>
        public abstract bool IsDerivable();
        /// <summary>
        /// Given a wallet/account index, derive a child key compatible with the iOS and Android wallets.
        /// <p>
        /// Use index 0 for the default account.
        /// </summary>
        /// <param name="index">the wallet/account index of the account, 0 for the default account.</param>
        /// <returns>the derived key</returns>
        /// <exception cref="IllegalStateException">if this key does not support derivation.</exception>
        /// <remarks>@see#isDerivable()</remarks>
        public abstract PrivateKey Derive(int index);
        /// <summary>
        /// Derive a public key from this private key.
        /// 
        /// <p>The public key can be freely given and used by other parties to verify the signatures
        /// generated by this private key.
        /// </summary>
        /// <returns>the corresponding public key for this private key.</returns>
        public abstract PublicKey GetPublicKey();
        /// <summary>
        /// Sign a message with this private key.
        /// </summary>
        /// <param name="message">The array of bytes to sign with</param>
        /// <returns>the signature of the message.</returns>
        public abstract byte[] Sign(byte[] message);
        /// <summary>
        /// Sign a transaction.
        /// </summary>
        /// <param name="transaction">the transaction</param>
        /// <returns>                         the signed transaction</returns>
        public virtual byte[] SignTransaction(Transaction<TWildcardTodo> transaction)
        {
            transaction.RequireOneNodeAccountId();
            if (!transaction.IsFrozen())
            {
                transaction.Freeze();
            }

            var builder = transaction.innerSignedTransactions[0];
            var signature = Sign(builder.BodyBytes().ToByteArray());
            transaction.AddSignature(GetPublicKey(), signature);
            return signature;
        }

        public abstract override byte[] ToBytes();
        /// <summary>
        /// Extract the byte array encoded as DER.
        /// </summary>
        /// <returns>                         the byte array encoded as DER</returns>
        public abstract byte[] ToBytesDER();
        /// <summary>
        /// Extract the raw byte array.
        /// </summary>
        /// <returns>                         the raw byte array</returns>
        public abstract byte[] ToBytesRaw();
        public override string ToString()
        {
            return ToStringDER();
        }

        /// <summary>
        /// Extract the DER encoded hex string.
        /// </summary>
        /// <returns>                         the DER encoded hex string</returns>
        public virtual string ToStringDER()
        {
            return Hex.ToHexString(ToBytesDER());
        }

        /// <summary>
        /// Extract the raw hex string.
        /// </summary>
        /// <returns>                         the raw hex string</returns>
        public virtual string ToStringRaw()
        {
            return Hex.ToHexString(ToBytesRaw());
        }

        /// <summary>
        /// Retrieve the account id.
        /// </summary>
        /// <param name="shard">the shard</param>
        /// <param name="realm">the realm</param>
        /// <returns>                         the account id</returns>
        public virtual AccountId ToAccountId(long shard, long realm)
        {
            return GetPublicKey().ToAccountId(shard, realm);
        }

        override Proto.Key ToProtobufKey()
        {
            // Forward to the corresponding public key.
            return GetPublicKey().ToProtobufKey();
        }

        /// <summary>
        /// Are we an ED25519 key?
        /// </summary>
        /// <returns>                         are we an ED25519 key</returns>
        public abstract bool IsED25519();
        /// <summary>
        /// Are we an ECDSA key?
        /// </summary>
        /// <returns>                         are we an ECDSA key</returns>
        public abstract bool IsECDSA();
        /// <summary>
        /// Get the chain code of the key
        /// </summary>
        /// <returns>the chainCode</returns>
        public abstract KeyParameter GetChainCode();
    }
}