// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: file.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021, 8981
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Hedera.Hashgraph.Proto {

  /// <summary>Holder for reflection information generated from file.proto</summary>
  public static partial class FileReflection {

    #region Descriptor
    /// <summary>File descriptor for file.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static FileReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CgpmaWxlLnByb3RvEgVwcm90bxoRYmFzaWNfdHlwZXMucHJvdG8ivQEKBEZp",
            "bGUSHgoHZmlsZV9pZBgBIAEoCzINLnByb3RvLkZpbGVJRBIZChFleHBpcmF0",
            "aW9uX3NlY29uZBgCIAEoAxIcCgRrZXlzGAMgASgLMg4ucHJvdG8uS2V5TGlz",
            "dBIQCghjb250ZW50cxgEIAEoDBIMCgRtZW1vGAUgASgJEg8KB2RlbGV0ZWQY",
            "BiABKAgSKwojcHJlX3N5c3RlbV9kZWxldGVfZXhwaXJhdGlvbl9zZWNvbmQY",
            "ByABKANCOQoeY29tLmhlZGVyYS5oYXNoZ3JhcGguc2RrLnByb3RvqgIWSGVk",
            "ZXJhLkhhc2hncmFwaC5Qcm90b2IGcHJvdG8z"));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Hedera.Hashgraph.Proto.BasicTypesReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Hedera.Hashgraph.Proto.File), global::Hedera.Hashgraph.Proto.File.Parser, new[]{ "FileId", "ExpirationSecond", "Keys", "Contents", "Memo", "Deleted", "PreSystemDeleteExpirationSecond" }, null, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  ///*
  /// Representation of an Hedera File Service `file`.
  ///
  /// Files offer a place to store additional data, much more than is available in
  /// other entities, for use with smart contracts, non-fungible tokens, etc...
  /// As with all network entities, a file has a unique entity number, which is
  /// given along with the network's shard and realm in the form of a
  /// shard.realm.number id.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class File : pb::IMessage<File>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<File> _parser = new pb::MessageParser<File>(() => new File());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<File> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Hedera.Hashgraph.Proto.FileReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public File() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public File(File other) : this() {
      fileId_ = other.fileId_ != null ? other.fileId_.Clone() : null;
      expirationSecond_ = other.expirationSecond_;
      keys_ = other.keys_ != null ? other.keys_.Clone() : null;
      contents_ = other.contents_;
      memo_ = other.memo_;
      deleted_ = other.deleted_;
      preSystemDeleteExpirationSecond_ = other.preSystemDeleteExpirationSecond_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public File Clone() {
      return new File(this);
    }

    /// <summary>Field number for the "file_id" field.</summary>
    public const int FileIdFieldNumber = 1;
    private global::Hedera.Hashgraph.Proto.FileID fileId_;
    /// <summary>
    ///*
    /// This file's ID within the global network state.
    /// &lt;p>
    /// This value SHALL be unique within the network.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Hedera.Hashgraph.Proto.FileID FileId {
      get { return fileId_; }
      set {
        fileId_ = value;
      }
    }

    /// <summary>Field number for the "expiration_second" field.</summary>
    public const int ExpirationSecondFieldNumber = 2;
    private long expirationSecond_;
    /// <summary>
    ///*
    /// The file's expiration time in seconds since the epoch.&lt;br/>
    /// This value should be compared against consensus time, which may not
    /// exactly match clock time at the moment of expiration.
    /// &lt;p>
    /// For this purpose, `epoch` SHALL be the UNIX epoch with 0 at `1970-01-01T00:00:00.000Z`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long ExpirationSecond {
      get { return expirationSecond_; }
      set {
        expirationSecond_ = value;
      }
    }

    /// <summary>Field number for the "keys" field.</summary>
    public const int KeysFieldNumber = 3;
    private global::Hedera.Hashgraph.Proto.KeyList keys_;
    /// <summary>
    ///*
    /// A list of keys that MUST sign any transaction to create
    /// or update this file.
    /// &lt;p>
    /// Only _one_ of these keys must sign a transaction to delete the file.&lt;br/>
    /// This field MAY be `null` or an empty list.&lt;br/>
    /// If this field is null or an empty `KeyList`, then the file SHALL be
    /// immutable.&lt;br/>
    /// For an immutable file, the only transaction permitted to modify that
    /// file SHALL be a `fileUpdate` transaction with _only_ the
    /// `expirationTime` set.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Hedera.Hashgraph.Proto.KeyList Keys {
      get { return keys_; }
      set {
        keys_ = value;
      }
    }

    /// <summary>Field number for the "contents" field.</summary>
    public const int ContentsFieldNumber = 4;
    private pb::ByteString contents_ = pb::ByteString.Empty;
    /// <summary>
    ///*
    /// The contents of the file.
    /// &lt;p>
    /// This SHALL be limited to the current maximum file size; typically no
    /// more than 1 Megabyte (1048576 bytes).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString Contents {
      get { return contents_; }
      set {
        contents_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "memo" field.</summary>
    public const int MemoFieldNumber = 5;
    private string memo_ = "";
    /// <summary>
    ///*
    /// A short description of the file.
    /// &lt;p>
    /// This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
    /// (default 100) bytes when encoded as UTF-8.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Memo {
      get { return memo_; }
      set {
        memo_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "deleted" field.</summary>
    public const int DeletedFieldNumber = 6;
    private bool deleted_;
    /// <summary>
    ///*
    /// A flag indicating that this file is deleted.
    /// &lt;p>
    /// The `contents` of a deleted "regular" file SHALL be an empty
    /// (zero length) bytes.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Deleted {
      get { return deleted_; }
      set {
        deleted_ = value;
      }
    }

    /// <summary>Field number for the "pre_system_delete_expiration_second" field.</summary>
    public const int PreSystemDeleteExpirationSecondFieldNumber = 7;
    private long preSystemDeleteExpirationSecond_;
    /// <summary>
    ///*
    /// The pre-system-delete expiration time of a deleted "system" file, in seconds.
    /// &lt;p>
    /// This field SHALL contain the original expiration time of a "system" file
    /// that is deleted. This SHOULD be used to restore that expiration time if
    /// the file is subsequently "un-deleted" before it is purged from the
    /// system.&lt;br/>
    /// A "regular" file cannot be "un-deleted", so this field SHALL NOT be set
    /// for those files.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long PreSystemDeleteExpirationSecond {
      get { return preSystemDeleteExpirationSecond_; }
      set {
        preSystemDeleteExpirationSecond_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as File);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(File other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(FileId, other.FileId)) return false;
      if (ExpirationSecond != other.ExpirationSecond) return false;
      if (!object.Equals(Keys, other.Keys)) return false;
      if (Contents != other.Contents) return false;
      if (Memo != other.Memo) return false;
      if (Deleted != other.Deleted) return false;
      if (PreSystemDeleteExpirationSecond != other.PreSystemDeleteExpirationSecond) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (fileId_ != null) hash ^= FileId.GetHashCode();
      if (ExpirationSecond != 0L) hash ^= ExpirationSecond.GetHashCode();
      if (keys_ != null) hash ^= Keys.GetHashCode();
      if (Contents.Length != 0) hash ^= Contents.GetHashCode();
      if (Memo.Length != 0) hash ^= Memo.GetHashCode();
      if (Deleted != false) hash ^= Deleted.GetHashCode();
      if (PreSystemDeleteExpirationSecond != 0L) hash ^= PreSystemDeleteExpirationSecond.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (fileId_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(FileId);
      }
      if (ExpirationSecond != 0L) {
        output.WriteRawTag(16);
        output.WriteInt64(ExpirationSecond);
      }
      if (keys_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Keys);
      }
      if (Contents.Length != 0) {
        output.WriteRawTag(34);
        output.WriteBytes(Contents);
      }
      if (Memo.Length != 0) {
        output.WriteRawTag(42);
        output.WriteString(Memo);
      }
      if (Deleted != false) {
        output.WriteRawTag(48);
        output.WriteBool(Deleted);
      }
      if (PreSystemDeleteExpirationSecond != 0L) {
        output.WriteRawTag(56);
        output.WriteInt64(PreSystemDeleteExpirationSecond);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (fileId_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(FileId);
      }
      if (ExpirationSecond != 0L) {
        output.WriteRawTag(16);
        output.WriteInt64(ExpirationSecond);
      }
      if (keys_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Keys);
      }
      if (Contents.Length != 0) {
        output.WriteRawTag(34);
        output.WriteBytes(Contents);
      }
      if (Memo.Length != 0) {
        output.WriteRawTag(42);
        output.WriteString(Memo);
      }
      if (Deleted != false) {
        output.WriteRawTag(48);
        output.WriteBool(Deleted);
      }
      if (PreSystemDeleteExpirationSecond != 0L) {
        output.WriteRawTag(56);
        output.WriteInt64(PreSystemDeleteExpirationSecond);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (fileId_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(FileId);
      }
      if (ExpirationSecond != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(ExpirationSecond);
      }
      if (keys_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Keys);
      }
      if (Contents.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Contents);
      }
      if (Memo.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Memo);
      }
      if (Deleted != false) {
        size += 1 + 1;
      }
      if (PreSystemDeleteExpirationSecond != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(PreSystemDeleteExpirationSecond);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(File other) {
      if (other == null) {
        return;
      }
      if (other.fileId_ != null) {
        if (fileId_ == null) {
          FileId = new global::Hedera.Hashgraph.Proto.FileID();
        }
        FileId.MergeFrom(other.FileId);
      }
      if (other.ExpirationSecond != 0L) {
        ExpirationSecond = other.ExpirationSecond;
      }
      if (other.keys_ != null) {
        if (keys_ == null) {
          Keys = new global::Hedera.Hashgraph.Proto.KeyList();
        }
        Keys.MergeFrom(other.Keys);
      }
      if (other.Contents.Length != 0) {
        Contents = other.Contents;
      }
      if (other.Memo.Length != 0) {
        Memo = other.Memo;
      }
      if (other.Deleted != false) {
        Deleted = other.Deleted;
      }
      if (other.PreSystemDeleteExpirationSecond != 0L) {
        PreSystemDeleteExpirationSecond = other.PreSystemDeleteExpirationSecond;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (fileId_ == null) {
              FileId = new global::Hedera.Hashgraph.Proto.FileID();
            }
            input.ReadMessage(FileId);
            break;
          }
          case 16: {
            ExpirationSecond = input.ReadInt64();
            break;
          }
          case 26: {
            if (keys_ == null) {
              Keys = new global::Hedera.Hashgraph.Proto.KeyList();
            }
            input.ReadMessage(Keys);
            break;
          }
          case 34: {
            Contents = input.ReadBytes();
            break;
          }
          case 42: {
            Memo = input.ReadString();
            break;
          }
          case 48: {
            Deleted = input.ReadBool();
            break;
          }
          case 56: {
            PreSystemDeleteExpirationSecond = input.ReadInt64();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (fileId_ == null) {
              FileId = new global::Hedera.Hashgraph.Proto.FileID();
            }
            input.ReadMessage(FileId);
            break;
          }
          case 16: {
            ExpirationSecond = input.ReadInt64();
            break;
          }
          case 26: {
            if (keys_ == null) {
              Keys = new global::Hedera.Hashgraph.Proto.KeyList();
            }
            input.ReadMessage(Keys);
            break;
          }
          case 34: {
            Contents = input.ReadBytes();
            break;
          }
          case 42: {
            Memo = input.ReadString();
            break;
          }
          case 48: {
            Deleted = input.ReadBool();
            break;
          }
          case 56: {
            PreSystemDeleteExpirationSecond = input.ReadInt64();
            break;
          }
        }
      }
    }
    #endif

  }

  #endregion

}

#endregion Designer generated code
