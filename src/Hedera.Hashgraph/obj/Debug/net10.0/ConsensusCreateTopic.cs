// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: consensus_create_topic.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021, 8981
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Proto {

  /// <summary>Holder for reflection information generated from consensus_create_topic.proto</summary>
  public static partial class ConsensusCreateTopicReflection {

    #region Descriptor
    /// <summary>File descriptor for consensus_create_topic.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static ConsensusCreateTopicReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "Chxjb25zZW5zdXNfY3JlYXRlX3RvcGljLnByb3RvEgVwcm90bxoRYmFzaWNf",
            "dHlwZXMucHJvdG8aEWN1c3RvbV9mZWVzLnByb3RvGg5kdXJhdGlvbi5wcm90",
            "byLBAgojQ29uc2Vuc3VzQ3JlYXRlVG9waWNUcmFuc2FjdGlvbkJvZHkSDAoE",
            "bWVtbxgBIAEoCRIcCghhZG1pbktleRgCIAEoCzIKLnByb3RvLktleRIdCglz",
            "dWJtaXRLZXkYAyABKAsyCi5wcm90by5LZXkSKAoPYXV0b1JlbmV3UGVyaW9k",
            "GAYgASgLMg8ucHJvdG8uRHVyYXRpb24SKgoQYXV0b1JlbmV3QWNjb3VudBgH",
            "IAEoCzIQLnByb3RvLkFjY291bnRJRBIkChBmZWVfc2NoZWR1bGVfa2V5GAgg",
            "ASgLMgoucHJvdG8uS2V5EicKE2ZlZV9leGVtcHRfa2V5X2xpc3QYCSADKAsy",
            "Ci5wcm90by5LZXkSKgoLY3VzdG9tX2ZlZXMYCiADKAsyFS5wcm90by5GaXhl",
            "ZEN1c3RvbUZlZUIiCh5jb20uaGVkZXJhLmhhc2hncmFwaC5zZGsucHJvdG9Q",
            "AWIGcHJvdG8z"));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Proto.BasicTypesReflection.Descriptor, global::Proto.CustomFeesReflection.Descriptor, global::Proto.DurationReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Proto.ConsensusCreateTopicTransactionBody), global::Proto.ConsensusCreateTopicTransactionBody.Parser, new[]{ "Memo", "AdminKey", "SubmitKey", "AutoRenewPeriod", "AutoRenewAccount", "FeeScheduleKey", "FeeExemptKeyList", "CustomFees" }, null, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  ///*
  /// Create a topic to accept and group consensus messages.
  ///
  /// If `autoRenewAccount` is specified, that account Key MUST also sign this
  /// transaction.&lt;br/>
  /// If `adminKey` is set, that Key MUST sign the transaction.&lt;br/>
  /// On success, the resulting `TransactionReceipt` SHALL contain the newly
  /// created `TopicId`.
  ///
  /// The `autoRenewPeriod` on a topic MUST be set to a value between
  /// `autoRenewPeriod.minDuration` and `autoRenewPeriod.maxDuration`. These
  /// values are configurable, typically 30 and 92 days.&lt;br/>
  /// This also sets the initial expirationTime of the topic.
  ///
  /// If no `adminKey` is set on a topic
  ///   -`autoRenewAccount` SHALL NOT be set on the topic.
  ///   - A `deleteTopic` transaction SHALL fail.
  ///   - An `updateTopic` transaction that only extends the expirationTime MAY
  ///     succeed.
  ///   - Any other `updateTopic` transaction SHALL fail.
  ///
  /// If the topic expires and is not automatically renewed, the topic SHALL enter
  /// the `EXPIRED` state.
  ///   - All transactions on the topic SHALL fail with TOPIC_EXPIRED
  ///      - Except an updateTopic() call that only extends the expirationTime.
  ///   - getTopicInfo() SHALL succeed, and show the topic is expired.
  /// The topic SHALL remain in the `EXPIRED` state for a time determined by the
  /// `autorenew.gracePeriod` (configurable, originally 7 days).&lt;br/>
  /// After the grace period, if the topic's expirationTime is not extended, the
  /// topic SHALL be automatically deleted from state entirely, and cannot be
  /// recovered or recreated.
  ///
  /// ### Block Stream Effects
  /// None
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class ConsensusCreateTopicTransactionBody : pb::IMessage<ConsensusCreateTopicTransactionBody>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ConsensusCreateTopicTransactionBody> _parser = new pb::MessageParser<ConsensusCreateTopicTransactionBody>(() => new ConsensusCreateTopicTransactionBody());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ConsensusCreateTopicTransactionBody> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Proto.ConsensusCreateTopicReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ConsensusCreateTopicTransactionBody() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ConsensusCreateTopicTransactionBody(ConsensusCreateTopicTransactionBody other) : this() {
      memo_ = other.memo_;
      adminKey_ = other.adminKey_ != null ? other.adminKey_.Clone() : null;
      submitKey_ = other.submitKey_ != null ? other.submitKey_.Clone() : null;
      autoRenewPeriod_ = other.autoRenewPeriod_ != null ? other.autoRenewPeriod_.Clone() : null;
      autoRenewAccount_ = other.autoRenewAccount_ != null ? other.autoRenewAccount_.Clone() : null;
      feeScheduleKey_ = other.feeScheduleKey_ != null ? other.feeScheduleKey_.Clone() : null;
      feeExemptKeyList_ = other.feeExemptKeyList_.Clone();
      customFees_ = other.customFees_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ConsensusCreateTopicTransactionBody Clone() {
      return new ConsensusCreateTopicTransactionBody(this);
    }

    /// <summary>Field number for the "memo" field.</summary>
    public const int MemoFieldNumber = 1;
    private string memo_ = "";
    /// <summary>
    ///*
    /// A short memo for this topic.
    /// &lt;p>
    /// This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
    /// (default 100) bytes when encoded as UTF-8.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Memo {
      get { return memo_; }
      set {
        memo_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "adminKey" field.</summary>
    public const int AdminKeyFieldNumber = 2;
    private global::Proto.Key adminKey_;
    /// <summary>
    ///*
    /// Access control for modification of the topic after it is created.
    /// &lt;p>
    /// If this field is set, that key MUST sign this transaction.&lt;br/>
    /// If this field is set, that key MUST sign each future transaction to
    /// update or delete the topic.&lt;br/>
    /// An updateTopic transaction that _only_ extends the topic expirationTime
    /// (a "manual renewal" transaction) SHALL NOT require admin key
    /// signature.&lt;br/>
    /// A topic without an admin key SHALL be immutable, except for expiration
    /// and renewal.&lt;br/>
    /// If adminKey is not set, then `autoRenewAccount` SHALL NOT be set.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.Key AdminKey {
      get { return adminKey_; }
      set {
        adminKey_ = value;
      }
    }

    /// <summary>Field number for the "submitKey" field.</summary>
    public const int SubmitKeyFieldNumber = 3;
    private global::Proto.Key submitKey_;
    /// <summary>
    ///*
    /// Access control for message submission to the topic.
    /// &lt;p>
    /// If this field is set, that key MUST sign each consensus submit message
    /// for this topic.&lt;br/>
    /// If this field is not set then any account may submit a message on the
    /// topic, without restriction.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.Key SubmitKey {
      get { return submitKey_; }
      set {
        submitKey_ = value;
      }
    }

    /// <summary>Field number for the "autoRenewPeriod" field.</summary>
    public const int AutoRenewPeriodFieldNumber = 6;
    private global::Proto.Duration autoRenewPeriod_;
    /// <summary>
    ///*
    /// The initial lifetime, in seconds, for the topic.&lt;br/>
    /// This is also the number of seconds for which the topic SHALL be
    /// automatically renewed upon expiring, if it has a valid auto-renew
    /// account.
    /// &lt;p>
    /// This value MUST be set.&lt;br/>
    /// This value MUST be greater than the configured
    /// MIN_AUTORENEW_PERIOD.&lt;br/>
    /// This value MUST be less than the configured MAX_AUTORENEW_PERIOD.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.Duration AutoRenewPeriod {
      get { return autoRenewPeriod_; }
      set {
        autoRenewPeriod_ = value;
      }
    }

    /// <summary>Field number for the "autoRenewAccount" field.</summary>
    public const int AutoRenewAccountFieldNumber = 7;
    private global::Proto.AccountID autoRenewAccount_;
    /// <summary>
    ///*
    /// The ID of the account to be charged renewal fees at the topic's
    /// expirationTime to extend the lifetime of the topic.
    /// &lt;p>
    /// The topic lifetime SHALL be extended by the smallest of the following:
    /// &lt;ul>
    ///   &lt;li>The current `autoRenewPeriod` duration.&lt;/li>
    ///   &lt;li>The maximum duration that this account has funds to purchase.&lt;/li>
    ///   &lt;li>The configured MAX_AUTORENEW_PERIOD at the time of automatic
    ///       renewal.&lt;/li>
    /// &lt;/ul>
    /// If this value is set, the referenced account MUST sign this
    /// transaction.&lt;br/>
    /// If this value is set, the `adminKey` field MUST also be set (though that
    /// key MAY not have any correlation to this account).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.AccountID AutoRenewAccount {
      get { return autoRenewAccount_; }
      set {
        autoRenewAccount_ = value;
      }
    }

    /// <summary>Field number for the "fee_schedule_key" field.</summary>
    public const int FeeScheduleKeyFieldNumber = 8;
    private global::Proto.Key feeScheduleKey_;
    /// <summary>
    ///*
    /// Access control for update or delete of custom fees.
    /// &lt;p>
    /// If set, subsequent `consensus_update_topic` transactions signed with this
    /// key MAY update or delete the custom fees for this topic.&lt;br/>
    /// If not set, the custom fees for this topic SHALL BE immutable.&lt;br/>
    /// If not set when the topic is created, this field CANNOT be set via
    /// update.&lt;br/>
    /// If set when the topic is created, this field MAY be changed via update.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.Key FeeScheduleKey {
      get { return feeScheduleKey_; }
      set {
        feeScheduleKey_ = value;
      }
    }

    /// <summary>Field number for the "fee_exempt_key_list" field.</summary>
    public const int FeeExemptKeyListFieldNumber = 9;
    private static readonly pb::FieldCodec<global::Proto.Key> _repeated_feeExemptKeyList_codec
        = pb::FieldCodec.ForMessage(74, global::Proto.Key.Parser);
    private readonly pbc::RepeatedField<global::Proto.Key> feeExemptKeyList_ = new pbc::RepeatedField<global::Proto.Key>();
    /// <summary>
    ///*
    /// A set of keys.&lt;br/>
    /// Keys in this list are permitted to submit messages to this topic without
    /// paying custom fees associated with this topic.
    /// &lt;p>
    /// If a submit transaction is signed by _any_ key included in this set,
    /// custom fees SHALL NOT be charged for that transaction.&lt;br/>
    /// This field MUST NOT contain more than 10 keys.&lt;br/>
    /// fee_exempt_key_list SHALL NOT contain any duplicate keys.&lt;br/>
    /// fee_exempt_key_list MAY contain keys for accounts that are inactive,
    /// deleted, or non-existent.&lt;br/>
    /// If fee_exempt_key_list is unset in this transaction, there SHALL NOT be
    /// any fee-exempt keys.  In particular, the following keys SHALL NOT be
    /// implicitly or automatically added to this list:
    /// `adminKey`, `submitKey`, `fee_schedule_key`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Proto.Key> FeeExemptKeyList {
      get { return feeExemptKeyList_; }
    }

    /// <summary>Field number for the "custom_fees" field.</summary>
    public const int CustomFeesFieldNumber = 10;
    private static readonly pb::FieldCodec<global::Proto.FixedCustomFee> _repeated_customFees_codec
        = pb::FieldCodec.ForMessage(82, global::Proto.FixedCustomFee.Parser);
    private readonly pbc::RepeatedField<global::Proto.FixedCustomFee> customFees_ = new pbc::RepeatedField<global::Proto.FixedCustomFee>();
    /// <summary>
    ///*
    /// A set of custom fee definitions.&lt;br/>
    /// These are fees to be assessed for each submit to this topic.
    /// &lt;p>
    /// Each fee defined in this set SHALL be evaluated for
    /// each message submitted to this topic, and the resultant
    /// total assessed fees SHALL be charged.&lt;br/>
    /// Custom fees defined here SHALL be assessed in addition to the base
    /// network and node fees.&lt;br/>
    /// custom_fees list SHALL NOT contain more than
    /// `MAX_CUSTOM_FEE_ENTRIES_FOR_TOPICS` entries.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Proto.FixedCustomFee> CustomFees {
      get { return customFees_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ConsensusCreateTopicTransactionBody);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ConsensusCreateTopicTransactionBody other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Memo != other.Memo) return false;
      if (!object.Equals(AdminKey, other.AdminKey)) return false;
      if (!object.Equals(SubmitKey, other.SubmitKey)) return false;
      if (!object.Equals(AutoRenewPeriod, other.AutoRenewPeriod)) return false;
      if (!object.Equals(AutoRenewAccount, other.AutoRenewAccount)) return false;
      if (!object.Equals(FeeScheduleKey, other.FeeScheduleKey)) return false;
      if(!feeExemptKeyList_.Equals(other.feeExemptKeyList_)) return false;
      if(!customFees_.Equals(other.customFees_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Memo.Length != 0) hash ^= Memo.GetHashCode();
      if (adminKey_ != null) hash ^= AdminKey.GetHashCode();
      if (submitKey_ != null) hash ^= SubmitKey.GetHashCode();
      if (autoRenewPeriod_ != null) hash ^= AutoRenewPeriod.GetHashCode();
      if (autoRenewAccount_ != null) hash ^= AutoRenewAccount.GetHashCode();
      if (feeScheduleKey_ != null) hash ^= FeeScheduleKey.GetHashCode();
      hash ^= feeExemptKeyList_.GetHashCode();
      hash ^= customFees_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Memo.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Memo);
      }
      if (adminKey_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(AdminKey);
      }
      if (submitKey_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(SubmitKey);
      }
      if (autoRenewPeriod_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(AutoRenewPeriod);
      }
      if (autoRenewAccount_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(AutoRenewAccount);
      }
      if (feeScheduleKey_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(FeeScheduleKey);
      }
      feeExemptKeyList_.WriteTo(output, _repeated_feeExemptKeyList_codec);
      customFees_.WriteTo(output, _repeated_customFees_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Memo.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Memo);
      }
      if (adminKey_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(AdminKey);
      }
      if (submitKey_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(SubmitKey);
      }
      if (autoRenewPeriod_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(AutoRenewPeriod);
      }
      if (autoRenewAccount_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(AutoRenewAccount);
      }
      if (feeScheduleKey_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(FeeScheduleKey);
      }
      feeExemptKeyList_.WriteTo(ref output, _repeated_feeExemptKeyList_codec);
      customFees_.WriteTo(ref output, _repeated_customFees_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Memo.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Memo);
      }
      if (adminKey_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(AdminKey);
      }
      if (submitKey_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SubmitKey);
      }
      if (autoRenewPeriod_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(AutoRenewPeriod);
      }
      if (autoRenewAccount_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(AutoRenewAccount);
      }
      if (feeScheduleKey_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(FeeScheduleKey);
      }
      size += feeExemptKeyList_.CalculateSize(_repeated_feeExemptKeyList_codec);
      size += customFees_.CalculateSize(_repeated_customFees_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ConsensusCreateTopicTransactionBody other) {
      if (other == null) {
        return;
      }
      if (other.Memo.Length != 0) {
        Memo = other.Memo;
      }
      if (other.adminKey_ != null) {
        if (adminKey_ == null) {
          AdminKey = new global::Proto.Key();
        }
        AdminKey.MergeFrom(other.AdminKey);
      }
      if (other.submitKey_ != null) {
        if (submitKey_ == null) {
          SubmitKey = new global::Proto.Key();
        }
        SubmitKey.MergeFrom(other.SubmitKey);
      }
      if (other.autoRenewPeriod_ != null) {
        if (autoRenewPeriod_ == null) {
          AutoRenewPeriod = new global::Proto.Duration();
        }
        AutoRenewPeriod.MergeFrom(other.AutoRenewPeriod);
      }
      if (other.autoRenewAccount_ != null) {
        if (autoRenewAccount_ == null) {
          AutoRenewAccount = new global::Proto.AccountID();
        }
        AutoRenewAccount.MergeFrom(other.AutoRenewAccount);
      }
      if (other.feeScheduleKey_ != null) {
        if (feeScheduleKey_ == null) {
          FeeScheduleKey = new global::Proto.Key();
        }
        FeeScheduleKey.MergeFrom(other.FeeScheduleKey);
      }
      feeExemptKeyList_.Add(other.feeExemptKeyList_);
      customFees_.Add(other.customFees_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Memo = input.ReadString();
            break;
          }
          case 18: {
            if (adminKey_ == null) {
              AdminKey = new global::Proto.Key();
            }
            input.ReadMessage(AdminKey);
            break;
          }
          case 26: {
            if (submitKey_ == null) {
              SubmitKey = new global::Proto.Key();
            }
            input.ReadMessage(SubmitKey);
            break;
          }
          case 50: {
            if (autoRenewPeriod_ == null) {
              AutoRenewPeriod = new global::Proto.Duration();
            }
            input.ReadMessage(AutoRenewPeriod);
            break;
          }
          case 58: {
            if (autoRenewAccount_ == null) {
              AutoRenewAccount = new global::Proto.AccountID();
            }
            input.ReadMessage(AutoRenewAccount);
            break;
          }
          case 66: {
            if (feeScheduleKey_ == null) {
              FeeScheduleKey = new global::Proto.Key();
            }
            input.ReadMessage(FeeScheduleKey);
            break;
          }
          case 74: {
            feeExemptKeyList_.AddEntriesFrom(input, _repeated_feeExemptKeyList_codec);
            break;
          }
          case 82: {
            customFees_.AddEntriesFrom(input, _repeated_customFees_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Memo = input.ReadString();
            break;
          }
          case 18: {
            if (adminKey_ == null) {
              AdminKey = new global::Proto.Key();
            }
            input.ReadMessage(AdminKey);
            break;
          }
          case 26: {
            if (submitKey_ == null) {
              SubmitKey = new global::Proto.Key();
            }
            input.ReadMessage(SubmitKey);
            break;
          }
          case 50: {
            if (autoRenewPeriod_ == null) {
              AutoRenewPeriod = new global::Proto.Duration();
            }
            input.ReadMessage(AutoRenewPeriod);
            break;
          }
          case 58: {
            if (autoRenewAccount_ == null) {
              AutoRenewAccount = new global::Proto.AccountID();
            }
            input.ReadMessage(AutoRenewAccount);
            break;
          }
          case 66: {
            if (feeScheduleKey_ == null) {
              FeeScheduleKey = new global::Proto.Key();
            }
            input.ReadMessage(FeeScheduleKey);
            break;
          }
          case 74: {
            feeExemptKeyList_.AddEntriesFrom(ref input, _repeated_feeExemptKeyList_codec);
            break;
          }
          case 82: {
            customFees_.AddEntriesFrom(ref input, _repeated_customFees_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  #endregion

}

#endregion Designer generated code
