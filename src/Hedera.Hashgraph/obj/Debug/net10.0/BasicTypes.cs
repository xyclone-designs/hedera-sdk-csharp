// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: basic_types.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021, 8981
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Proto {

  /// <summary>Holder for reflection information generated from basic_types.proto</summary>
  public static partial class BasicTypesReflection {

    #region Descriptor
    /// <summary>File descriptor for basic_types.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static BasicTypesReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "ChFiYXNpY190eXBlcy5wcm90bxIFcHJvdG8aD3RpbWVzdGFtcC5wcm90bxoe",
            "Z29vZ2xlL3Byb3RvYnVmL3dyYXBwZXJzLnByb3RvIhsKB1NoYXJkSUQSEAoI",
            "c2hhcmROdW0YASABKAMiLQoHUmVhbG1JRBIQCghzaGFyZE51bRgBIAEoAxIQ",
            "CghyZWFsbU51bRgCIAEoAyI/CgdUb2tlbklEEhAKCHNoYXJkTnVtGAEgASgD",
            "EhAKCHJlYWxtTnVtGAIgASgDEhAKCHRva2VuTnVtGAMgASgDImEKCUFjY291",
            "bnRJRBIQCghzaGFyZE51bRgBIAEoAxIQCghyZWFsbU51bRgCIAEoAxIUCgph",
            "Y2NvdW50TnVtGAMgASgDSAASDwoFYWxpYXMYBCABKAxIAEIJCgdhY2NvdW50",
            "IkAKBU5mdElEEiAKCHRva2VuX0lEGAEgASgLMg4ucHJvdG8uVG9rZW5JRBIV",
            "Cg1zZXJpYWxfbnVtYmVyGAIgASgDIj0KBkZpbGVJRBIQCghzaGFyZE51bRgB",
            "IAEoAxIQCghyZWFsbU51bRgCIAEoAxIPCgdmaWxlTnVtGAMgASgDImoKCkNv",
            "bnRyYWN0SUQSEAoIc2hhcmROdW0YASABKAMSEAoIcmVhbG1OdW0YAiABKAMS",
            "FQoLY29udHJhY3ROdW0YAyABKANIABIVCgtldm1fYWRkcmVzcxgEIAEoDEgA",
            "QgoKCGNvbnRyYWN0Ij8KB1RvcGljSUQSEAoIc2hhcmROdW0YASABKAMSEAoI",
            "cmVhbG1OdW0YAiABKAMSEAoIdG9waWNOdW0YAyABKAMiRQoKU2NoZWR1bGVJ",
            "RBIQCghzaGFyZE51bRgBIAEoAxIQCghyZWFsbU51bRgCIAEoAxITCgtzY2hl",
            "ZHVsZU51bRgDIAEoAyKHAQoNVHJhbnNhY3Rpb25JRBIvChV0cmFuc2FjdGlv",
            "blZhbGlkU3RhcnQYASABKAsyEC5wcm90by5UaW1lc3RhbXASIwoJYWNjb3Vu",
            "dElEGAIgASgLMhAucHJvdG8uQWNjb3VudElEEhEKCXNjaGVkdWxlZBgDIAEo",
            "CBINCgVub25jZRgEIAEoBSJBCgZIb29rSWQSJgoJZW50aXR5X2lkGAEgASgL",
            "MhMucHJvdG8uSG9va0VudGl0eUlkEg8KB2hvb2tfaWQYAiABKAMibQoMSG9v",
            "a0VudGl0eUlkEiYKCmFjY291bnRfaWQYASABKAsyEC5wcm90by5BY2NvdW50",
            "SURIABIoCgtjb250cmFjdF9pZBgCIAEoCzIRLnByb3RvLkNvbnRyYWN0SURI",
            "AEILCgllbnRpdHlfaWQiXQoISG9va0NhbGwSEQoHaG9va19pZBgBIAEoA0gA",
            "EisKDWV2bV9ob29rX2NhbGwYAyABKAsyEi5wcm90by5Fdm1Ib29rQ2FsbEgB",
            "QgQKAmlkQgsKCWNhbGxfc3BlYyIuCgtFdm1Ib29rQ2FsbBIMCgRkYXRhGAEg",
            "ASgMEhEKCWdhc19saW1pdBgCIAEoBCLPAQoNQWNjb3VudEFtb3VudBIjCglh",
            "Y2NvdW50SUQYASABKAsyEC5wcm90by5BY2NvdW50SUQSDgoGYW1vdW50GAIg",
            "ASgSEhMKC2lzX2FwcHJvdmFsGAMgASgIEjAKFXByZV90eF9hbGxvd2FuY2Vf",
            "aG9vaxgEIAEoCzIPLnByb3RvLkhvb2tDYWxsSAASNQoacHJlX3Bvc3RfdHhf",
            "YWxsb3dhbmNlX2hvb2sYBSABKAsyDy5wcm90by5Ib29rQ2FsbEgAQgsKCWhv",
            "b2tfY2FsbCI8CgxUcmFuc2Zlckxpc3QSLAoOYWNjb3VudEFtb3VudHMYASAD",
            "KAsyFC5wcm90by5BY2NvdW50QW1vdW50IsADCgtOZnRUcmFuc2ZlchIpCg9z",
            "ZW5kZXJBY2NvdW50SUQYASABKAsyEC5wcm90by5BY2NvdW50SUQSKwoRcmVj",
            "ZWl2ZXJBY2NvdW50SUQYAiABKAsyEC5wcm90by5BY2NvdW50SUQSFAoMc2Vy",
            "aWFsTnVtYmVyGAMgASgDEhMKC2lzX2FwcHJvdmFsGAQgASgIEjcKHHByZV90",
            "eF9zZW5kZXJfYWxsb3dhbmNlX2hvb2sYBSABKAsyDy5wcm90by5Ib29rQ2Fs",
            "bEgAEjwKIXByZV9wb3N0X3R4X3NlbmRlcl9hbGxvd2FuY2VfaG9vaxgGIAEo",
            "CzIPLnByb3RvLkhvb2tDYWxsSAASOQoecHJlX3R4X3JlY2VpdmVyX2FsbG93",
            "YW5jZV9ob29rGAcgASgLMg8ucHJvdG8uSG9va0NhbGxIARI+CiNwcmVfcG9z",
            "dF90eF9yZWNlaXZlcl9hbGxvd2FuY2VfaG9vaxgIIAEoCzIPLnByb3RvLkhv",
            "b2tDYWxsSAFCHAoac2VuZGVyX2FsbG93YW5jZV9ob29rX2NhbGxCHgoccmVj",
            "ZWl2ZXJfYWxsb3dhbmNlX2hvb2tfY2FsbCK+AQoRVG9rZW5UcmFuc2Zlckxp",
            "c3QSHQoFdG9rZW4YASABKAsyDi5wcm90by5Ub2tlbklEEicKCXRyYW5zZmVy",
            "cxgCIAMoCzIULnByb3RvLkFjY291bnRBbW91bnQSKAoMbmZ0VHJhbnNmZXJz",
            "GAMgAygLMhIucHJvdG8uTmZ0VHJhbnNmZXISNwoRZXhwZWN0ZWRfZGVjaW1h",
            "bHMYBCABKAsyHC5nb29nbGUucHJvdG9idWYuVUludDMyVmFsdWUiMgoIRnJh",
            "Y3Rpb24SEQoJbnVtZXJhdG9yGAEgASgDEhMKC2Rlbm9taW5hdG9yGAIgASgD",
            "IpoCCgNLZXkSJwoKY29udHJhY3RJRBgBIAEoCzIRLnByb3RvLkNvbnRyYWN0",
            "SURIABIRCgdlZDI1NTE5GAIgASgMSAASFgoIUlNBXzMwNzIYAyABKAxCAhgB",
            "SAASFwoJRUNEU0FfMzg0GAQgASgMQgIYAUgAEisKDHRocmVzaG9sZEtleRgF",
            "IAEoCzITLnByb3RvLlRocmVzaG9sZEtleUgAEiEKB2tleUxpc3QYBiABKAsy",
            "Di5wcm90by5LZXlMaXN0SAASGQoPRUNEU0Ffc2VjcDI1NmsxGAcgASgMSAAS",
            "NAoXZGVsZWdhdGFibGVfY29udHJhY3RfaWQYCCABKAsyES5wcm90by5Db250",
            "cmFjdElESABCBQoDa2V5Ij8KDFRocmVzaG9sZEtleRIRCgl0aHJlc2hvbGQY",
            "ASABKA0SHAoEa2V5cxgCIAEoCzIOLnByb3RvLktleUxpc3QiIwoHS2V5TGlz",
            "dBIYCgRrZXlzGAEgAygLMgoucHJvdG8uS2V5ItQBCglTaWduYXR1cmUSEgoI",
            "Y29udHJhY3QYASABKAxIABIRCgdlZDI1NTE5GAIgASgMSAASEgoIUlNBXzMw",
            "NzIYAyABKAxIABITCglFQ0RTQV8zODQYBCABKAxIABI3ChJ0aHJlc2hvbGRT",
            "aWduYXR1cmUYBSABKAsyGS5wcm90by5UaHJlc2hvbGRTaWduYXR1cmVIABIt",
            "Cg1zaWduYXR1cmVMaXN0GAYgASgLMhQucHJvdG8uU2lnbmF0dXJlTGlzdEgA",
            "OgIYAUILCglzaWduYXR1cmUiPAoSVGhyZXNob2xkU2lnbmF0dXJlEiIKBHNp",
            "Z3MYAiABKAsyFC5wcm90by5TaWduYXR1cmVMaXN0OgIYASIzCg1TaWduYXR1",
            "cmVMaXN0Eh4KBHNpZ3MYAiADKAsyEC5wcm90by5TaWduYXR1cmU6AhgBIqUB",
            "Cg1TaWduYXR1cmVQYWlyEhQKDHB1YktleVByZWZpeBgBIAEoDBISCghjb250",
            "cmFjdBgCIAEoDEgAEhEKB2VkMjU1MTkYAyABKAxIABIWCghSU0FfMzA3MhgE",
            "IAEoDEICGAFIABIXCglFQ0RTQV8zODQYBSABKAxCAhgBSAASGQoPRUNEU0Ff",
            "c2VjcDI1NmsxGAYgASgMSABCCwoJc2lnbmF0dXJlIjUKDFNpZ25hdHVyZU1h",
            "cBIlCgdzaWdQYWlyGAEgAygLMhQucHJvdG8uU2lnbmF0dXJlUGFpciKjAQoN",
            "RmVlQ29tcG9uZW50cxILCgNtaW4YASABKAMSCwoDbWF4GAIgASgDEhAKCGNv",
            "bnN0YW50GAMgASgDEgsKA2JwdBgEIAEoAxILCgN2cHQYBSABKAMSCwoDcmJo",
            "GAYgASgDEgsKA3NiaBgHIAEoAxILCgNnYXMYCCABKAMSCgoCdHYYCSABKAMS",
            "CwoDYnByGAogASgDEgwKBHNicHIYCyABKAMilAEKFlRyYW5zYWN0aW9uRmVl",
            "U2NoZWR1bGUSNwoTaGVkZXJhRnVuY3Rpb25hbGl0eRgBIAEoDjIaLnByb3Rv",
            "LkhlZGVyYUZ1bmN0aW9uYWxpdHkSIwoHZmVlRGF0YRgCIAEoCzIOLnByb3Rv",
            "LkZlZURhdGFCAhgBEhwKBGZlZXMYAyADKAsyDi5wcm90by5GZWVEYXRhIqgB",
            "CgdGZWVEYXRhEiYKCG5vZGVkYXRhGAEgASgLMhQucHJvdG8uRmVlQ29tcG9u",
            "ZW50cxIpCgtuZXR3b3JrZGF0YRgCIAEoCzIULnByb3RvLkZlZUNvbXBvbmVu",
            "dHMSKQoLc2VydmljZWRhdGEYAyABKAsyFC5wcm90by5GZWVDb21wb25lbnRz",
            "Eh8KB3N1YlR5cGUYBCABKA4yDi5wcm90by5TdWJUeXBlInkKC0ZlZVNjaGVk",
            "dWxlEj0KFnRyYW5zYWN0aW9uRmVlU2NoZWR1bGUYASADKAsyHS5wcm90by5U",
            "cmFuc2FjdGlvbkZlZVNjaGVkdWxlEisKCmV4cGlyeVRpbWUYAiABKAsyFy5w",
            "cm90by5UaW1lc3RhbXBTZWNvbmRzIngKGUN1cnJlbnRBbmROZXh0RmVlU2No",
            "ZWR1bGUSLgoSY3VycmVudEZlZVNjaGVkdWxlGAEgASgLMhIucHJvdG8uRmVl",
            "U2NoZWR1bGUSKwoPbmV4dEZlZVNjaGVkdWxlGAIgASgLMhIucHJvdG8uRmVl",
            "U2NoZWR1bGUiSQoPU2VydmljZUVuZHBvaW50EhMKC2lwQWRkcmVzc1Y0GAEg",
            "ASgMEgwKBHBvcnQYAiABKAUSEwoLZG9tYWluX25hbWUYAyABKAkihgIKC05v",
            "ZGVBZGRyZXNzEhUKCWlwQWRkcmVzcxgBIAEoDEICGAESEgoGcG9ydG5vGAIg",
            "ASgFQgIYARIQCgRtZW1vGAMgASgMQgIYARISCgpSU0FfUHViS2V5GAQgASgJ",
            "Eg4KBm5vZGVJZBgFIAEoAxInCg1ub2RlQWNjb3VudElkGAYgASgLMhAucHJv",
            "dG8uQWNjb3VudElEEhQKDG5vZGVDZXJ0SGFzaBgHIAEoDBIvCg9zZXJ2aWNl",
            "RW5kcG9pbnQYCCADKAsyFi5wcm90by5TZXJ2aWNlRW5kcG9pbnQSEwoLZGVz",
            "Y3JpcHRpb24YCSABKAkSEQoFc3Rha2UYCiABKANCAhgBIjoKD05vZGVBZGRy",
            "ZXNzQm9vaxInCgtub2RlQWRkcmVzcxgBIAMoCzISLnByb3RvLk5vZGVBZGRy",
            "ZXNzIloKD1NlbWFudGljVmVyc2lvbhINCgVtYWpvchgBIAEoBRINCgVtaW5v",
            "chgCIAEoBRINCgVwYXRjaBgDIAEoBRILCgNwcmUYBCABKAkSDQoFYnVpbGQY",
            "BSABKAkiNAoHU2V0dGluZxIMCgRuYW1lGAEgASgJEg0KBXZhbHVlGAIgASgJ",
            "EgwKBGRhdGEYAyABKAwiPgoZU2VydmljZXNDb25maWd1cmF0aW9uTGlzdBIh",
            "CgluYW1lVmFsdWUYASADKAsyDi5wcm90by5TZXR0aW5nIuABChFUb2tlblJl",
            "bGF0aW9uc2hpcBIfCgd0b2tlbklkGAEgASgLMg4ucHJvdG8uVG9rZW5JRBIO",
            "CgZzeW1ib2wYAiABKAkSDwoHYmFsYW5jZRgDIAEoBBIoCglreWNTdGF0dXMY",
            "BCABKA4yFS5wcm90by5Ub2tlbkt5Y1N0YXR1cxIuCgxmcmVlemVTdGF0dXMY",
            "BSABKA4yGC5wcm90by5Ub2tlbkZyZWV6ZVN0YXR1cxIQCghkZWNpbWFscxgG",
            "IAEoDRIdChVhdXRvbWF0aWNfYXNzb2NpYXRpb24YByABKAgiUgoMVG9rZW5C",
            "YWxhbmNlEh8KB3Rva2VuSWQYASABKAsyDi5wcm90by5Ub2tlbklEEg8KB2Jh",
            "bGFuY2UYAiABKAQSEAoIZGVjaW1hbHMYAyABKA0iOwoNVG9rZW5CYWxhbmNl",
            "cxIqCg10b2tlbkJhbGFuY2VzGAEgAygLMhMucHJvdG8uVG9rZW5CYWxhbmNl",
            "IloKEFRva2VuQXNzb2NpYXRpb24SIAoIdG9rZW5faWQYASABKAsyDi5wcm90",
            "by5Ub2tlbklEEiQKCmFjY291bnRfaWQYAiABKAsyEC5wcm90by5BY2NvdW50",
            "SUQi1wEKC1N0YWtpbmdJbmZvEhYKDmRlY2xpbmVfcmV3YXJkGAEgASgIEiwK",
            "EnN0YWtlX3BlcmlvZF9zdGFydBgCIAEoCzIQLnByb3RvLlRpbWVzdGFtcBIW",
            "Cg5wZW5kaW5nX3Jld2FyZBgDIAEoAxIUCgxzdGFrZWRfdG9fbWUYBCABKAMS",
            "LQoRc3Rha2VkX2FjY291bnRfaWQYBSABKAsyEC5wcm90by5BY2NvdW50SURI",
            "ABIYCg5zdGFrZWRfbm9kZV9pZBgGIAEoA0gAQgsKCXN0YWtlZF9pZCLMAQoQ",
            "UGVuZGluZ0FpcmRyb3BJZBIjCglzZW5kZXJfaWQYASABKAsyEC5wcm90by5B",
            "Y2NvdW50SUQSJQoLcmVjZWl2ZXJfaWQYAiABKAsyEC5wcm90by5BY2NvdW50",
            "SUQSLQoTZnVuZ2libGVfdG9rZW5fdHlwZRgDIAEoCzIOLnByb3RvLlRva2Vu",
            "SURIABIqChJub25fZnVuZ2libGVfdG9rZW4YBCABKAsyDC5wcm90by5OZnRJ",
            "REgAQhEKD3Rva2VuX3JlZmVyZW5jZSIlChNQZW5kaW5nQWlyZHJvcFZhbHVl",
            "Eg4KBmFtb3VudBgBIAEoBCoiChJCbG9ja0hhc2hBbGdvcml0aG0SDAoIU0hB",
            "Ml8zODQQACo5CglUb2tlblR5cGUSEwoPRlVOR0lCTEVfQ09NTU9OEAASFwoT",
            "Tk9OX0ZVTkdJQkxFX1VOSVFVRRABKpcCCgdTdWJUeXBlEgsKB0RFRkFVTFQQ",
            "ABIZChVUT0tFTl9GVU5HSUJMRV9DT01NT04QARIdChlUT0tFTl9OT05fRlVO",
            "R0lCTEVfVU5JUVVFEAISKgomVE9LRU5fRlVOR0lCTEVfQ09NTU9OX1dJVEhf",
            "Q1VTVE9NX0ZFRVMQAxIuCipUT0tFTl9OT05fRlVOR0lCTEVfVU5JUVVFX1dJ",
            "VEhfQ1VTVE9NX0ZFRVMQBBIhCh1TQ0hFRFVMRV9DUkVBVEVfQ09OVFJBQ1Rf",
            "Q0FMTBAFEiEKHVRPUElDX0NSRUFURV9XSVRIX0NVU1RPTV9GRUVTEAYSIwof",
            "U1VCTUlUX01FU1NBR0VfV0lUSF9DVVNUT01fRkVFUxAHKisKD1Rva2VuU3Vw",
            "cGx5VHlwZRIMCghJTkZJTklURRAAEgoKBkZJTklURRABKjwKElRva2VuS2V5",
            "VmFsaWRhdGlvbhITCg9GVUxMX1ZBTElEQVRJT04QABIRCg1OT19WQUxJREFU",
            "SU9OEAEqRgoRVG9rZW5GcmVlemVTdGF0dXMSFwoTRnJlZXplTm90QXBwbGlj",
            "YWJsZRAAEgoKBkZyb3plbhABEgwKCFVuZnJvemVuEAIqQAoOVG9rZW5LeWNT",
            "dGF0dXMSFAoQS3ljTm90QXBwbGljYWJsZRAAEgsKB0dyYW50ZWQQARILCgdS",
            "ZXZva2VkEAIqRAoQVG9rZW5QYXVzZVN0YXR1cxIWChJQYXVzZU5vdEFwcGxp",
            "Y2FibGUQABIKCgZQYXVzZWQQARIMCghVbnBhdXNlZBACKrEQChNIZWRlcmFG",
            "dW5jdGlvbmFsaXR5EggKBE5PTkUQABISCg5DcnlwdG9UcmFuc2ZlchABEhAK",
            "DENyeXB0b1VwZGF0ZRACEhAKDENyeXB0b0RlbGV0ZRADEhkKEUNyeXB0b0Fk",
            "ZExpdmVIYXNoEAQaAggBEhwKFENyeXB0b0RlbGV0ZUxpdmVIYXNoEAUaAggB",
            "EhAKDENvbnRyYWN0Q2FsbBAGEhIKDkNvbnRyYWN0Q3JlYXRlEAcSEgoOQ29u",
            "dHJhY3RVcGRhdGUQCBIOCgpGaWxlQ3JlYXRlEAkSDgoKRmlsZUFwcGVuZBAK",
            "Eg4KCkZpbGVVcGRhdGUQCxIOCgpGaWxlRGVsZXRlEAwSGwoXQ3J5cHRvR2V0",
            "QWNjb3VudEJhbGFuY2UQDRIbChdDcnlwdG9HZXRBY2NvdW50UmVjb3JkcxAO",
            "EhEKDUNyeXB0b0dldEluZm8QDxIVChFDb250cmFjdENhbGxMb2NhbBAQEhMK",
            "D0NvbnRyYWN0R2V0SW5mbxAREhcKE0NvbnRyYWN0R2V0Qnl0ZWNvZGUQEhIT",
            "Cg9HZXRCeVNvbGlkaXR5SUQQExIMCghHZXRCeUtleRAUEhkKEUNyeXB0b0dl",
            "dExpdmVIYXNoEBUaAggBEhgKEENyeXB0b0dldFN0YWtlcnMQFhoCCAESEwoP",
            "RmlsZUdldENvbnRlbnRzEBcSDwoLRmlsZUdldEluZm8QGBIYChRUcmFuc2Fj",
            "dGlvbkdldFJlY29yZBAZEhoKEkNvbnRyYWN0R2V0UmVjb3JkcxAaGgIIARIQ",
            "CgxDcnlwdG9DcmVhdGUQGxIQCgxTeXN0ZW1EZWxldGUQHBISCg5TeXN0ZW1V",
            "bmRlbGV0ZRAdEhIKDkNvbnRyYWN0RGVsZXRlEB4SCgoGRnJlZXplEB8SGwoX",
            "Q3JlYXRlVHJhbnNhY3Rpb25SZWNvcmQQIBIaChZDcnlwdG9BY2NvdW50QXV0",
            "b1JlbmV3ECESFQoRQ29udHJhY3RBdXRvUmVuZXcQIhISCg5HZXRWZXJzaW9u",
            "SW5mbxAjEhkKFVRyYW5zYWN0aW9uR2V0UmVjZWlwdBAkEhgKFENvbnNlbnN1",
            "c0NyZWF0ZVRvcGljEDISGAoUQ29uc2Vuc3VzVXBkYXRlVG9waWMQMxIYChRD",
            "b25zZW5zdXNEZWxldGVUb3BpYxA0EhkKFUNvbnNlbnN1c0dldFRvcGljSW5m",
            "bxA1EhoKFkNvbnNlbnN1c1N1Ym1pdE1lc3NhZ2UQNhITCg9VbmNoZWNrZWRT",
            "dWJtaXQQNxIPCgtUb2tlbkNyZWF0ZRA4EhAKDFRva2VuR2V0SW5mbxA6EhYK",
            "ElRva2VuRnJlZXplQWNjb3VudBA7EhgKFFRva2VuVW5mcmVlemVBY2NvdW50",
            "EDwSGgoWVG9rZW5HcmFudEt5Y1RvQWNjb3VudBA9Eh0KGVRva2VuUmV2b2tl",
            "S3ljRnJvbUFjY291bnQQPhIPCgtUb2tlbkRlbGV0ZRA/Eg8KC1Rva2VuVXBk",
            "YXRlEEASDQoJVG9rZW5NaW50EEESDQoJVG9rZW5CdXJuEEISFAoQVG9rZW5B",
            "Y2NvdW50V2lwZRBDEhsKF1Rva2VuQXNzb2NpYXRlVG9BY2NvdW50EEQSHgoa",
            "VG9rZW5EaXNzb2NpYXRlRnJvbUFjY291bnQQRRISCg5TY2hlZHVsZUNyZWF0",
            "ZRBGEhIKDlNjaGVkdWxlRGVsZXRlEEcSEAoMU2NoZWR1bGVTaWduEEgSEwoP",
            "U2NoZWR1bGVHZXRJbmZvEEkSHwoXVG9rZW5HZXRBY2NvdW50TmZ0SW5mb3MQ",
            "ShoCCAESFwoPVG9rZW5HZXROZnRJbmZvEEsaAggBEhQKEFRva2VuR2V0TmZ0",
            "SW5mb3MQTBIaChZUb2tlbkZlZVNjaGVkdWxlVXBkYXRlEE0SHwoXTmV0d29y",
            "a0dldEV4ZWN1dGlvblRpbWUQThoCCAESDgoKVG9rZW5QYXVzZRBPEhAKDFRv",
            "a2VuVW5wYXVzZRBQEhoKFkNyeXB0b0FwcHJvdmVBbGxvd2FuY2UQURIZChVD",
            "cnlwdG9EZWxldGVBbGxvd2FuY2UQUhIVChFHZXRBY2NvdW50RGV0YWlscxBT",
            "EhcKE0V0aGVyZXVtVHJhbnNhY3Rpb24QVBITCg9Ob2RlU3Rha2VVcGRhdGUQ",
            "VRIMCghVdGlsUHJuZxBWEiAKGFRyYW5zYWN0aW9uR2V0RmFzdFJlY29yZBBX",
            "GgIIARITCg9Ub2tlblVwZGF0ZU5mdHMQWBIOCgpOb2RlQ3JlYXRlEFkSDgoK",
            "Tm9kZVVwZGF0ZRBaEg4KCk5vZGVEZWxldGUQWxIPCgtUb2tlblJlamVjdBBc",
            "EhAKDFRva2VuQWlyZHJvcBBdEhYKElRva2VuQ2FuY2VsQWlyZHJvcBBeEhUK",
            "EVRva2VuQ2xhaW1BaXJkcm9wEF8SHQoZU3RhdGVTaWduYXR1cmVUcmFuc2Fj",
            "dGlvbhBkEhcKE0hpbnRzS2V5UHVibGljYXRpb24QZRIaChZIaW50c1ByZXBy",
            "b2Nlc3NpbmdWb3RlEGYSGQoVSGludHNQYXJ0aWFsU2lnbmF0dXJlEGcSHAoY",
            "SGlzdG9yeUFzc2VtYmx5U2lnbmF0dXJlEGgSHgoaSGlzdG9yeVByb29mS2V5",
            "UHVibGljYXRpb24QaRIUChBIaXN0b3J5UHJvb2ZWb3RlEGoSEgoOQ3JzUHVi",
            "bGljYXRpb24QaxIPCgtBdG9taWNCYXRjaBBsEhAKDExhbWJkYVNTdG9yZRBt",
            "EhAKDEhvb2tEaXNwYXRjaBBuQiIKHmNvbS5oZWRlcmEuaGFzaGdyYXBoLnNk",
            "ay5wcm90b1ABYgZwcm90bzM="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Proto.TimestampReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.WrappersReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(new[] {typeof(global::Proto.BlockHashAlgorithm), typeof(global::Proto.TokenType), typeof(global::Proto.SubType), typeof(global::Proto.TokenSupplyType), typeof(global::Proto.TokenKeyValidation), typeof(global::Proto.TokenFreezeStatus), typeof(global::Proto.TokenKycStatus), typeof(global::Proto.TokenPauseStatus), typeof(global::Proto.HederaFunctionality), }, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Proto.ShardID), global::Proto.ShardID.Parser, new[]{ "ShardNum" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Proto.RealmID), global::Proto.RealmID.Parser, new[]{ "ShardNum", "RealmNum" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Proto.TokenID), global::Proto.TokenID.Parser, new[]{ "ShardNum", "RealmNum", "TokenNum" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Proto.AccountID), global::Proto.AccountID.Parser, new[]{ "ShardNum", "RealmNum", "AccountNum", "Alias" }, new[]{ "Account" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Proto.NftID), global::Proto.NftID.Parser, new[]{ "TokenID", "SerialNumber" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Proto.FileID), global::Proto.FileID.Parser, new[]{ "ShardNum", "RealmNum", "FileNum" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Proto.ContractID), global::Proto.ContractID.Parser, new[]{ "ShardNum", "RealmNum", "ContractNum", "EvmAddress" }, new[]{ "Contract" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Proto.TopicID), global::Proto.TopicID.Parser, new[]{ "ShardNum", "RealmNum", "TopicNum" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Proto.ScheduleID), global::Proto.ScheduleID.Parser, new[]{ "ShardNum", "RealmNum", "ScheduleNum" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Proto.TransactionID), global::Proto.TransactionID.Parser, new[]{ "TransactionValidStart", "AccountID", "Scheduled", "Nonce" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Proto.HookId), global::Proto.HookId.Parser, new[]{ "EntityId", "HookId_" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Proto.HookEntityId), global::Proto.HookEntityId.Parser, new[]{ "AccountId", "ContractId" }, new[]{ "EntityId" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Proto.HookCall), global::Proto.HookCall.Parser, new[]{ "HookId", "EvmHookCall" }, new[]{ "Id", "CallSpec" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Proto.EvmHookCall), global::Proto.EvmHookCall.Parser, new[]{ "Data", "GasLimit" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Proto.AccountAmount), global::Proto.AccountAmount.Parser, new[]{ "AccountID", "Amount", "IsApproval", "PreTxAllowanceHook", "PrePostTxAllowanceHook" }, new[]{ "HookCall" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Proto.TransferList), global::Proto.TransferList.Parser, new[]{ "AccountAmounts" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Proto.NftTransfer), global::Proto.NftTransfer.Parser, new[]{ "SenderAccountID", "ReceiverAccountID", "SerialNumber", "IsApproval", "PreTxSenderAllowanceHook", "PrePostTxSenderAllowanceHook", "PreTxReceiverAllowanceHook", "PrePostTxReceiverAllowanceHook" }, new[]{ "SenderAllowanceHookCall", "ReceiverAllowanceHookCall" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Proto.TokenTransferList), global::Proto.TokenTransferList.Parser, new[]{ "Token", "Transfers", "NftTransfers", "ExpectedDecimals" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Proto.Fraction), global::Proto.Fraction.Parser, new[]{ "Numerator", "Denominator" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Proto.Key), global::Proto.Key.Parser, new[]{ "ContractID", "Ed25519", "RSA3072", "ECDSA384", "ThresholdKey", "KeyList", "ECDSASecp256K1", "DelegatableContractId" }, new[]{ "Key" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Proto.ThresholdKey), global::Proto.ThresholdKey.Parser, new[]{ "Threshold", "Keys" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Proto.KeyList), global::Proto.KeyList.Parser, new[]{ "Keys" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Proto.Signature), global::Proto.Signature.Parser, new[]{ "Contract", "Ed25519", "RSA3072", "ECDSA384", "ThresholdSignature", "SignatureList" }, new[]{ "Signature" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Proto.ThresholdSignature), global::Proto.ThresholdSignature.Parser, new[]{ "Sigs" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Proto.SignatureList), global::Proto.SignatureList.Parser, new[]{ "Sigs" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Proto.SignaturePair), global::Proto.SignaturePair.Parser, new[]{ "PubKeyPrefix", "Contract", "Ed25519", "RSA3072", "ECDSA384", "ECDSASecp256K1" }, new[]{ "Signature" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Proto.SignatureMap), global::Proto.SignatureMap.Parser, new[]{ "SigPair" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Proto.FeeComponents), global::Proto.FeeComponents.Parser, new[]{ "Min", "Max", "Constant", "Bpt", "Vpt", "Rbh", "Sbh", "Gas", "Tv", "Bpr", "Sbpr" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Proto.TransactionFeeSchedule), global::Proto.TransactionFeeSchedule.Parser, new[]{ "HederaFunctionality", "FeeData", "Fees" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Proto.FeeData), global::Proto.FeeData.Parser, new[]{ "Nodedata", "Networkdata", "Servicedata", "SubType" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Proto.FeeSchedule), global::Proto.FeeSchedule.Parser, new[]{ "TransactionFeeSchedule", "ExpiryTime" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Proto.CurrentAndNextFeeSchedule), global::Proto.CurrentAndNextFeeSchedule.Parser, new[]{ "CurrentFeeSchedule", "NextFeeSchedule" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Proto.ServiceEndpoint), global::Proto.ServiceEndpoint.Parser, new[]{ "IpAddressV4", "Port", "DomainName" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Proto.NodeAddress), global::Proto.NodeAddress.Parser, new[]{ "IpAddress", "Portno", "Memo", "RSAPubKey", "NodeId", "NodeAccountId", "NodeCertHash", "ServiceEndpoint", "Description", "Stake" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Proto.NodeAddressBook), global::Proto.NodeAddressBook.Parser, new[]{ "NodeAddress" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Proto.SemanticVersion), global::Proto.SemanticVersion.Parser, new[]{ "Major", "Minor", "Patch", "Pre", "Build" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Proto.Setting), global::Proto.Setting.Parser, new[]{ "Name", "Value", "Data" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Proto.ServicesConfigurationList), global::Proto.ServicesConfigurationList.Parser, new[]{ "NameValue" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Proto.TokenRelationship), global::Proto.TokenRelationship.Parser, new[]{ "TokenId", "Symbol", "Balance", "KycStatus", "FreezeStatus", "Decimals", "AutomaticAssociation" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Proto.TokenBalance), global::Proto.TokenBalance.Parser, new[]{ "TokenId", "Balance", "Decimals" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Proto.TokenBalances), global::Proto.TokenBalances.Parser, new[]{ "TokenBalances_" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Proto.TokenAssociation), global::Proto.TokenAssociation.Parser, new[]{ "TokenId", "AccountId" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Proto.StakingInfo), global::Proto.StakingInfo.Parser, new[]{ "DeclineReward", "StakePeriodStart", "PendingReward", "StakedToMe", "StakedAccountId", "StakedNodeId" }, new[]{ "StakedId" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Proto.PendingAirdropId), global::Proto.PendingAirdropId.Parser, new[]{ "SenderId", "ReceiverId", "FungibleTokenType", "NonFungibleToken" }, new[]{ "TokenReference" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Proto.PendingAirdropValue), global::Proto.PendingAirdropValue.Parser, new[]{ "Amount" }, null, null, null, null)
          }));
    }
    #endregion

  }
  #region Enums
  /// <summary>
  ///*
  /// A specific hash algorithm.
  ///
  /// We did not reuse Record Stream `HashAlgorithm` here because in all cases,
  /// currently, this will be `SHA2_384` and if that is the default value then
  /// we can save space by not serializing it, whereas `HASH_ALGORITHM_UNKNOWN`
  /// is the default for Record Stream `HashAlgorithm`.
  ///
  /// Note that enum values here MUST NOT match the name of any other enum value
  /// in the same `package`, as protobuf follows `C++` scope rules and all enum
  /// _names_ are treated as global constants within the `package`.
  /// </summary>
  public enum BlockHashAlgorithm {
    /// <summary>
    ///*
    /// A SHA2 algorithm SHA-384 hash.
    /// &lt;p>
    /// This is the default value, if a field of this enumerated type is
    /// not set, then this is the value that will be decoded when the
    /// serialized message is read.
    /// </summary>
    [pbr::OriginalName("SHA2_384")] Sha2384 = 0,
  }

  /// <summary>
  ///*
  /// Possible Token Types (IWA Compatibility).
  ///
  /// Apart from fungible and non-fungible, Tokens can have either a common or
  /// unique representation. Furthermore, tokens can have intrinsic or referential
  /// value, and can be whole and indivisible or fractional.&lt;br/>
  /// These distinction might seem subtle, but it is important when considering
  /// how tokens can be traced, used, transferred, and if they can have isolated
  /// unique properties.
  ///
  /// A few examples (these may not match enumerations below) using IWA taxonomy.
  /// &lt;dl>
  ///   &lt;dt>fungible, whole, intrinsic, unique&lt;/dt>
  ///     &lt;dd>Physical fiat currency&lt;/dd>
  ///   &lt;dt>fungible, fractional, intrinsic, common&lt;/dt>
  ///     &lt;dd>bank balance fiat currency&lt;/dd>
  ///   &lt;dt>non-fungible, fractional, reference, unique&lt;/dt>
  ///     &lt;dd>"mutual" collectible/art/property ownership&lt;/dd>
  ///   &lt;dt>non-fungible, whole, intrinsic, unique&lt;/dt>
  ///     &lt;dd>Physical work of fine art&lt;/dd>
  ///   &lt;dt>non-fungible, whole, reference, unique&lt;/dt>
  ///     &lt;dd>Registered property title&lt;/dd>
  /// &lt;/dl>
  /// </summary>
  public enum TokenType {
    /// <summary>
    ///*
    /// A fungible/common token.&lt;br/>
    /// Tokens of this type are interchangeable with one another, where any
    /// quantity of tokens has the same value as another equal quantity, if
    /// they are in the same class. Tokens share a single set of properties,
    /// and are not distinct from one another. Ownership is represented as a
    /// balance or quantity associated to a given account. Tokens may be
    /// divided into fractional tokens, within reasonable limits.
    /// &lt;p>
    /// IWA taxonomy _fungible, fractional, intrinsic, common_
    /// </summary>
    [pbr::OriginalName("FUNGIBLE_COMMON")] FungibleCommon = 0,
    /// <summary>
    ///*
    /// A non-fungible/unique token.&lt;br/>
    /// Tokens of this type are unique, and are not interchangeable with other
    /// tokens of the same type. Each token carries a serial number which is
    /// unique for that token, these tokens may have a different trade value
    /// for each individual token. The tokens are individually accounted and
    /// often carry additional unique properties. Tokens cannot be subdivided,
    /// and value is related to what the individual token represents.
    /// &lt;p>
    /// IWA taxonomy _non-fungible, whole, reference, unique_
    /// </summary>
    [pbr::OriginalName("NON_FUNGIBLE_UNIQUE")] NonFungibleUnique = 1,
  }

  /// <summary>
  ///*
  /// A transaction sub type.&lt;br/>
  /// This enumeration enables a set of transaction base fees to be broadly
  /// defined for a type of operation and also be modified, when necessary,
  /// based on specifics of the operation.
  ///
  /// ### Explanation
  /// The resource cost for a TokenMint operation is different between minting
  /// fungible/common and non-fungible/unique tokens. This `enum` is used to
  /// "mark" a cost as applying to one or the other.&lt;br/>
  /// Similarly, the resource cost for a basic `tokenCreate` without a custom
  /// fee schedule may yield a _base_ fee of $1. The resource cost for a
  /// `tokenCreate` _with_ a custom fee schedule is different and may yield a
  /// _base_ fee of $2 or more.
  /// </summary>
  public enum SubType {
    /// <summary>
    ///*
    /// The resource cost for the transaction type has no additional attributes
    /// </summary>
    [pbr::OriginalName("DEFAULT")] Default = 0,
    /// <summary>
    ///*
    /// The resource cost for the transaction type includes an operation on a
    /// fungible/common token
    /// </summary>
    [pbr::OriginalName("TOKEN_FUNGIBLE_COMMON")] TokenFungibleCommon = 1,
    /// <summary>
    ///*
    /// The resource cost for the transaction type includes an operation on
    /// a non-fungible/unique token
    /// </summary>
    [pbr::OriginalName("TOKEN_NON_FUNGIBLE_UNIQUE")] TokenNonFungibleUnique = 2,
    /// <summary>
    ///*
    /// The resource cost for the transaction type includes an operation on a
    /// fungible/common token with a custom fee schedule
    /// </summary>
    [pbr::OriginalName("TOKEN_FUNGIBLE_COMMON_WITH_CUSTOM_FEES")] TokenFungibleCommonWithCustomFees = 3,
    /// <summary>
    ///*
    /// The resource cost for the transaction type includes an operation on a
    /// non-fungible/unique token with a custom fee schedule
    /// </summary>
    [pbr::OriginalName("TOKEN_NON_FUNGIBLE_UNIQUE_WITH_CUSTOM_FEES")] TokenNonFungibleUniqueWithCustomFees = 4,
    /// <summary>
    ///*
    /// The resource cost for the transaction type includes a ScheduleCreate
    /// containing a ContractCall.
    /// </summary>
    [pbr::OriginalName("SCHEDULE_CREATE_CONTRACT_CALL")] ScheduleCreateContractCall = 5,
    /// <summary>
    ///*
    /// The resource cost for the transaction type includes a TopicCreate
    /// with custom fees.
    /// </summary>
    [pbr::OriginalName("TOPIC_CREATE_WITH_CUSTOM_FEES")] TopicCreateWithCustomFees = 6,
    /// <summary>
    ///*
    /// The resource cost for the transaction type includes a ConsensusSubmitMessage
    /// for a topic with custom fees.
    /// </summary>
    [pbr::OriginalName("SUBMIT_MESSAGE_WITH_CUSTOM_FEES")] SubmitMessageWithCustomFees = 7,
  }

  /// <summary>
  ///*
  /// Possible Token Supply Types (IWA Compatibility).
  ///
  /// This `enum` indicates the limit of tokens that can exist during the
  /// lifetime of a token definition. The "infinite" supply is only theoretically
  /// infinite, as it is still limited to the magnitude of a 64-bit signed
  /// integer. A "finite" supply is further limited to a value specified when
  /// the token is created (or updated, if not immutable).
  /// </summary>
  public enum TokenSupplyType {
    /// <summary>
    ///*
    /// An unlimited supply.&lt;br/>
    /// This indicates that tokens of this type have an upper bound of
    /// Long.MAX_VALUE.&lt;br/>
    /// The supply is accounted in the smallest units of the token
    /// (i.e. 10&lt;sup>-`decimals`&lt;/sup> whole tokens)
    /// </summary>
    [pbr::OriginalName("INFINITE")] Infinite = 0,
    /// <summary>
    ///*
    /// A limited supply.&lt;br/>
    /// This indicates that tokens of this type have an upper bound of
    /// `maxSupply`.&lt;br/>
    /// The maximum supply SHALL be provided on token creation, but MAY be
    /// changed thereafter if the token has an `admin_key` set.
    /// </summary>
    [pbr::OriginalName("FINITE")] Finite = 1,
  }

  /// <summary>
  ///*
  /// Types of validation strategies for token keys.
  /// </summary>
  public enum TokenKeyValidation {
    /// <summary>
    ///*
    /// Perform all token key validations.&lt;br/>
    /// This is the default value and behavior.
    /// </summary>
    [pbr::OriginalName("FULL_VALIDATION")] FullValidation = 0,
    /// <summary>
    ///*
    /// Perform no validations at all for all passed token keys.
    /// </summary>
    [pbr::OriginalName("NO_VALIDATION")] NoValidation = 1,
  }

  /// <summary>
  ///*
  /// Possible token freeze status values.
  ///
  /// This is returned by `TokenGetInfoQuery` or `CryptoGetInfoResponse`
  /// in `TokenRelationship`.
  /// </summary>
  public enum TokenFreezeStatus {
    /// <summary>
    ///*
    /// The token does not support freeze or cannot be frozen for the designated
    /// account.&lt;br/>
    /// Typically this indicates that the token does not have a `freeze_key` set.
    /// </summary>
    [pbr::OriginalName("FreezeNotApplicable")] FreezeNotApplicable = 0,
    /// <summary>
    ///*
    /// The token is currently frozen for the designated account.
    /// </summary>
    [pbr::OriginalName("Frozen")] Frozen = 1,
    /// <summary>
    ///*
    /// The token is not currently frozen for the designated account.
    /// </summary>
    [pbr::OriginalName("Unfrozen")] Unfrozen = 2,
  }

  /// <summary>
  ///*
  /// Possible token "KYC" status values.
  ///
  /// This is returned by `TokenGetInfoQuery` or `CryptoGetInfoResponse`
  /// in `TokenRelationship`.
  /// </summary>
  public enum TokenKycStatus {
    /// <summary>
    ///*
    /// The token does not support KYC or cannot grant KYC for the
    /// designated account.&lt;br/>
    /// Typically this indicates that the token does not have a `kyc_key` set.
    /// </summary>
    [pbr::OriginalName("KycNotApplicable")] KycNotApplicable = 0,
    /// <summary>
    ///*
    /// The designated account is currently granted KYC status for the
    /// designated token.
    /// </summary>
    [pbr::OriginalName("Granted")] Granted = 1,
    /// <summary>
    ///*
    /// The designated account is not currently granted KYC status for the
    /// designated token.
    /// </summary>
    [pbr::OriginalName("Revoked")] Revoked = 2,
  }

  /// <summary>
  ///*
  /// Possible Pause status values.
  ///
  /// This is returned by `TokenGetInfoQuery` in `TokenRelationship`.
  /// </summary>
  public enum TokenPauseStatus {
    /// <summary>
    ///*
    /// The token does not support pause or cannot be paused.&lt;br/>
    /// Typically this indicates that the token does not have a `pause_key` set.
    /// </summary>
    [pbr::OriginalName("PauseNotApplicable")] PauseNotApplicable = 0,
    /// <summary>
    ///*
    /// The token is currently paused.
    /// </summary>
    [pbr::OriginalName("Paused")] Paused = 1,
    /// <summary>
    ///*
    /// The token is not currently paused.
    /// </summary>
    [pbr::OriginalName("Unpaused")] Unpaused = 2,
  }

  /// <summary>
  ///*
  /// The transactions and queries supported by Hedera Hashgraph.
  /// </summary>
  public enum HederaFunctionality {
    /// <summary>
    ///*
    /// Unused - The first value is unused because this default value is
    /// ambiguous with an "unset" value and therefore should not be used.
    /// </summary>
    [pbr::OriginalName("NONE")] None = 0,
    /// <summary>
    ///*
    /// Transfer tokens among accounts.
    /// </summary>
    [pbr::OriginalName("CryptoTransfer")] CryptoTransfer = 1,
    /// <summary>
    ///*
    /// Update an account.
    /// </summary>
    [pbr::OriginalName("CryptoUpdate")] CryptoUpdate = 2,
    /// <summary>
    ///*
    /// Delete an account.
    /// </summary>
    [pbr::OriginalName("CryptoDelete")] CryptoDelete = 3,
    /// <summary>
    ///*
    /// Add a livehash to an account
    /// </summary>
    [global::System.ObsoleteAttribute]
    [pbr::OriginalName("CryptoAddLiveHash")] CryptoAddLiveHash = 4,
    /// <summary>
    ///*
    /// Delete a livehash from an account
    /// </summary>
    [global::System.ObsoleteAttribute]
    [pbr::OriginalName("CryptoDeleteLiveHash")] CryptoDeleteLiveHash = 5,
    /// <summary>
    ///*
    /// Execute a smart contract call.
    /// </summary>
    [pbr::OriginalName("ContractCall")] ContractCall = 6,
    /// <summary>
    ///*
    /// Create a smart contract.
    /// </summary>
    [pbr::OriginalName("ContractCreate")] ContractCreate = 7,
    /// <summary>
    ///*
    /// Update a smart contract.
    /// </summary>
    [pbr::OriginalName("ContractUpdate")] ContractUpdate = 8,
    /// <summary>
    ///*
    /// Create a "file" stored in the ledger.
    /// </summary>
    [pbr::OriginalName("FileCreate")] FileCreate = 9,
    /// <summary>
    ///*
    /// Append data to a "file" stored in the ledger.
    /// </summary>
    [pbr::OriginalName("FileAppend")] FileAppend = 10,
    /// <summary>
    ///*
    /// Update a "file" stored in the ledger.
    /// </summary>
    [pbr::OriginalName("FileUpdate")] FileUpdate = 11,
    /// <summary>
    ///*
    /// Delete a "file" stored in the ledger.
    /// </summary>
    [pbr::OriginalName("FileDelete")] FileDelete = 12,
    /// <summary>
    ///*
    /// Get the balance for an account.
    /// </summary>
    [pbr::OriginalName("CryptoGetAccountBalance")] CryptoGetAccountBalance = 13,
    /// <summary>
    ///*
    /// Get a full account record.
    /// </summary>
    [pbr::OriginalName("CryptoGetAccountRecords")] CryptoGetAccountRecords = 14,
    /// <summary>
    ///*
    /// Get information about a token.
    /// </summary>
    [pbr::OriginalName("CryptoGetInfo")] CryptoGetInfo = 15,
    /// <summary>
    ///*
    /// Execute a local smart contract call.&lt;br/>
    /// Used by contracts to call other contracts.
    /// </summary>
    [pbr::OriginalName("ContractCallLocal")] ContractCallLocal = 16,
    /// <summary>
    ///*
    /// Get information about a smart contract.
    /// </summary>
    [pbr::OriginalName("ContractGetInfo")] ContractGetInfo = 17,
    /// <summary>
    ///*
    /// Get the compiled bytecode that implements a smart contract.
    /// </summary>
    [pbr::OriginalName("ContractGetBytecode")] ContractGetBytecode = 18,
    /// <summary>
    ///*
    /// Get a smart contract record by reference to the solidity ID.
    /// </summary>
    [pbr::OriginalName("GetBySolidityID")] GetBySolidityId = 19,
    /// <summary>
    ///*
    /// Get a smart contract by reference to the contract key.
    /// </summary>
    [pbr::OriginalName("GetByKey")] GetByKey = 20,
    /// <summary>
    ///*
    /// Get the live hash for an account
    /// </summary>
    [global::System.ObsoleteAttribute]
    [pbr::OriginalName("CryptoGetLiveHash")] CryptoGetLiveHash = 21,
    /// <summary>
    ///*
    /// Get the accounts proxy staking to a given account.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [pbr::OriginalName("CryptoGetStakers")] CryptoGetStakers = 22,
    /// <summary>
    ///*
    /// Get the contents of a "file" stored in the ledger.
    /// </summary>
    [pbr::OriginalName("FileGetContents")] FileGetContents = 23,
    /// <summary>
    ///*
    /// Get the metadata for a "file" stored in the ledger.
    /// </summary>
    [pbr::OriginalName("FileGetInfo")] FileGetInfo = 24,
    /// <summary>
    ///*
    /// Get transaction record(s) for a specified transaction ID.
    /// </summary>
    [pbr::OriginalName("TransactionGetRecord")] TransactionGetRecord = 25,
    /// <summary>
    ///*
    /// Get all transaction records for a specified contract ID in
    /// the past 24 hours.&lt;br/>
    /// deprecated since version 0.9.0
    /// </summary>
    [global::System.ObsoleteAttribute]
    [pbr::OriginalName("ContractGetRecords")] ContractGetRecords = 26,
    /// <summary>
    ///*
    /// Create a new account
    /// </summary>
    [pbr::OriginalName("CryptoCreate")] CryptoCreate = 27,
    /// <summary>
    ///*
    /// Delete a "system" "file" stored in the ledger.&lt;br/>
    /// "System" files are files with special purpose and ID values within a
    /// specific range.&lt;br/>
    /// These files require additional controls and can only be deleted when
    /// authorized by accounts with elevated privilege.
    /// </summary>
    [pbr::OriginalName("SystemDelete")] SystemDelete = 28,
    /// <summary>
    ///*
    /// Undo the delete of a "system" "file" stored in the ledger.&lt;br/>
    /// "System" files are files with special purpose and ID values within a
    /// specific range.&lt;br/>
    /// These files require additional controls and can only be deleted when
    /// authorized by accounts with elevated privilege. This operation allows
    /// such files to be restored, within a reasonable timeframe, if
    /// deleted improperly.
    /// </summary>
    [pbr::OriginalName("SystemUndelete")] SystemUndelete = 29,
    /// <summary>
    ///*
    /// Delete a smart contract
    /// </summary>
    [pbr::OriginalName("ContractDelete")] ContractDelete = 30,
    /// <summary>
    ///*
    /// Stop all processing and "freeze" the entire network.&lt;br/>
    /// This is generally sent immediately prior to upgrading the network.&lt;br/>
    /// After processing this transactions all nodes enter a quiescent state.
    /// </summary>
    [pbr::OriginalName("Freeze")] Freeze = 31,
    /// <summary>
    ///*
    /// Create a Transaction Record.&lt;br/>
    /// This appears to be purely internal and unused.
    /// </summary>
    [pbr::OriginalName("CreateTransactionRecord")] CreateTransactionRecord = 32,
    /// <summary>
    ///*
    /// Auto-renew an account.&lt;br/>
    /// This is used for internal fee calculations.
    /// </summary>
    [pbr::OriginalName("CryptoAccountAutoRenew")] CryptoAccountAutoRenew = 33,
    /// <summary>
    ///*
    /// Auto-renew a smart contract.&lt;br/>
    /// This is used for internal fee calculations.
    /// </summary>
    [pbr::OriginalName("ContractAutoRenew")] ContractAutoRenew = 34,
    /// <summary>
    ///*
    /// Get version information for the ledger.&lt;br/>
    /// This returns a the version of the software currently running the network
    /// for both the protocol buffers and the network services (node).
    /// </summary>
    [pbr::OriginalName("GetVersionInfo")] GetVersionInfo = 35,
    /// <summary>
    ///*
    /// Get a receipt for a specified transaction ID.
    /// </summary>
    [pbr::OriginalName("TransactionGetReceipt")] TransactionGetReceipt = 36,
    /// <summary>
    ///*
    /// Create a topic for the Hedera Consensus Service (HCS).
    /// </summary>
    [pbr::OriginalName("ConsensusCreateTopic")] ConsensusCreateTopic = 50,
    /// <summary>
    ///*
    /// Update an HCS topic.
    /// </summary>
    [pbr::OriginalName("ConsensusUpdateTopic")] ConsensusUpdateTopic = 51,
    /// <summary>
    ///*
    /// Delete an HCS topic.
    /// </summary>
    [pbr::OriginalName("ConsensusDeleteTopic")] ConsensusDeleteTopic = 52,
    /// <summary>
    ///*
    /// Get metadata (information) for an HCS topic.
    /// </summary>
    [pbr::OriginalName("ConsensusGetTopicInfo")] ConsensusGetTopicInfo = 53,
    /// <summary>
    ///*
    /// Publish a message to an HCS topic.
    /// </summary>
    [pbr::OriginalName("ConsensusSubmitMessage")] ConsensusSubmitMessage = 54,
    /// <summary>
    ///*
    /// Submit a transaction, bypassing intake checking.
    /// Only enabled in local-mode.
    /// </summary>
    [pbr::OriginalName("UncheckedSubmit")] UncheckedSubmit = 55,
    /// <summary>
    ///*
    /// Create a token for the Hedera Token Service (HTS).
    /// </summary>
    [pbr::OriginalName("TokenCreate")] TokenCreate = 56,
    /// <summary>
    ///*
    /// Get metadata (information) for an HTS token.
    /// </summary>
    [pbr::OriginalName("TokenGetInfo")] TokenGetInfo = 58,
    /// <summary>
    ///*
    /// Freeze a specific account with respect to a specific HTS token.
    /// &lt;p>
    /// Once this transaction completes that account CANNOT send or receive
    /// the specified token.
    /// </summary>
    [pbr::OriginalName("TokenFreezeAccount")] TokenFreezeAccount = 59,
    /// <summary>
    ///*
    /// Remove a "freeze" from an account with respect to a specific HTS token.
    /// </summary>
    [pbr::OriginalName("TokenUnfreezeAccount")] TokenUnfreezeAccount = 60,
    /// <summary>
    ///*
    /// Grant KYC status to an account for a specific HTS token.
    /// </summary>
    [pbr::OriginalName("TokenGrantKycToAccount")] TokenGrantKycToAccount = 61,
    /// <summary>
    ///*
    /// Revoke KYC status from an account for a specific HTS token.
    /// </summary>
    [pbr::OriginalName("TokenRevokeKycFromAccount")] TokenRevokeKycFromAccount = 62,
    /// <summary>
    ///*
    /// Delete a specific HTS token.
    /// </summary>
    [pbr::OriginalName("TokenDelete")] TokenDelete = 63,
    /// <summary>
    ///*
    /// Update a specific HTS token.
    /// </summary>
    [pbr::OriginalName("TokenUpdate")] TokenUpdate = 64,
    /// <summary>
    ///*
    /// Mint HTS token amounts to the treasury account for that token.
    /// </summary>
    [pbr::OriginalName("TokenMint")] TokenMint = 65,
    /// <summary>
    ///*
    /// Burn HTS token amounts from the treasury account for that token.
    /// </summary>
    [pbr::OriginalName("TokenBurn")] TokenBurn = 66,
    /// <summary>
    ///*
    /// Wipe all amounts for a specific HTS token from a specified account.
    /// </summary>
    [pbr::OriginalName("TokenAccountWipe")] TokenAccountWipe = 67,
    /// <summary>
    ///*
    /// Associate a specific HTS token to an account.
    /// </summary>
    [pbr::OriginalName("TokenAssociateToAccount")] TokenAssociateToAccount = 68,
    /// <summary>
    ///*
    /// Dissociate a specific HTS token from an account.
    /// </summary>
    [pbr::OriginalName("TokenDissociateFromAccount")] TokenDissociateFromAccount = 69,
    /// <summary>
    ///*
    /// Create a scheduled transaction
    /// </summary>
    [pbr::OriginalName("ScheduleCreate")] ScheduleCreate = 70,
    /// <summary>
    ///*
    /// Delete a scheduled transaction
    /// </summary>
    [pbr::OriginalName("ScheduleDelete")] ScheduleDelete = 71,
    /// <summary>
    ///*
    /// Sign a scheduled transaction
    /// </summary>
    [pbr::OriginalName("ScheduleSign")] ScheduleSign = 72,
    /// <summary>
    ///*
    /// Get metadata (information) for a scheduled transaction
    /// </summary>
    [pbr::OriginalName("ScheduleGetInfo")] ScheduleGetInfo = 73,
    /// <summary>
    ///*
    /// Get NFT metadata (information) for a range of NFTs associated to a
    /// specific non-fungible/unique HTS token and owned by a specific account.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [pbr::OriginalName("TokenGetAccountNftInfos")] TokenGetAccountNftInfos = 74,
    /// <summary>
    ///*
    /// Get metadata (information) for a specific NFT identified by token and
    /// serial number.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [pbr::OriginalName("TokenGetNftInfo")] TokenGetNftInfo = 75,
    /// <summary>
    ///*
    /// Get NFT metadata (information) for a range of NFTs associated to a
    /// specific non-fungible/unique HTS token.
    /// </summary>
    [pbr::OriginalName("TokenGetNftInfos")] TokenGetNftInfos = 76,
    /// <summary>
    ///*
    /// Update a token's custom fee schedule.
    /// &lt;p>
    /// If a transaction of this type is not signed by the token
    /// `fee_schedule_key` it SHALL fail with INVALID_SIGNATURE, or
    /// TOKEN_HAS_NO_FEE_SCHEDULE_KEY if there is no `fee_schedule_key` set.
    /// </summary>
    [pbr::OriginalName("TokenFeeScheduleUpdate")] TokenFeeScheduleUpdate = 77,
    /// <summary>
    ///*
    /// Get execution time(s) for one or more "recent" TransactionIDs.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [pbr::OriginalName("NetworkGetExecutionTime")] NetworkGetExecutionTime = 78,
    /// <summary>
    ///*
    /// Pause a specific HTS token
    /// </summary>
    [pbr::OriginalName("TokenPause")] TokenPause = 79,
    /// <summary>
    ///*
    /// Unpause a paused HTS token.
    /// </summary>
    [pbr::OriginalName("TokenUnpause")] TokenUnpause = 80,
    /// <summary>
    ///*
    /// Approve an allowance for a spender relative to the owner account, which
    /// MUST sign the transaction.
    /// </summary>
    [pbr::OriginalName("CryptoApproveAllowance")] CryptoApproveAllowance = 81,
    /// <summary>
    ///*
    /// Delete (unapprove) an allowance previously approved
    /// for the owner account.
    /// </summary>
    [pbr::OriginalName("CryptoDeleteAllowance")] CryptoDeleteAllowance = 82,
    /// <summary>
    ///*
    /// Get all the information about an account, including balance
    /// and allowances.&lt;br/>
    /// This does not get a list of account records.
    /// </summary>
    [pbr::OriginalName("GetAccountDetails")] GetAccountDetails = 83,
    /// <summary>
    ///*
    /// Perform an Ethereum (EVM) transaction.&lt;br/>
    /// CallData may be inline if small, or in a "file" if large.
    /// </summary>
    [pbr::OriginalName("EthereumTransaction")] EthereumTransaction = 84,
    /// <summary>
    ///*
    /// Used to indicate when the network has updated the staking information
    /// at the end of a staking period and to indicate a new staking period
    /// has started.
    /// </summary>
    [pbr::OriginalName("NodeStakeUpdate")] NodeStakeUpdate = 85,
    /// <summary>
    ///*
    /// Generate and return a pseudorandom number based on network state.
    /// </summary>
    [pbr::OriginalName("UtilPrng")] UtilPrng = 86,
    /// <summary>
    ///*
    /// Get a record for a "recent" transaction.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [pbr::OriginalName("TransactionGetFastRecord")] TransactionGetFastRecord = 87,
    /// <summary>
    ///*
    /// Update the metadata of one or more NFT's of a specific token type.
    /// </summary>
    [pbr::OriginalName("TokenUpdateNfts")] TokenUpdateNfts = 88,
    /// <summary>
    ///*
    /// Create a node
    /// </summary>
    [pbr::OriginalName("NodeCreate")] NodeCreate = 89,
    /// <summary>
    ///*
    /// Update a node
    /// </summary>
    [pbr::OriginalName("NodeUpdate")] NodeUpdate = 90,
    /// <summary>
    ///*
    /// Delete a node
    /// </summary>
    [pbr::OriginalName("NodeDelete")] NodeDelete = 91,
    /// <summary>
    ///*
    /// Transfer one or more token balances held by the requesting account
    /// to the treasury for each token type.
    /// </summary>
    [pbr::OriginalName("TokenReject")] TokenReject = 92,
    /// <summary>
    ///*
    /// Airdrop one or more tokens to one or more accounts.
    /// </summary>
    [pbr::OriginalName("TokenAirdrop")] TokenAirdrop = 93,
    /// <summary>
    ///*
    /// Remove one or more pending airdrops from state on behalf of
    /// the sender(s) for each airdrop.
    /// </summary>
    [pbr::OriginalName("TokenCancelAirdrop")] TokenCancelAirdrop = 94,
    /// <summary>
    ///*
    /// Claim one or more pending airdrops
    /// </summary>
    [pbr::OriginalName("TokenClaimAirdrop")] TokenClaimAirdrop = 95,
    /// <summary>
    ///*
    /// Submit a signature of a state root hash gossiped to other nodes
    /// </summary>
    [pbr::OriginalName("StateSignatureTransaction")] StateSignatureTransaction = 100,
    /// <summary>
    ///*
    /// Publish a hinTS key to the network.
    /// </summary>
    [pbr::OriginalName("HintsKeyPublication")] HintsKeyPublication = 101,
    /// <summary>
    ///*
    /// Vote for a particular preprocessing output of a hinTS construction.
    /// </summary>
    [pbr::OriginalName("HintsPreprocessingVote")] HintsPreprocessingVote = 102,
    /// <summary>
    ///*
    /// Sign a partial signature for the active hinTS construction.
    /// </summary>
    [pbr::OriginalName("HintsPartialSignature")] HintsPartialSignature = 103,
    /// <summary>
    ///*
    /// Sign a particular history assembly.
    /// </summary>
    [pbr::OriginalName("HistoryAssemblySignature")] HistoryAssemblySignature = 104,
    /// <summary>
    ///*
    /// Publish a roster history proof key to the network.
    /// </summary>
    [pbr::OriginalName("HistoryProofKeyPublication")] HistoryProofKeyPublication = 105,
    /// <summary>
    ///*
    /// Vote for a particular history proof.
    /// </summary>
    [pbr::OriginalName("HistoryProofVote")] HistoryProofVote = 106,
    /// <summary>
    ///*
    /// Publish a random CRS to the network.
    /// </summary>
    [pbr::OriginalName("CrsPublication")] CrsPublication = 107,
    /// <summary>
    ///*
    /// Submit a batch of transactions to run atomically
    /// </summary>
    [pbr::OriginalName("AtomicBatch")] AtomicBatch = 108,
    /// <summary>
    ///*
    /// Update one or more storage slots in an lambda EVM hook.
    /// </summary>
    [pbr::OriginalName("LambdaSStore")] LambdaSstore = 109,
    /// <summary>
    ///*
    /// (Internal-only) Dispatch a hook action.
    /// </summary>
    [pbr::OriginalName("HookDispatch")] HookDispatch = 110,
  }

  #endregion

  #region Messages
  /// <summary>
  ///*
  /// A shard identifier.&lt;br/>
  /// A shard is a partition of nodes running the network that processes
  /// transactions separately from other shards. Each shard is effectively an
  /// independent instance of the overall network that shares the same virtual
  /// distributed ledger, and may gossip cross-shard transactions with other
  /// shards to maintain overall correct processing of the ledger.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class ShardID : pb::IMessage<ShardID>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ShardID> _parser = new pb::MessageParser<ShardID>(() => new ShardID());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ShardID> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Proto.BasicTypesReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ShardID() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ShardID(ShardID other) : this() {
      shardNum_ = other.shardNum_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ShardID Clone() {
      return new ShardID(this);
    }

    /// <summary>Field number for the "shardNum" field.</summary>
    public const int ShardNumFieldNumber = 1;
    private long shardNum_;
    /// <summary>
    ///*
    /// A whole number shard identifier.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long ShardNum {
      get { return shardNum_; }
      set {
        shardNum_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ShardID);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ShardID other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (ShardNum != other.ShardNum) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (ShardNum != 0L) hash ^= ShardNum.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (ShardNum != 0L) {
        output.WriteRawTag(8);
        output.WriteInt64(ShardNum);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (ShardNum != 0L) {
        output.WriteRawTag(8);
        output.WriteInt64(ShardNum);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (ShardNum != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(ShardNum);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ShardID other) {
      if (other == null) {
        return;
      }
      if (other.ShardNum != 0L) {
        ShardNum = other.ShardNum;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            ShardNum = input.ReadInt64();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            ShardNum = input.ReadInt64();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// A realm identifier.&lt;br/>
  /// Within a given shard, every realm has a unique numeric identifier.
  /// Each account, file, and contract instance belongs to exactly one realm.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class RealmID : pb::IMessage<RealmID>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<RealmID> _parser = new pb::MessageParser<RealmID>(() => new RealmID());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<RealmID> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Proto.BasicTypesReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public RealmID() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public RealmID(RealmID other) : this() {
      shardNum_ = other.shardNum_;
      realmNum_ = other.realmNum_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public RealmID Clone() {
      return new RealmID(this);
    }

    /// <summary>Field number for the "shardNum" field.</summary>
    public const int ShardNumFieldNumber = 1;
    private long shardNum_;
    /// <summary>
    ///*
    /// A whole number shard identifier.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long ShardNum {
      get { return shardNum_; }
      set {
        shardNum_ = value;
      }
    }

    /// <summary>Field number for the "realmNum" field.</summary>
    public const int RealmNumFieldNumber = 2;
    private long realmNum_;
    /// <summary>
    ///*
    /// A whole number realm identifier.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long RealmNum {
      get { return realmNum_; }
      set {
        realmNum_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as RealmID);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(RealmID other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (ShardNum != other.ShardNum) return false;
      if (RealmNum != other.RealmNum) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (ShardNum != 0L) hash ^= ShardNum.GetHashCode();
      if (RealmNum != 0L) hash ^= RealmNum.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (ShardNum != 0L) {
        output.WriteRawTag(8);
        output.WriteInt64(ShardNum);
      }
      if (RealmNum != 0L) {
        output.WriteRawTag(16);
        output.WriteInt64(RealmNum);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (ShardNum != 0L) {
        output.WriteRawTag(8);
        output.WriteInt64(ShardNum);
      }
      if (RealmNum != 0L) {
        output.WriteRawTag(16);
        output.WriteInt64(RealmNum);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (ShardNum != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(ShardNum);
      }
      if (RealmNum != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(RealmNum);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(RealmID other) {
      if (other == null) {
        return;
      }
      if (other.ShardNum != 0L) {
        ShardNum = other.ShardNum;
      }
      if (other.RealmNum != 0L) {
        RealmNum = other.RealmNum;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            ShardNum = input.ReadInt64();
            break;
          }
          case 16: {
            RealmNum = input.ReadInt64();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            ShardNum = input.ReadInt64();
            break;
          }
          case 16: {
            RealmNum = input.ReadInt64();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// Unique identifier for a token.&lt;br/>
  /// As with all entity identifiers within the network, a token identifier
  /// consists of a combination of shard number, realm number, and entity number.
  /// Each of these numbers is unique within its scope (shard > realm > entity).
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class TokenID : pb::IMessage<TokenID>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<TokenID> _parser = new pb::MessageParser<TokenID>(() => new TokenID());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<TokenID> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Proto.BasicTypesReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TokenID() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TokenID(TokenID other) : this() {
      shardNum_ = other.shardNum_;
      realmNum_ = other.realmNum_;
      tokenNum_ = other.tokenNum_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TokenID Clone() {
      return new TokenID(this);
    }

    /// <summary>Field number for the "shardNum" field.</summary>
    public const int ShardNumFieldNumber = 1;
    private long shardNum_;
    /// <summary>
    ///*
    /// A whole number shard identifier.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long ShardNum {
      get { return shardNum_; }
      set {
        shardNum_ = value;
      }
    }

    /// <summary>Field number for the "realmNum" field.</summary>
    public const int RealmNumFieldNumber = 2;
    private long realmNum_;
    /// <summary>
    ///*
    /// A whole number realm identifier.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long RealmNum {
      get { return realmNum_; }
      set {
        realmNum_ = value;
      }
    }

    /// <summary>Field number for the "tokenNum" field.</summary>
    public const int TokenNumFieldNumber = 3;
    private long tokenNum_;
    /// <summary>
    ///*
    /// A whole number token identifier.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long TokenNum {
      get { return tokenNum_; }
      set {
        tokenNum_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as TokenID);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(TokenID other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (ShardNum != other.ShardNum) return false;
      if (RealmNum != other.RealmNum) return false;
      if (TokenNum != other.TokenNum) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (ShardNum != 0L) hash ^= ShardNum.GetHashCode();
      if (RealmNum != 0L) hash ^= RealmNum.GetHashCode();
      if (TokenNum != 0L) hash ^= TokenNum.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (ShardNum != 0L) {
        output.WriteRawTag(8);
        output.WriteInt64(ShardNum);
      }
      if (RealmNum != 0L) {
        output.WriteRawTag(16);
        output.WriteInt64(RealmNum);
      }
      if (TokenNum != 0L) {
        output.WriteRawTag(24);
        output.WriteInt64(TokenNum);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (ShardNum != 0L) {
        output.WriteRawTag(8);
        output.WriteInt64(ShardNum);
      }
      if (RealmNum != 0L) {
        output.WriteRawTag(16);
        output.WriteInt64(RealmNum);
      }
      if (TokenNum != 0L) {
        output.WriteRawTag(24);
        output.WriteInt64(TokenNum);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (ShardNum != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(ShardNum);
      }
      if (RealmNum != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(RealmNum);
      }
      if (TokenNum != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(TokenNum);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(TokenID other) {
      if (other == null) {
        return;
      }
      if (other.ShardNum != 0L) {
        ShardNum = other.ShardNum;
      }
      if (other.RealmNum != 0L) {
        RealmNum = other.RealmNum;
      }
      if (other.TokenNum != 0L) {
        TokenNum = other.TokenNum;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            ShardNum = input.ReadInt64();
            break;
          }
          case 16: {
            RealmNum = input.ReadInt64();
            break;
          }
          case 24: {
            TokenNum = input.ReadInt64();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            ShardNum = input.ReadInt64();
            break;
          }
          case 16: {
            RealmNum = input.ReadInt64();
            break;
          }
          case 24: {
            TokenNum = input.ReadInt64();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// A unique identifier for an Hedera account.
  ///
  /// An account identifier is of the form `shard.realm.[number|alias]`.&lt;br/>
  /// The identifier MAY use the alias form when transferring HBAR to a public key
  /// before the account for that key is created, when only the alias value is
  /// known, or in some smart contracts that use the EVM address style alias to
  /// refer to Accounts.&lt;br/>
  /// When the account entry is completed, the alias SHALL be stored separately in
  /// the Account record, and the identifier in the Account SHALL use the
  /// `accountNum` form.
  ///
  /// ---
  /// ### Additional Notes
  ///
  /// #### Alias
  /// There is considerable complexity with `alias` (aka `evm_address`) for
  /// Accounts. Much of this comes from the existence of a "hidden" alias for
  /// almost all accounts, and the reuse of the alias field for both EVM reference
  /// and "automatic" account creation.&lt;br/>
  /// For the purposes of this specification, we will use the following terms for
  /// clarity.
  ///   - `key_alias`&lt;br/>
  ///      The account public key as a protobuf serialized message and used for
  ///      auto-creation and subsequent lookup. This is only valid if the account
  ///      key is a single `primitive` key, either Ed25519 or ECDSA_SECP256K1.
  ///   - `evm_address`&lt;br/>
  ///     Exists for every account and is one of
  ///      - `contract_address`&lt;br/>
  ///        The 20 byte EVM address prescribed by `CREATE` or `CREATE2`
  ///      - `evm_key_address`&lt;br/>
  ///        An arbitrary 20 byte EVM address that, for a usable externally owned
  ///        account (EOA) SHALL be the rightmost 20 bytes of the Keccak-256 hash
  ///        of a ECDSA_SECP256K1 key.&lt;br/>
  ///        Such accounts may be created in one of three ways:
  ///        - Sending hbar or fungible tokens to an unused
  ///          ECDSA_SECP256K1 key alias.
  ///        - Sending hbar or fungible tokens to an unassigned 20-byte
  ///          EVM address.
  ///        - Submitting a `CryptoCreate` signed with the corresponding
  ///          private key.
  ///      - `long_zero`&lt;br/>
  ///        A synthetic 20 byte address inferred for "normally" created accounts.
  ///        It is constructed from the "standard" AccountID as follows.
  ///         1. 4 byte big-endian shard number
  ///         1. 8 byte big-endian realm number
  ///         1. 8 byte big-endian entity number&lt;br/>
  ///
  /// The `alias` field in the `Account` message SHALL contain one of four values
  /// for any given account.
  ///   - The `key_alias`, if the account was created by transferring HBAR to the
  ///     `key_alias` public key value.
  ///   - The `evm_key_address` if the account was created from an EVM public key
  ///   - The `contract_address` if the account belongs to an EVM contract
  ///   - Not-Set/null/Bytes.EMPTY (collectively `null`) if the account was
  ///     created normally
  ///
  /// If the `alias` field of an `Account` is any form of `null`, then the account
  /// MAY be referred to by `alias` in an `AccountID` by using the `long_zero`
  /// address for the account.&lt;br/>
  /// This "hidden default" alias SHALL NOT be stored, but is synthesized by the
  /// node software as needed, and may be synthesized by an EVM contract or client
  /// software as well.
  ///
  /// ---
  ///
  /// #### Alias forms
  /// An `AccountID` in a transaction MAY reference an `Account` with
  /// `shard.realm.alias`.&lt;br/>
  /// If the account `alias` field is set for an Account, that value SHALL be the
  /// account alias.&lt;br/>
  /// If the account `alias` field is not set for an Account, the `long_zero` alias
  /// SHALL be the account alias.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class AccountID : pb::IMessage<AccountID>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<AccountID> _parser = new pb::MessageParser<AccountID>(() => new AccountID());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<AccountID> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Proto.BasicTypesReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AccountID() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AccountID(AccountID other) : this() {
      shardNum_ = other.shardNum_;
      realmNum_ = other.realmNum_;
      switch (other.AccountCase) {
        case AccountOneofCase.AccountNum:
          AccountNum = other.AccountNum;
          break;
        case AccountOneofCase.Alias:
          Alias = other.Alias;
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AccountID Clone() {
      return new AccountID(this);
    }

    /// <summary>Field number for the "shardNum" field.</summary>
    public const int ShardNumFieldNumber = 1;
    private long shardNum_;
    /// <summary>
    ///*
    /// A whole number shard identifier.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long ShardNum {
      get { return shardNum_; }
      set {
        shardNum_ = value;
      }
    }

    /// <summary>Field number for the "realmNum" field.</summary>
    public const int RealmNumFieldNumber = 2;
    private long realmNum_;
    /// <summary>
    ///*
    /// A whole number realm identifier.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long RealmNum {
      get { return realmNum_; }
      set {
        realmNum_ = value;
      }
    }

    /// <summary>Field number for the "accountNum" field.</summary>
    public const int AccountNumFieldNumber = 3;
    /// <summary>
    ///*
    /// A whole number account number, unique within its realm and shard.
    /// &lt;p>
    /// For any AccountID fields in the query response, transaction records,
    /// transaction receipts, or block stream `accountNum` MUST be used.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long AccountNum {
      get { return HasAccountNum ? (long) account_ : 0L; }
      set {
        account_ = value;
        accountCase_ = AccountOneofCase.AccountNum;
      }
    }
    /// <summary>Gets whether the "accountNum" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasAccountNum {
      get { return accountCase_ == AccountOneofCase.AccountNum; }
    }
    /// <summary> Clears the value of the oneof if it's currently set to "accountNum" </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearAccountNum() {
      if (HasAccountNum) {
        ClearAccount();
      }
    }

    /// <summary>Field number for the "alias" field.</summary>
    public const int AliasFieldNumber = 4;
    /// <summary>
    ///*
    /// An alias value.&lt;br/>
    /// Alias is a value used in some contexts to refer to an account when
    /// account number is not available, and may be an alias public key, or
    /// an EVM address.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString Alias {
      get { return HasAlias ? (pb::ByteString) account_ : pb::ByteString.Empty; }
      set {
        account_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        accountCase_ = AccountOneofCase.Alias;
      }
    }
    /// <summary>Gets whether the "alias" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasAlias {
      get { return accountCase_ == AccountOneofCase.Alias; }
    }
    /// <summary> Clears the value of the oneof if it's currently set to "alias" </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearAlias() {
      if (HasAlias) {
        ClearAccount();
      }
    }

    private object account_;
    /// <summary>Enum of possible cases for the "account" oneof.</summary>
    public enum AccountOneofCase {
      None = 0,
      AccountNum = 3,
      Alias = 4,
    }
    private AccountOneofCase accountCase_ = AccountOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AccountOneofCase AccountCase {
      get { return accountCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearAccount() {
      accountCase_ = AccountOneofCase.None;
      account_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as AccountID);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(AccountID other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (ShardNum != other.ShardNum) return false;
      if (RealmNum != other.RealmNum) return false;
      if (AccountNum != other.AccountNum) return false;
      if (Alias != other.Alias) return false;
      if (AccountCase != other.AccountCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (ShardNum != 0L) hash ^= ShardNum.GetHashCode();
      if (RealmNum != 0L) hash ^= RealmNum.GetHashCode();
      if (HasAccountNum) hash ^= AccountNum.GetHashCode();
      if (HasAlias) hash ^= Alias.GetHashCode();
      hash ^= (int) accountCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (ShardNum != 0L) {
        output.WriteRawTag(8);
        output.WriteInt64(ShardNum);
      }
      if (RealmNum != 0L) {
        output.WriteRawTag(16);
        output.WriteInt64(RealmNum);
      }
      if (HasAccountNum) {
        output.WriteRawTag(24);
        output.WriteInt64(AccountNum);
      }
      if (HasAlias) {
        output.WriteRawTag(34);
        output.WriteBytes(Alias);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (ShardNum != 0L) {
        output.WriteRawTag(8);
        output.WriteInt64(ShardNum);
      }
      if (RealmNum != 0L) {
        output.WriteRawTag(16);
        output.WriteInt64(RealmNum);
      }
      if (HasAccountNum) {
        output.WriteRawTag(24);
        output.WriteInt64(AccountNum);
      }
      if (HasAlias) {
        output.WriteRawTag(34);
        output.WriteBytes(Alias);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (ShardNum != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(ShardNum);
      }
      if (RealmNum != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(RealmNum);
      }
      if (HasAccountNum) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(AccountNum);
      }
      if (HasAlias) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Alias);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(AccountID other) {
      if (other == null) {
        return;
      }
      if (other.ShardNum != 0L) {
        ShardNum = other.ShardNum;
      }
      if (other.RealmNum != 0L) {
        RealmNum = other.RealmNum;
      }
      switch (other.AccountCase) {
        case AccountOneofCase.AccountNum:
          AccountNum = other.AccountNum;
          break;
        case AccountOneofCase.Alias:
          Alias = other.Alias;
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            ShardNum = input.ReadInt64();
            break;
          }
          case 16: {
            RealmNum = input.ReadInt64();
            break;
          }
          case 24: {
            AccountNum = input.ReadInt64();
            break;
          }
          case 34: {
            Alias = input.ReadBytes();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            ShardNum = input.ReadInt64();
            break;
          }
          case 16: {
            RealmNum = input.ReadInt64();
            break;
          }
          case 24: {
            AccountNum = input.ReadInt64();
            break;
          }
          case 34: {
            Alias = input.ReadBytes();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// An identifier for a unique token (or "NFT"), used by both contract
  /// and token services.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class NftID : pb::IMessage<NftID>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<NftID> _parser = new pb::MessageParser<NftID>(() => new NftID());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<NftID> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Proto.BasicTypesReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NftID() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NftID(NftID other) : this() {
      tokenID_ = other.tokenID_ != null ? other.tokenID_.Clone() : null;
      serialNumber_ = other.serialNumber_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NftID Clone() {
      return new NftID(this);
    }

    /// <summary>Field number for the "token_ID" field.</summary>
    public const int TokenIDFieldNumber = 1;
    private global::Proto.TokenID tokenID_;
    /// <summary>
    ///*
    /// A token identifier.&lt;br/>
    /// This token represents the collection containing this NFT.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.TokenID TokenID {
      get { return tokenID_; }
      set {
        tokenID_ = value;
      }
    }

    /// <summary>Field number for the "serial_number" field.</summary>
    public const int SerialNumberFieldNumber = 2;
    private long serialNumber_;
    /// <summary>
    ///*
    /// A unique serial number.&lt;br/>
    /// This serial number is unique within its token type.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long SerialNumber {
      get { return serialNumber_; }
      set {
        serialNumber_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as NftID);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(NftID other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(TokenID, other.TokenID)) return false;
      if (SerialNumber != other.SerialNumber) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (tokenID_ != null) hash ^= TokenID.GetHashCode();
      if (SerialNumber != 0L) hash ^= SerialNumber.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (tokenID_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(TokenID);
      }
      if (SerialNumber != 0L) {
        output.WriteRawTag(16);
        output.WriteInt64(SerialNumber);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (tokenID_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(TokenID);
      }
      if (SerialNumber != 0L) {
        output.WriteRawTag(16);
        output.WriteInt64(SerialNumber);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (tokenID_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TokenID);
      }
      if (SerialNumber != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(SerialNumber);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(NftID other) {
      if (other == null) {
        return;
      }
      if (other.tokenID_ != null) {
        if (tokenID_ == null) {
          TokenID = new global::Proto.TokenID();
        }
        TokenID.MergeFrom(other.TokenID);
      }
      if (other.SerialNumber != 0L) {
        SerialNumber = other.SerialNumber;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (tokenID_ == null) {
              TokenID = new global::Proto.TokenID();
            }
            input.ReadMessage(TokenID);
            break;
          }
          case 16: {
            SerialNumber = input.ReadInt64();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (tokenID_ == null) {
              TokenID = new global::Proto.TokenID();
            }
            input.ReadMessage(TokenID);
            break;
          }
          case 16: {
            SerialNumber = input.ReadInt64();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// An identifier for a File within the network.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class FileID : pb::IMessage<FileID>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<FileID> _parser = new pb::MessageParser<FileID>(() => new FileID());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<FileID> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Proto.BasicTypesReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public FileID() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public FileID(FileID other) : this() {
      shardNum_ = other.shardNum_;
      realmNum_ = other.realmNum_;
      fileNum_ = other.fileNum_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public FileID Clone() {
      return new FileID(this);
    }

    /// <summary>Field number for the "shardNum" field.</summary>
    public const int ShardNumFieldNumber = 1;
    private long shardNum_;
    /// <summary>
    ///*
    /// A whole number shard identifier.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long ShardNum {
      get { return shardNum_; }
      set {
        shardNum_ = value;
      }
    }

    /// <summary>Field number for the "realmNum" field.</summary>
    public const int RealmNumFieldNumber = 2;
    private long realmNum_;
    /// <summary>
    ///*
    /// A whole number realm identifier.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long RealmNum {
      get { return realmNum_; }
      set {
        realmNum_ = value;
      }
    }

    /// <summary>Field number for the "fileNum" field.</summary>
    public const int FileNumFieldNumber = 3;
    private long fileNum_;
    /// <summary>
    ///*
    /// A whole number file identifier, unique within its realm and shard.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long FileNum {
      get { return fileNum_; }
      set {
        fileNum_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as FileID);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(FileID other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (ShardNum != other.ShardNum) return false;
      if (RealmNum != other.RealmNum) return false;
      if (FileNum != other.FileNum) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (ShardNum != 0L) hash ^= ShardNum.GetHashCode();
      if (RealmNum != 0L) hash ^= RealmNum.GetHashCode();
      if (FileNum != 0L) hash ^= FileNum.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (ShardNum != 0L) {
        output.WriteRawTag(8);
        output.WriteInt64(ShardNum);
      }
      if (RealmNum != 0L) {
        output.WriteRawTag(16);
        output.WriteInt64(RealmNum);
      }
      if (FileNum != 0L) {
        output.WriteRawTag(24);
        output.WriteInt64(FileNum);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (ShardNum != 0L) {
        output.WriteRawTag(8);
        output.WriteInt64(ShardNum);
      }
      if (RealmNum != 0L) {
        output.WriteRawTag(16);
        output.WriteInt64(RealmNum);
      }
      if (FileNum != 0L) {
        output.WriteRawTag(24);
        output.WriteInt64(FileNum);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (ShardNum != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(ShardNum);
      }
      if (RealmNum != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(RealmNum);
      }
      if (FileNum != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(FileNum);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(FileID other) {
      if (other == null) {
        return;
      }
      if (other.ShardNum != 0L) {
        ShardNum = other.ShardNum;
      }
      if (other.RealmNum != 0L) {
        RealmNum = other.RealmNum;
      }
      if (other.FileNum != 0L) {
        FileNum = other.FileNum;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            ShardNum = input.ReadInt64();
            break;
          }
          case 16: {
            RealmNum = input.ReadInt64();
            break;
          }
          case 24: {
            FileNum = input.ReadInt64();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            ShardNum = input.ReadInt64();
            break;
          }
          case 16: {
            RealmNum = input.ReadInt64();
            break;
          }
          case 24: {
            FileNum = input.ReadInt64();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// An identifier for a smart contract within the network.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class ContractID : pb::IMessage<ContractID>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ContractID> _parser = new pb::MessageParser<ContractID>(() => new ContractID());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ContractID> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Proto.BasicTypesReflection.Descriptor.MessageTypes[6]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ContractID() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ContractID(ContractID other) : this() {
      shardNum_ = other.shardNum_;
      realmNum_ = other.realmNum_;
      switch (other.ContractCase) {
        case ContractOneofCase.ContractNum:
          ContractNum = other.ContractNum;
          break;
        case ContractOneofCase.EvmAddress:
          EvmAddress = other.EvmAddress;
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ContractID Clone() {
      return new ContractID(this);
    }

    /// <summary>Field number for the "shardNum" field.</summary>
    public const int ShardNumFieldNumber = 1;
    private long shardNum_;
    /// <summary>
    ///*
    /// A whole number shard identifier.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long ShardNum {
      get { return shardNum_; }
      set {
        shardNum_ = value;
      }
    }

    /// <summary>Field number for the "realmNum" field.</summary>
    public const int RealmNumFieldNumber = 2;
    private long realmNum_;
    /// <summary>
    ///*
    /// A whole number realm identifier.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long RealmNum {
      get { return realmNum_; }
      set {
        realmNum_ = value;
      }
    }

    /// <summary>Field number for the "contractNum" field.</summary>
    public const int ContractNumFieldNumber = 3;
    /// <summary>
    ///*
    /// A whole number contract identifier, unique within its realm and shard.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long ContractNum {
      get { return HasContractNum ? (long) contract_ : 0L; }
      set {
        contract_ = value;
        contractCase_ = ContractOneofCase.ContractNum;
      }
    }
    /// <summary>Gets whether the "contractNum" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasContractNum {
      get { return contractCase_ == ContractOneofCase.ContractNum; }
    }
    /// <summary> Clears the value of the oneof if it's currently set to "contractNum" </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearContractNum() {
      if (HasContractNum) {
        ClearContract();
      }
    }

    /// <summary>Field number for the "evm_address" field.</summary>
    public const int EvmAddressFieldNumber = 4;
    /// <summary>
    ///*
    /// A 20-byte EVM address of the contract to call.
    /// &lt;p>
    /// A contract created via a HAPI `ContractCreate` call SHALL have
    /// an EVM address determined by its `shard.realm.num` identifier.&lt;br/>
    /// This address is as follows
    /// &lt;ol>
    ///     &lt;li>4 byte big-endian shard number&lt;/li>
    ///     &lt;li>8 byte big-endian realm number&lt;/li>
    ///     &lt;li>8 byte big-endian contract number&lt;/li>
    /// &lt;/ol>
    /// This address is not stored in state, but is computed when needed.
    /// &lt;p>
    /// Contracts created by any other means, including a HAPI
    /// `EthereumTransaction` whose `to` address is the zero address,
    /// SHALL have the EVM address prescribed by the `CREATE` or
    /// `CREATE2` opcode, as applicable.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString EvmAddress {
      get { return HasEvmAddress ? (pb::ByteString) contract_ : pb::ByteString.Empty; }
      set {
        contract_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        contractCase_ = ContractOneofCase.EvmAddress;
      }
    }
    /// <summary>Gets whether the "evm_address" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasEvmAddress {
      get { return contractCase_ == ContractOneofCase.EvmAddress; }
    }
    /// <summary> Clears the value of the oneof if it's currently set to "evm_address" </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearEvmAddress() {
      if (HasEvmAddress) {
        ClearContract();
      }
    }

    private object contract_;
    /// <summary>Enum of possible cases for the "contract" oneof.</summary>
    public enum ContractOneofCase {
      None = 0,
      ContractNum = 3,
      EvmAddress = 4,
    }
    private ContractOneofCase contractCase_ = ContractOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ContractOneofCase ContractCase {
      get { return contractCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearContract() {
      contractCase_ = ContractOneofCase.None;
      contract_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ContractID);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ContractID other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (ShardNum != other.ShardNum) return false;
      if (RealmNum != other.RealmNum) return false;
      if (ContractNum != other.ContractNum) return false;
      if (EvmAddress != other.EvmAddress) return false;
      if (ContractCase != other.ContractCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (ShardNum != 0L) hash ^= ShardNum.GetHashCode();
      if (RealmNum != 0L) hash ^= RealmNum.GetHashCode();
      if (HasContractNum) hash ^= ContractNum.GetHashCode();
      if (HasEvmAddress) hash ^= EvmAddress.GetHashCode();
      hash ^= (int) contractCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (ShardNum != 0L) {
        output.WriteRawTag(8);
        output.WriteInt64(ShardNum);
      }
      if (RealmNum != 0L) {
        output.WriteRawTag(16);
        output.WriteInt64(RealmNum);
      }
      if (HasContractNum) {
        output.WriteRawTag(24);
        output.WriteInt64(ContractNum);
      }
      if (HasEvmAddress) {
        output.WriteRawTag(34);
        output.WriteBytes(EvmAddress);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (ShardNum != 0L) {
        output.WriteRawTag(8);
        output.WriteInt64(ShardNum);
      }
      if (RealmNum != 0L) {
        output.WriteRawTag(16);
        output.WriteInt64(RealmNum);
      }
      if (HasContractNum) {
        output.WriteRawTag(24);
        output.WriteInt64(ContractNum);
      }
      if (HasEvmAddress) {
        output.WriteRawTag(34);
        output.WriteBytes(EvmAddress);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (ShardNum != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(ShardNum);
      }
      if (RealmNum != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(RealmNum);
      }
      if (HasContractNum) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(ContractNum);
      }
      if (HasEvmAddress) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(EvmAddress);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ContractID other) {
      if (other == null) {
        return;
      }
      if (other.ShardNum != 0L) {
        ShardNum = other.ShardNum;
      }
      if (other.RealmNum != 0L) {
        RealmNum = other.RealmNum;
      }
      switch (other.ContractCase) {
        case ContractOneofCase.ContractNum:
          ContractNum = other.ContractNum;
          break;
        case ContractOneofCase.EvmAddress:
          EvmAddress = other.EvmAddress;
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            ShardNum = input.ReadInt64();
            break;
          }
          case 16: {
            RealmNum = input.ReadInt64();
            break;
          }
          case 24: {
            ContractNum = input.ReadInt64();
            break;
          }
          case 34: {
            EvmAddress = input.ReadBytes();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            ShardNum = input.ReadInt64();
            break;
          }
          case 16: {
            RealmNum = input.ReadInt64();
            break;
          }
          case 24: {
            ContractNum = input.ReadInt64();
            break;
          }
          case 34: {
            EvmAddress = input.ReadBytes();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// An unique identifier for a topic.&lt;br/>
  /// Topics are part of the consensus service, messages are published to a topic.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class TopicID : pb::IMessage<TopicID>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<TopicID> _parser = new pb::MessageParser<TopicID>(() => new TopicID());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<TopicID> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Proto.BasicTypesReflection.Descriptor.MessageTypes[7]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TopicID() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TopicID(TopicID other) : this() {
      shardNum_ = other.shardNum_;
      realmNum_ = other.realmNum_;
      topicNum_ = other.topicNum_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TopicID Clone() {
      return new TopicID(this);
    }

    /// <summary>Field number for the "shardNum" field.</summary>
    public const int ShardNumFieldNumber = 1;
    private long shardNum_;
    /// <summary>
    ///*
    /// A whole number shard identifier.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long ShardNum {
      get { return shardNum_; }
      set {
        shardNum_ = value;
      }
    }

    /// <summary>Field number for the "realmNum" field.</summary>
    public const int RealmNumFieldNumber = 2;
    private long realmNum_;
    /// <summary>
    ///*
    /// A whole number realm identifier.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long RealmNum {
      get { return realmNum_; }
      set {
        realmNum_ = value;
      }
    }

    /// <summary>Field number for the "topicNum" field.</summary>
    public const int TopicNumFieldNumber = 3;
    private long topicNum_;
    /// <summary>
    ///*
    /// A whole number topic identifier, unique within its realm and shard.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long TopicNum {
      get { return topicNum_; }
      set {
        topicNum_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as TopicID);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(TopicID other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (ShardNum != other.ShardNum) return false;
      if (RealmNum != other.RealmNum) return false;
      if (TopicNum != other.TopicNum) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (ShardNum != 0L) hash ^= ShardNum.GetHashCode();
      if (RealmNum != 0L) hash ^= RealmNum.GetHashCode();
      if (TopicNum != 0L) hash ^= TopicNum.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (ShardNum != 0L) {
        output.WriteRawTag(8);
        output.WriteInt64(ShardNum);
      }
      if (RealmNum != 0L) {
        output.WriteRawTag(16);
        output.WriteInt64(RealmNum);
      }
      if (TopicNum != 0L) {
        output.WriteRawTag(24);
        output.WriteInt64(TopicNum);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (ShardNum != 0L) {
        output.WriteRawTag(8);
        output.WriteInt64(ShardNum);
      }
      if (RealmNum != 0L) {
        output.WriteRawTag(16);
        output.WriteInt64(RealmNum);
      }
      if (TopicNum != 0L) {
        output.WriteRawTag(24);
        output.WriteInt64(TopicNum);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (ShardNum != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(ShardNum);
      }
      if (RealmNum != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(RealmNum);
      }
      if (TopicNum != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(TopicNum);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(TopicID other) {
      if (other == null) {
        return;
      }
      if (other.ShardNum != 0L) {
        ShardNum = other.ShardNum;
      }
      if (other.RealmNum != 0L) {
        RealmNum = other.RealmNum;
      }
      if (other.TopicNum != 0L) {
        TopicNum = other.TopicNum;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            ShardNum = input.ReadInt64();
            break;
          }
          case 16: {
            RealmNum = input.ReadInt64();
            break;
          }
          case 24: {
            TopicNum = input.ReadInt64();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            ShardNum = input.ReadInt64();
            break;
          }
          case 16: {
            RealmNum = input.ReadInt64();
            break;
          }
          case 24: {
            TopicNum = input.ReadInt64();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// An unique identifier for a Schedule
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class ScheduleID : pb::IMessage<ScheduleID>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ScheduleID> _parser = new pb::MessageParser<ScheduleID>(() => new ScheduleID());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ScheduleID> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Proto.BasicTypesReflection.Descriptor.MessageTypes[8]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ScheduleID() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ScheduleID(ScheduleID other) : this() {
      shardNum_ = other.shardNum_;
      realmNum_ = other.realmNum_;
      scheduleNum_ = other.scheduleNum_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ScheduleID Clone() {
      return new ScheduleID(this);
    }

    /// <summary>Field number for the "shardNum" field.</summary>
    public const int ShardNumFieldNumber = 1;
    private long shardNum_;
    /// <summary>
    ///*
    /// A whole number shard
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long ShardNum {
      get { return shardNum_; }
      set {
        shardNum_ = value;
      }
    }

    /// <summary>Field number for the "realmNum" field.</summary>
    public const int RealmNumFieldNumber = 2;
    private long realmNum_;
    /// <summary>
    ///*
    /// A whole number realm
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long RealmNum {
      get { return realmNum_; }
      set {
        realmNum_ = value;
      }
    }

    /// <summary>Field number for the "scheduleNum" field.</summary>
    public const int ScheduleNumFieldNumber = 3;
    private long scheduleNum_;
    /// <summary>
    ///*
    /// A whole number schedule, unique within its realm and shard
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long ScheduleNum {
      get { return scheduleNum_; }
      set {
        scheduleNum_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ScheduleID);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ScheduleID other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (ShardNum != other.ShardNum) return false;
      if (RealmNum != other.RealmNum) return false;
      if (ScheduleNum != other.ScheduleNum) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (ShardNum != 0L) hash ^= ShardNum.GetHashCode();
      if (RealmNum != 0L) hash ^= RealmNum.GetHashCode();
      if (ScheduleNum != 0L) hash ^= ScheduleNum.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (ShardNum != 0L) {
        output.WriteRawTag(8);
        output.WriteInt64(ShardNum);
      }
      if (RealmNum != 0L) {
        output.WriteRawTag(16);
        output.WriteInt64(RealmNum);
      }
      if (ScheduleNum != 0L) {
        output.WriteRawTag(24);
        output.WriteInt64(ScheduleNum);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (ShardNum != 0L) {
        output.WriteRawTag(8);
        output.WriteInt64(ShardNum);
      }
      if (RealmNum != 0L) {
        output.WriteRawTag(16);
        output.WriteInt64(RealmNum);
      }
      if (ScheduleNum != 0L) {
        output.WriteRawTag(24);
        output.WriteInt64(ScheduleNum);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (ShardNum != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(ShardNum);
      }
      if (RealmNum != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(RealmNum);
      }
      if (ScheduleNum != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(ScheduleNum);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ScheduleID other) {
      if (other == null) {
        return;
      }
      if (other.ShardNum != 0L) {
        ShardNum = other.ShardNum;
      }
      if (other.RealmNum != 0L) {
        RealmNum = other.RealmNum;
      }
      if (other.ScheduleNum != 0L) {
        ScheduleNum = other.ScheduleNum;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            ShardNum = input.ReadInt64();
            break;
          }
          case 16: {
            RealmNum = input.ReadInt64();
            break;
          }
          case 24: {
            ScheduleNum = input.ReadInt64();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            ShardNum = input.ReadInt64();
            break;
          }
          case 16: {
            RealmNum = input.ReadInt64();
            break;
          }
          case 24: {
            ScheduleNum = input.ReadInt64();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// A transaction identifier.&lt;br/>
  /// This is used for retrieving receipts and records for a transaction
  /// and internally by the network for detecting when duplicate transactions are
  /// submitted.
  ///
  /// A transaction may be processed more reliably by submitting it to
  /// several nodes, each with a different node account, but all with the same
  /// TransactionID. Then, the transaction will take effect when the first of all
  /// those nodes submits the transaction and it reaches consensus. The other
  /// transactions SHALL NOT be executed (and SHALL result in a
  /// `DUPLICATE_TRANSACTION` response).&lt;br/>
  /// Multiple submission increase reliability on the assumption that an error in,
  /// for example, network connectivity will not affect all nodes equally. Latency
  /// might be slightly lower, if one node is handling intake significantly slower
  /// than others, for example. The base transaction fee is required for each
  /// submission, however, so the total fees charged are significantly higher when
  /// using this approach.
  ///
  /// ### Requirements
  /// Each transaction identifier MUST be unique.&lt;br/>
  /// Multiple transactions MAY be submitted with the same transaction
  /// identifier, but all except the first SHALL be rejected as duplicate
  /// transactions.&lt;br/>
  /// An identifier MUST specify a `payer` account to be charged all fees
  /// associated with the transaction.&lt;br/>
  /// The `payer` account MUST exist and MUST have sufficient HBAR to pay all
  /// transaction fees.&lt;br/>
  /// An identifier MUST specify a "valid start time".&lt;br/>
  /// The "valid start time" MUST be strictly _earlier_ than the current
  /// network consensus time when submitted.&lt;br/>
  /// The "valid start time" MUST NOT be more than `transaction.maxValidDuration`
  /// seconds before the current network consensus time when submitted.&lt;br/>
  /// A client-submitted transaction MUST NOT set the `scheduled` flag.
  ///
  /// ### Additional Notes
  ///
  /// Additional items applicable to Scheduled Transactions:
  ///
  ///  - The ID of a Scheduled Transaction, once executed, SHALL inherit both
  ///    `transactionValidStart` and `accountID` from the `ScheduleCreate`
  ///    transaction that created the schedule.
  ///  - The `scheduled` property SHALL be set for Scheduled Transactions.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class TransactionID : pb::IMessage<TransactionID>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<TransactionID> _parser = new pb::MessageParser<TransactionID>(() => new TransactionID());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<TransactionID> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Proto.BasicTypesReflection.Descriptor.MessageTypes[9]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TransactionID() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TransactionID(TransactionID other) : this() {
      transactionValidStart_ = other.transactionValidStart_ != null ? other.transactionValidStart_.Clone() : null;
      accountID_ = other.accountID_ != null ? other.accountID_.Clone() : null;
      scheduled_ = other.scheduled_;
      nonce_ = other.nonce_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TransactionID Clone() {
      return new TransactionID(this);
    }

    /// <summary>Field number for the "transactionValidStart" field.</summary>
    public const int TransactionValidStartFieldNumber = 1;
    private global::Proto.Timestamp transactionValidStart_;
    /// <summary>
    ///*
    /// A timestamp for the transaction start time.&lt;br/>
    /// This is the earliest expected start time for this transaction.
    /// &lt;p>
    /// This value MUST be strictly less than `consensusTimestamp` when the
    /// transaction is submitted.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.Timestamp TransactionValidStart {
      get { return transactionValidStart_; }
      set {
        transactionValidStart_ = value;
      }
    }

    /// <summary>Field number for the "accountID" field.</summary>
    public const int AccountIDFieldNumber = 2;
    private global::Proto.AccountID accountID_;
    /// <summary>
    ///*
    /// An Account identifier.
    /// &lt;p>
    /// The identified account SHALL pay transaction fees for this transaction.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.AccountID AccountID {
      get { return accountID_; }
      set {
        accountID_ = value;
      }
    }

    /// <summary>Field number for the "scheduled" field.</summary>
    public const int ScheduledFieldNumber = 3;
    private bool scheduled_;
    /// <summary>
    ///*
    /// A scheduled transaction flag.&lt;br/>
    /// If set, this transaction represents the execution of a Schedule after
    /// all necessary signatures are gathered.
    /// &lt;p>
    /// This flag MUST NOT be set in a user-submitted transaction.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Scheduled {
      get { return scheduled_; }
      set {
        scheduled_ = value;
      }
    }

    /// <summary>Field number for the "nonce" field.</summary>
    public const int NonceFieldNumber = 4;
    private int nonce_;
    /// <summary>
    ///*
    /// An identifier for an internal transaction.&lt;br/>
    /// An internal transaction is one that was spawned as part of handling a
    /// user transaction. These internal transactions share the
    /// transactionValidStart and accountID of the user transaction, so a nonce
    /// is necessary to give them a unique TransactionID.
    /// &lt;p>
    /// An example is when a "parent" ContractCreate or ContractCall transaction
    /// calls one or more HTS precompiled contracts; each of the "child"
    /// transactions spawned for a precompile has a transaction id with a
    /// different nonce.
    /// &lt;p>
    /// This value MUST be unset for user-submitted transactions.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int Nonce {
      get { return nonce_; }
      set {
        nonce_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as TransactionID);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(TransactionID other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(TransactionValidStart, other.TransactionValidStart)) return false;
      if (!object.Equals(AccountID, other.AccountID)) return false;
      if (Scheduled != other.Scheduled) return false;
      if (Nonce != other.Nonce) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (transactionValidStart_ != null) hash ^= TransactionValidStart.GetHashCode();
      if (accountID_ != null) hash ^= AccountID.GetHashCode();
      if (Scheduled != false) hash ^= Scheduled.GetHashCode();
      if (Nonce != 0) hash ^= Nonce.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (transactionValidStart_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(TransactionValidStart);
      }
      if (accountID_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(AccountID);
      }
      if (Scheduled != false) {
        output.WriteRawTag(24);
        output.WriteBool(Scheduled);
      }
      if (Nonce != 0) {
        output.WriteRawTag(32);
        output.WriteInt32(Nonce);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (transactionValidStart_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(TransactionValidStart);
      }
      if (accountID_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(AccountID);
      }
      if (Scheduled != false) {
        output.WriteRawTag(24);
        output.WriteBool(Scheduled);
      }
      if (Nonce != 0) {
        output.WriteRawTag(32);
        output.WriteInt32(Nonce);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (transactionValidStart_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TransactionValidStart);
      }
      if (accountID_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(AccountID);
      }
      if (Scheduled != false) {
        size += 1 + 1;
      }
      if (Nonce != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(Nonce);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(TransactionID other) {
      if (other == null) {
        return;
      }
      if (other.transactionValidStart_ != null) {
        if (transactionValidStart_ == null) {
          TransactionValidStart = new global::Proto.Timestamp();
        }
        TransactionValidStart.MergeFrom(other.TransactionValidStart);
      }
      if (other.accountID_ != null) {
        if (accountID_ == null) {
          AccountID = new global::Proto.AccountID();
        }
        AccountID.MergeFrom(other.AccountID);
      }
      if (other.Scheduled != false) {
        Scheduled = other.Scheduled;
      }
      if (other.Nonce != 0) {
        Nonce = other.Nonce;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (transactionValidStart_ == null) {
              TransactionValidStart = new global::Proto.Timestamp();
            }
            input.ReadMessage(TransactionValidStart);
            break;
          }
          case 18: {
            if (accountID_ == null) {
              AccountID = new global::Proto.AccountID();
            }
            input.ReadMessage(AccountID);
            break;
          }
          case 24: {
            Scheduled = input.ReadBool();
            break;
          }
          case 32: {
            Nonce = input.ReadInt32();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (transactionValidStart_ == null) {
              TransactionValidStart = new global::Proto.Timestamp();
            }
            input.ReadMessage(TransactionValidStart);
            break;
          }
          case 18: {
            if (accountID_ == null) {
              AccountID = new global::Proto.AccountID();
            }
            input.ReadMessage(AccountID);
            break;
          }
          case 24: {
            Scheduled = input.ReadBool();
            break;
          }
          case 32: {
            Nonce = input.ReadInt32();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// Once a hook is created, its full id.
  /// &lt;p>
  /// A composite of its creating entity's id and an arbitrary 64-bit hook id
  /// (which need not be sequential).
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class HookId : pb::IMessage<HookId>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<HookId> _parser = new pb::MessageParser<HookId>(() => new HookId());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<HookId> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Proto.BasicTypesReflection.Descriptor.MessageTypes[10]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public HookId() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public HookId(HookId other) : this() {
      entityId_ = other.entityId_ != null ? other.entityId_.Clone() : null;
      hookId_ = other.hookId_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public HookId Clone() {
      return new HookId(this);
    }

    /// <summary>Field number for the "entity_id" field.</summary>
    public const int EntityIdFieldNumber = 1;
    private global::Proto.HookEntityId entityId_;
    /// <summary>
    ///*
    /// The hook's creating entity id.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.HookEntityId EntityId {
      get { return entityId_; }
      set {
        entityId_ = value;
      }
    }

    /// <summary>Field number for the "hook_id" field.</summary>
    public const int HookId_FieldNumber = 2;
    private long hookId_;
    /// <summary>
    ///*
    /// An arbitrary 64-bit identifier.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long HookId_ {
      get { return hookId_; }
      set {
        hookId_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as HookId);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(HookId other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(EntityId, other.EntityId)) return false;
      if (HookId_ != other.HookId_) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (entityId_ != null) hash ^= EntityId.GetHashCode();
      if (HookId_ != 0L) hash ^= HookId_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (entityId_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(EntityId);
      }
      if (HookId_ != 0L) {
        output.WriteRawTag(16);
        output.WriteInt64(HookId_);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (entityId_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(EntityId);
      }
      if (HookId_ != 0L) {
        output.WriteRawTag(16);
        output.WriteInt64(HookId_);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (entityId_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(EntityId);
      }
      if (HookId_ != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(HookId_);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(HookId other) {
      if (other == null) {
        return;
      }
      if (other.entityId_ != null) {
        if (entityId_ == null) {
          EntityId = new global::Proto.HookEntityId();
        }
        EntityId.MergeFrom(other.EntityId);
      }
      if (other.HookId_ != 0L) {
        HookId_ = other.HookId_;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (entityId_ == null) {
              EntityId = new global::Proto.HookEntityId();
            }
            input.ReadMessage(EntityId);
            break;
          }
          case 16: {
            HookId_ = input.ReadInt64();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (entityId_ == null) {
              EntityId = new global::Proto.HookEntityId();
            }
            input.ReadMessage(EntityId);
            break;
          }
          case 16: {
            HookId_ = input.ReadInt64();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// The id of an entity using a hook.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class HookEntityId : pb::IMessage<HookEntityId>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<HookEntityId> _parser = new pb::MessageParser<HookEntityId>(() => new HookEntityId());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<HookEntityId> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Proto.BasicTypesReflection.Descriptor.MessageTypes[11]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public HookEntityId() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public HookEntityId(HookEntityId other) : this() {
      switch (other.EntityIdCase) {
        case EntityIdOneofCase.AccountId:
          AccountId = other.AccountId.Clone();
          break;
        case EntityIdOneofCase.ContractId:
          ContractId = other.ContractId.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public HookEntityId Clone() {
      return new HookEntityId(this);
    }

    /// <summary>Field number for the "account_id" field.</summary>
    public const int AccountIdFieldNumber = 1;
    /// <summary>
    ///*
    /// An account using a hook.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.AccountID AccountId {
      get { return entityIdCase_ == EntityIdOneofCase.AccountId ? (global::Proto.AccountID) entityId_ : null; }
      set {
        entityId_ = value;
        entityIdCase_ = value == null ? EntityIdOneofCase.None : EntityIdOneofCase.AccountId;
      }
    }

    /// <summary>Field number for the "contract_id" field.</summary>
    public const int ContractIdFieldNumber = 2;
    /// <summary>
    ///*
    /// A contract using a hook.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.ContractID ContractId {
      get { return entityIdCase_ == EntityIdOneofCase.ContractId ? (global::Proto.ContractID) entityId_ : null; }
      set {
        entityId_ = value;
        entityIdCase_ = value == null ? EntityIdOneofCase.None : EntityIdOneofCase.ContractId;
      }
    }

    private object entityId_;
    /// <summary>Enum of possible cases for the "entity_id" oneof.</summary>
    public enum EntityIdOneofCase {
      None = 0,
      AccountId = 1,
      ContractId = 2,
    }
    private EntityIdOneofCase entityIdCase_ = EntityIdOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public EntityIdOneofCase EntityIdCase {
      get { return entityIdCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearEntityId() {
      entityIdCase_ = EntityIdOneofCase.None;
      entityId_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as HookEntityId);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(HookEntityId other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(AccountId, other.AccountId)) return false;
      if (!object.Equals(ContractId, other.ContractId)) return false;
      if (EntityIdCase != other.EntityIdCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (entityIdCase_ == EntityIdOneofCase.AccountId) hash ^= AccountId.GetHashCode();
      if (entityIdCase_ == EntityIdOneofCase.ContractId) hash ^= ContractId.GetHashCode();
      hash ^= (int) entityIdCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (entityIdCase_ == EntityIdOneofCase.AccountId) {
        output.WriteRawTag(10);
        output.WriteMessage(AccountId);
      }
      if (entityIdCase_ == EntityIdOneofCase.ContractId) {
        output.WriteRawTag(18);
        output.WriteMessage(ContractId);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (entityIdCase_ == EntityIdOneofCase.AccountId) {
        output.WriteRawTag(10);
        output.WriteMessage(AccountId);
      }
      if (entityIdCase_ == EntityIdOneofCase.ContractId) {
        output.WriteRawTag(18);
        output.WriteMessage(ContractId);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (entityIdCase_ == EntityIdOneofCase.AccountId) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(AccountId);
      }
      if (entityIdCase_ == EntityIdOneofCase.ContractId) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ContractId);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(HookEntityId other) {
      if (other == null) {
        return;
      }
      switch (other.EntityIdCase) {
        case EntityIdOneofCase.AccountId:
          if (AccountId == null) {
            AccountId = new global::Proto.AccountID();
          }
          AccountId.MergeFrom(other.AccountId);
          break;
        case EntityIdOneofCase.ContractId:
          if (ContractId == null) {
            ContractId = new global::Proto.ContractID();
          }
          ContractId.MergeFrom(other.ContractId);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            global::Proto.AccountID subBuilder = new global::Proto.AccountID();
            if (entityIdCase_ == EntityIdOneofCase.AccountId) {
              subBuilder.MergeFrom(AccountId);
            }
            input.ReadMessage(subBuilder);
            AccountId = subBuilder;
            break;
          }
          case 18: {
            global::Proto.ContractID subBuilder = new global::Proto.ContractID();
            if (entityIdCase_ == EntityIdOneofCase.ContractId) {
              subBuilder.MergeFrom(ContractId);
            }
            input.ReadMessage(subBuilder);
            ContractId = subBuilder;
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            global::Proto.AccountID subBuilder = new global::Proto.AccountID();
            if (entityIdCase_ == EntityIdOneofCase.AccountId) {
              subBuilder.MergeFrom(AccountId);
            }
            input.ReadMessage(subBuilder);
            AccountId = subBuilder;
            break;
          }
          case 18: {
            global::Proto.ContractID subBuilder = new global::Proto.ContractID();
            if (entityIdCase_ == EntityIdOneofCase.ContractId) {
              subBuilder.MergeFrom(ContractId);
            }
            input.ReadMessage(subBuilder);
            ContractId = subBuilder;
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// Specifies a call to a hook from within a transaction.
  /// &lt;p>
  /// Often the hook's entity is implied by the nature of the call site. For example, when using an account allowance hook
  /// inside a crypto transfer, the hook's entity is necessarily the account whose authorization is required.
  /// &lt;p>
  /// For future extension points where the hook owner is not forced by the context, we include the option to fully
  /// specify the hook id for the call.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class HookCall : pb::IMessage<HookCall>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<HookCall> _parser = new pb::MessageParser<HookCall>(() => new HookCall());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<HookCall> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Proto.BasicTypesReflection.Descriptor.MessageTypes[12]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public HookCall() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public HookCall(HookCall other) : this() {
      switch (other.IdCase) {
        case IdOneofCase.HookId:
          HookId = other.HookId;
          break;
      }

      switch (other.CallSpecCase) {
        case CallSpecOneofCase.EvmHookCall:
          EvmHookCall = other.EvmHookCall.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public HookCall Clone() {
      return new HookCall(this);
    }

    /// <summary>Field number for the "hook_id" field.</summary>
    public const int HookIdFieldNumber = 1;
    /// <summary>
    ///*
    /// The numeric id of the hook to call, when the owning entity is forced by the call site.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long HookId {
      get { return HasHookId ? (long) id_ : 0L; }
      set {
        id_ = value;
        idCase_ = IdOneofCase.HookId;
      }
    }
    /// <summary>Gets whether the "hook_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasHookId {
      get { return idCase_ == IdOneofCase.HookId; }
    }
    /// <summary> Clears the value of the oneof if it's currently set to "hook_id" </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearHookId() {
      if (HasHookId) {
        ClearId();
      }
    }

    /// <summary>Field number for the "evm_hook_call" field.</summary>
    public const int EvmHookCallFieldNumber = 3;
    /// <summary>
    ///*
    /// Specification of how to call an EVM hook.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.EvmHookCall EvmHookCall {
      get { return callSpecCase_ == CallSpecOneofCase.EvmHookCall ? (global::Proto.EvmHookCall) callSpec_ : null; }
      set {
        callSpec_ = value;
        callSpecCase_ = value == null ? CallSpecOneofCase.None : CallSpecOneofCase.EvmHookCall;
      }
    }

    private object id_;
    /// <summary>Enum of possible cases for the "id" oneof.</summary>
    public enum IdOneofCase {
      None = 0,
      HookId = 1,
    }
    private IdOneofCase idCase_ = IdOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public IdOneofCase IdCase {
      get { return idCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearId() {
      idCase_ = IdOneofCase.None;
      id_ = null;
    }

    private object callSpec_;
    /// <summary>Enum of possible cases for the "call_spec" oneof.</summary>
    public enum CallSpecOneofCase {
      None = 0,
      EvmHookCall = 3,
    }
    private CallSpecOneofCase callSpecCase_ = CallSpecOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public CallSpecOneofCase CallSpecCase {
      get { return callSpecCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearCallSpec() {
      callSpecCase_ = CallSpecOneofCase.None;
      callSpec_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as HookCall);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(HookCall other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (HookId != other.HookId) return false;
      if (!object.Equals(EvmHookCall, other.EvmHookCall)) return false;
      if (IdCase != other.IdCase) return false;
      if (CallSpecCase != other.CallSpecCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasHookId) hash ^= HookId.GetHashCode();
      if (callSpecCase_ == CallSpecOneofCase.EvmHookCall) hash ^= EvmHookCall.GetHashCode();
      hash ^= (int) idCase_;
      hash ^= (int) callSpecCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasHookId) {
        output.WriteRawTag(8);
        output.WriteInt64(HookId);
      }
      if (callSpecCase_ == CallSpecOneofCase.EvmHookCall) {
        output.WriteRawTag(26);
        output.WriteMessage(EvmHookCall);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasHookId) {
        output.WriteRawTag(8);
        output.WriteInt64(HookId);
      }
      if (callSpecCase_ == CallSpecOneofCase.EvmHookCall) {
        output.WriteRawTag(26);
        output.WriteMessage(EvmHookCall);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasHookId) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(HookId);
      }
      if (callSpecCase_ == CallSpecOneofCase.EvmHookCall) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(EvmHookCall);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(HookCall other) {
      if (other == null) {
        return;
      }
      switch (other.IdCase) {
        case IdOneofCase.HookId:
          HookId = other.HookId;
          break;
      }

      switch (other.CallSpecCase) {
        case CallSpecOneofCase.EvmHookCall:
          if (EvmHookCall == null) {
            EvmHookCall = new global::Proto.EvmHookCall();
          }
          EvmHookCall.MergeFrom(other.EvmHookCall);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            HookId = input.ReadInt64();
            break;
          }
          case 26: {
            global::Proto.EvmHookCall subBuilder = new global::Proto.EvmHookCall();
            if (callSpecCase_ == CallSpecOneofCase.EvmHookCall) {
              subBuilder.MergeFrom(EvmHookCall);
            }
            input.ReadMessage(subBuilder);
            EvmHookCall = subBuilder;
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            HookId = input.ReadInt64();
            break;
          }
          case 26: {
            global::Proto.EvmHookCall subBuilder = new global::Proto.EvmHookCall();
            if (callSpecCase_ == CallSpecOneofCase.EvmHookCall) {
              subBuilder.MergeFrom(EvmHookCall);
            }
            input.ReadMessage(subBuilder);
            EvmHookCall = subBuilder;
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// Specifies details of a call to an EVM hook.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class EvmHookCall : pb::IMessage<EvmHookCall>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<EvmHookCall> _parser = new pb::MessageParser<EvmHookCall>(() => new EvmHookCall());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<EvmHookCall> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Proto.BasicTypesReflection.Descriptor.MessageTypes[13]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public EvmHookCall() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public EvmHookCall(EvmHookCall other) : this() {
      data_ = other.data_;
      gasLimit_ = other.gasLimit_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public EvmHookCall Clone() {
      return new EvmHookCall(this);
    }

    /// <summary>Field number for the "data" field.</summary>
    public const int DataFieldNumber = 1;
    private pb::ByteString data_ = pb::ByteString.Empty;
    /// <summary>
    ///*
    /// Call data to pass to the hook via the IHieroHook.HookContext#data field.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString Data {
      get { return data_; }
      set {
        data_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "gas_limit" field.</summary>
    public const int GasLimitFieldNumber = 2;
    private ulong gasLimit_;
    /// <summary>
    ///*
    /// The gas limit to use.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ulong GasLimit {
      get { return gasLimit_; }
      set {
        gasLimit_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as EvmHookCall);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(EvmHookCall other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Data != other.Data) return false;
      if (GasLimit != other.GasLimit) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Data.Length != 0) hash ^= Data.GetHashCode();
      if (GasLimit != 0UL) hash ^= GasLimit.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Data.Length != 0) {
        output.WriteRawTag(10);
        output.WriteBytes(Data);
      }
      if (GasLimit != 0UL) {
        output.WriteRawTag(16);
        output.WriteUInt64(GasLimit);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Data.Length != 0) {
        output.WriteRawTag(10);
        output.WriteBytes(Data);
      }
      if (GasLimit != 0UL) {
        output.WriteRawTag(16);
        output.WriteUInt64(GasLimit);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Data.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Data);
      }
      if (GasLimit != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(GasLimit);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(EvmHookCall other) {
      if (other == null) {
        return;
      }
      if (other.Data.Length != 0) {
        Data = other.Data;
      }
      if (other.GasLimit != 0UL) {
        GasLimit = other.GasLimit;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Data = input.ReadBytes();
            break;
          }
          case 16: {
            GasLimit = input.ReadUInt64();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Data = input.ReadBytes();
            break;
          }
          case 16: {
            GasLimit = input.ReadUInt64();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// An account, and the amount that it sends or receives during a token transfer.
  ///
  /// This message is only relevant to fungible/common token transfers.
  /// Non-fungible/unique (NFT) token transfers MUST use the NftTransfer message.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class AccountAmount : pb::IMessage<AccountAmount>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<AccountAmount> _parser = new pb::MessageParser<AccountAmount>(() => new AccountAmount());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<AccountAmount> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Proto.BasicTypesReflection.Descriptor.MessageTypes[14]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AccountAmount() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AccountAmount(AccountAmount other) : this() {
      accountID_ = other.accountID_ != null ? other.accountID_.Clone() : null;
      amount_ = other.amount_;
      isApproval_ = other.isApproval_;
      switch (other.HookCallCase) {
        case HookCallOneofCase.PreTxAllowanceHook:
          PreTxAllowanceHook = other.PreTxAllowanceHook.Clone();
          break;
        case HookCallOneofCase.PrePostTxAllowanceHook:
          PrePostTxAllowanceHook = other.PrePostTxAllowanceHook.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AccountAmount Clone() {
      return new AccountAmount(this);
    }

    /// <summary>Field number for the "accountID" field.</summary>
    public const int AccountIDFieldNumber = 1;
    private global::Proto.AccountID accountID_;
    /// <summary>
    ///*
    /// An account identifier that will send or receive token(s).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.AccountID AccountID {
      get { return accountID_; }
      set {
        accountID_ = value;
      }
    }

    /// <summary>Field number for the "amount" field.</summary>
    public const int AmountFieldNumber = 2;
    private long amount_;
    /// <summary>
    ///*
    /// An amount to send (negative) or receive (positive).
    /// &lt;p>
    /// This amount MUST be denominated in the smallest unit of the relevant
    /// token.&lt;br/>
    /// For HBAR this SHALL be tinybar (10&lt;sup>-8&lt;/sup> HBAR).&lt;br/>
    /// For other fungible/common tokens this SHALL depend on the value of
    /// `decimals` for that token.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long Amount {
      get { return amount_; }
      set {
        amount_ = value;
      }
    }

    /// <summary>Field number for the "is_approval" field.</summary>
    public const int IsApprovalFieldNumber = 3;
    private bool isApproval_;
    /// <summary>
    ///*
    /// An approved allowance flag.&lt;br/>
    /// If true then the transfer is expected to be an approved allowance.
    /// &lt;p>
    /// If set, `accountID` SHALL be the owner that previously approved
    /// the allowance.&lt;br/>
    /// The default value SHALL be false (unset).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool IsApproval {
      get { return isApproval_; }
      set {
        isApproval_ = value;
      }
    }

    /// <summary>Field number for the "pre_tx_allowance_hook" field.</summary>
    public const int PreTxAllowanceHookFieldNumber = 4;
    /// <summary>
    ///*
    /// A single call made before attempting the CryptoTransfer, to a
    /// method with logical signature allow(HookContext, ProposedTransfers)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.HookCall PreTxAllowanceHook {
      get { return hookCallCase_ == HookCallOneofCase.PreTxAllowanceHook ? (global::Proto.HookCall) hookCall_ : null; }
      set {
        hookCall_ = value;
        hookCallCase_ = value == null ? HookCallOneofCase.None : HookCallOneofCase.PreTxAllowanceHook;
      }
    }

    /// <summary>Field number for the "pre_post_tx_allowance_hook" field.</summary>
    public const int PrePostTxAllowanceHookFieldNumber = 5;
    /// <summary>
    ///*
    /// Two calls, the first call before attempting the CryptoTransfer, to a
    /// method with logical signature allowPre(HookContext, ProposedTransfers);
    /// and the second call after attempting the CryptoTransfer, to a method
    /// with logical signature allowPost(HookContext, ProposedTransfers).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.HookCall PrePostTxAllowanceHook {
      get { return hookCallCase_ == HookCallOneofCase.PrePostTxAllowanceHook ? (global::Proto.HookCall) hookCall_ : null; }
      set {
        hookCall_ = value;
        hookCallCase_ = value == null ? HookCallOneofCase.None : HookCallOneofCase.PrePostTxAllowanceHook;
      }
    }

    private object hookCall_;
    /// <summary>Enum of possible cases for the "hook_call" oneof.</summary>
    public enum HookCallOneofCase {
      None = 0,
      PreTxAllowanceHook = 4,
      PrePostTxAllowanceHook = 5,
    }
    private HookCallOneofCase hookCallCase_ = HookCallOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public HookCallOneofCase HookCallCase {
      get { return hookCallCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearHookCall() {
      hookCallCase_ = HookCallOneofCase.None;
      hookCall_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as AccountAmount);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(AccountAmount other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(AccountID, other.AccountID)) return false;
      if (Amount != other.Amount) return false;
      if (IsApproval != other.IsApproval) return false;
      if (!object.Equals(PreTxAllowanceHook, other.PreTxAllowanceHook)) return false;
      if (!object.Equals(PrePostTxAllowanceHook, other.PrePostTxAllowanceHook)) return false;
      if (HookCallCase != other.HookCallCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (accountID_ != null) hash ^= AccountID.GetHashCode();
      if (Amount != 0L) hash ^= Amount.GetHashCode();
      if (IsApproval != false) hash ^= IsApproval.GetHashCode();
      if (hookCallCase_ == HookCallOneofCase.PreTxAllowanceHook) hash ^= PreTxAllowanceHook.GetHashCode();
      if (hookCallCase_ == HookCallOneofCase.PrePostTxAllowanceHook) hash ^= PrePostTxAllowanceHook.GetHashCode();
      hash ^= (int) hookCallCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (accountID_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(AccountID);
      }
      if (Amount != 0L) {
        output.WriteRawTag(16);
        output.WriteSInt64(Amount);
      }
      if (IsApproval != false) {
        output.WriteRawTag(24);
        output.WriteBool(IsApproval);
      }
      if (hookCallCase_ == HookCallOneofCase.PreTxAllowanceHook) {
        output.WriteRawTag(34);
        output.WriteMessage(PreTxAllowanceHook);
      }
      if (hookCallCase_ == HookCallOneofCase.PrePostTxAllowanceHook) {
        output.WriteRawTag(42);
        output.WriteMessage(PrePostTxAllowanceHook);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (accountID_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(AccountID);
      }
      if (Amount != 0L) {
        output.WriteRawTag(16);
        output.WriteSInt64(Amount);
      }
      if (IsApproval != false) {
        output.WriteRawTag(24);
        output.WriteBool(IsApproval);
      }
      if (hookCallCase_ == HookCallOneofCase.PreTxAllowanceHook) {
        output.WriteRawTag(34);
        output.WriteMessage(PreTxAllowanceHook);
      }
      if (hookCallCase_ == HookCallOneofCase.PrePostTxAllowanceHook) {
        output.WriteRawTag(42);
        output.WriteMessage(PrePostTxAllowanceHook);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (accountID_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(AccountID);
      }
      if (Amount != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeSInt64Size(Amount);
      }
      if (IsApproval != false) {
        size += 1 + 1;
      }
      if (hookCallCase_ == HookCallOneofCase.PreTxAllowanceHook) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(PreTxAllowanceHook);
      }
      if (hookCallCase_ == HookCallOneofCase.PrePostTxAllowanceHook) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(PrePostTxAllowanceHook);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(AccountAmount other) {
      if (other == null) {
        return;
      }
      if (other.accountID_ != null) {
        if (accountID_ == null) {
          AccountID = new global::Proto.AccountID();
        }
        AccountID.MergeFrom(other.AccountID);
      }
      if (other.Amount != 0L) {
        Amount = other.Amount;
      }
      if (other.IsApproval != false) {
        IsApproval = other.IsApproval;
      }
      switch (other.HookCallCase) {
        case HookCallOneofCase.PreTxAllowanceHook:
          if (PreTxAllowanceHook == null) {
            PreTxAllowanceHook = new global::Proto.HookCall();
          }
          PreTxAllowanceHook.MergeFrom(other.PreTxAllowanceHook);
          break;
        case HookCallOneofCase.PrePostTxAllowanceHook:
          if (PrePostTxAllowanceHook == null) {
            PrePostTxAllowanceHook = new global::Proto.HookCall();
          }
          PrePostTxAllowanceHook.MergeFrom(other.PrePostTxAllowanceHook);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (accountID_ == null) {
              AccountID = new global::Proto.AccountID();
            }
            input.ReadMessage(AccountID);
            break;
          }
          case 16: {
            Amount = input.ReadSInt64();
            break;
          }
          case 24: {
            IsApproval = input.ReadBool();
            break;
          }
          case 34: {
            global::Proto.HookCall subBuilder = new global::Proto.HookCall();
            if (hookCallCase_ == HookCallOneofCase.PreTxAllowanceHook) {
              subBuilder.MergeFrom(PreTxAllowanceHook);
            }
            input.ReadMessage(subBuilder);
            PreTxAllowanceHook = subBuilder;
            break;
          }
          case 42: {
            global::Proto.HookCall subBuilder = new global::Proto.HookCall();
            if (hookCallCase_ == HookCallOneofCase.PrePostTxAllowanceHook) {
              subBuilder.MergeFrom(PrePostTxAllowanceHook);
            }
            input.ReadMessage(subBuilder);
            PrePostTxAllowanceHook = subBuilder;
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (accountID_ == null) {
              AccountID = new global::Proto.AccountID();
            }
            input.ReadMessage(AccountID);
            break;
          }
          case 16: {
            Amount = input.ReadSInt64();
            break;
          }
          case 24: {
            IsApproval = input.ReadBool();
            break;
          }
          case 34: {
            global::Proto.HookCall subBuilder = new global::Proto.HookCall();
            if (hookCallCase_ == HookCallOneofCase.PreTxAllowanceHook) {
              subBuilder.MergeFrom(PreTxAllowanceHook);
            }
            input.ReadMessage(subBuilder);
            PreTxAllowanceHook = subBuilder;
            break;
          }
          case 42: {
            global::Proto.HookCall subBuilder = new global::Proto.HookCall();
            if (hookCallCase_ == HookCallOneofCase.PrePostTxAllowanceHook) {
              subBuilder.MergeFrom(PrePostTxAllowanceHook);
            }
            input.ReadMessage(subBuilder);
            PrePostTxAllowanceHook = subBuilder;
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// A list of accounts and amounts to transfer.
  ///
  /// Each `AccountAmount` SHALL specify the account and the amount to
  /// send(negative) or receive(positive).&lt;br/>
  /// Each `TransferList` SHALL be contained in another message that contains
  /// other details required to complete a transfer. This is typically a
  /// `CryptoTransferTransactionBody` or `TransactionRecord`.&lt;br/>
  /// The `TransferList` SHALL only be used for HBAR transfers. Other token types
  /// MUST use the `TokenTransferList` message.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class TransferList : pb::IMessage<TransferList>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<TransferList> _parser = new pb::MessageParser<TransferList>(() => new TransferList());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<TransferList> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Proto.BasicTypesReflection.Descriptor.MessageTypes[15]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TransferList() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TransferList(TransferList other) : this() {
      accountAmounts_ = other.accountAmounts_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TransferList Clone() {
      return new TransferList(this);
    }

    /// <summary>Field number for the "accountAmounts" field.</summary>
    public const int AccountAmountsFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Proto.AccountAmount> _repeated_accountAmounts_codec
        = pb::FieldCodec.ForMessage(10, global::Proto.AccountAmount.Parser);
    private readonly pbc::RepeatedField<global::Proto.AccountAmount> accountAmounts_ = new pbc::RepeatedField<global::Proto.AccountAmount>();
    /// <summary>
    ///*
    /// A list of AccountAmount pairs.&lt;br/>
    /// Each entry in this list is an account and an amount to transfer
    /// into it (positive) or out of it (negative)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Proto.AccountAmount> AccountAmounts {
      get { return accountAmounts_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as TransferList);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(TransferList other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!accountAmounts_.Equals(other.accountAmounts_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= accountAmounts_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      accountAmounts_.WriteTo(output, _repeated_accountAmounts_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      accountAmounts_.WriteTo(ref output, _repeated_accountAmounts_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += accountAmounts_.CalculateSize(_repeated_accountAmounts_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(TransferList other) {
      if (other == null) {
        return;
      }
      accountAmounts_.Add(other.accountAmounts_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            accountAmounts_.AddEntriesFrom(input, _repeated_accountAmounts_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            accountAmounts_.AddEntriesFrom(ref input, _repeated_accountAmounts_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// A NFT transfer.&lt;br/>
  /// This refers to a sender account, a receiver account, and the serial number
  /// of an NFT to transfer from sender to receiver.
  ///
  /// Each `NftTransfer` SHALL be contained in another message (typically
  /// `TokenTransferList`) that details which `Token` type applies to this NFT
  /// transfer.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class NftTransfer : pb::IMessage<NftTransfer>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<NftTransfer> _parser = new pb::MessageParser<NftTransfer>(() => new NftTransfer());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<NftTransfer> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Proto.BasicTypesReflection.Descriptor.MessageTypes[16]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NftTransfer() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NftTransfer(NftTransfer other) : this() {
      senderAccountID_ = other.senderAccountID_ != null ? other.senderAccountID_.Clone() : null;
      receiverAccountID_ = other.receiverAccountID_ != null ? other.receiverAccountID_.Clone() : null;
      serialNumber_ = other.serialNumber_;
      isApproval_ = other.isApproval_;
      switch (other.SenderAllowanceHookCallCase) {
        case SenderAllowanceHookCallOneofCase.PreTxSenderAllowanceHook:
          PreTxSenderAllowanceHook = other.PreTxSenderAllowanceHook.Clone();
          break;
        case SenderAllowanceHookCallOneofCase.PrePostTxSenderAllowanceHook:
          PrePostTxSenderAllowanceHook = other.PrePostTxSenderAllowanceHook.Clone();
          break;
      }

      switch (other.ReceiverAllowanceHookCallCase) {
        case ReceiverAllowanceHookCallOneofCase.PreTxReceiverAllowanceHook:
          PreTxReceiverAllowanceHook = other.PreTxReceiverAllowanceHook.Clone();
          break;
        case ReceiverAllowanceHookCallOneofCase.PrePostTxReceiverAllowanceHook:
          PrePostTxReceiverAllowanceHook = other.PrePostTxReceiverAllowanceHook.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NftTransfer Clone() {
      return new NftTransfer(this);
    }

    /// <summary>Field number for the "senderAccountID" field.</summary>
    public const int SenderAccountIDFieldNumber = 1;
    private global::Proto.AccountID senderAccountID_;
    /// <summary>
    ///*
    /// An Account identifier for the sender.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.AccountID SenderAccountID {
      get { return senderAccountID_; }
      set {
        senderAccountID_ = value;
      }
    }

    /// <summary>Field number for the "receiverAccountID" field.</summary>
    public const int ReceiverAccountIDFieldNumber = 2;
    private global::Proto.AccountID receiverAccountID_;
    /// <summary>
    ///*
    /// An Account identifier for the receiver.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.AccountID ReceiverAccountID {
      get { return receiverAccountID_; }
      set {
        receiverAccountID_ = value;
      }
    }

    /// <summary>Field number for the "serialNumber" field.</summary>
    public const int SerialNumberFieldNumber = 3;
    private long serialNumber_;
    /// <summary>
    ///*
    /// A serial number for the NFT to transfer.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long SerialNumber {
      get { return serialNumber_; }
      set {
        serialNumber_ = value;
      }
    }

    /// <summary>Field number for the "is_approval" field.</summary>
    public const int IsApprovalFieldNumber = 4;
    private bool isApproval_;
    /// <summary>
    ///*
    /// An approved allowance flag.&lt;br/>
    /// If true then the transfer is expected to be an approved allowance.
    /// &lt;p>
    /// If set, `senderAccountID` SHALL be the owner that previously approved
    /// the allowance.&lt;br/>
    /// If set, the `senderAccountID` MUST be the "payer" account for
    /// the transaction &lt;br/>
    /// The default value SHALL be false (unset).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool IsApproval {
      get { return isApproval_; }
      set {
        isApproval_ = value;
      }
    }

    /// <summary>Field number for the "pre_tx_sender_allowance_hook" field.</summary>
    public const int PreTxSenderAllowanceHookFieldNumber = 5;
    /// <summary>
    ///*
    /// A single call made before attempting the CryptoTransfer, to a
    /// method with logical signature allow(HookContext, ProposedTransfers)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.HookCall PreTxSenderAllowanceHook {
      get { return senderAllowanceHookCallCase_ == SenderAllowanceHookCallOneofCase.PreTxSenderAllowanceHook ? (global::Proto.HookCall) senderAllowanceHookCall_ : null; }
      set {
        senderAllowanceHookCall_ = value;
        senderAllowanceHookCallCase_ = value == null ? SenderAllowanceHookCallOneofCase.None : SenderAllowanceHookCallOneofCase.PreTxSenderAllowanceHook;
      }
    }

    /// <summary>Field number for the "pre_post_tx_sender_allowance_hook" field.</summary>
    public const int PrePostTxSenderAllowanceHookFieldNumber = 6;
    /// <summary>
    ///*
    /// Two calls, the first call before attempting the CryptoTransfer, to a
    /// method with logical signature allowPre(HookContext, ProposedTransfers);
    /// and the second call after attempting the CryptoTransfer, to a method
    /// with logical signature allowPost(HookContext, ProposedTransfers).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.HookCall PrePostTxSenderAllowanceHook {
      get { return senderAllowanceHookCallCase_ == SenderAllowanceHookCallOneofCase.PrePostTxSenderAllowanceHook ? (global::Proto.HookCall) senderAllowanceHookCall_ : null; }
      set {
        senderAllowanceHookCall_ = value;
        senderAllowanceHookCallCase_ = value == null ? SenderAllowanceHookCallOneofCase.None : SenderAllowanceHookCallOneofCase.PrePostTxSenderAllowanceHook;
      }
    }

    /// <summary>Field number for the "pre_tx_receiver_allowance_hook" field.</summary>
    public const int PreTxReceiverAllowanceHookFieldNumber = 7;
    /// <summary>
    ///*
    /// A single call made before attempting the CryptoTransfer, to a
    /// method with logical signature allow(HookContext, ProposedTransfers)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.HookCall PreTxReceiverAllowanceHook {
      get { return receiverAllowanceHookCallCase_ == ReceiverAllowanceHookCallOneofCase.PreTxReceiverAllowanceHook ? (global::Proto.HookCall) receiverAllowanceHookCall_ : null; }
      set {
        receiverAllowanceHookCall_ = value;
        receiverAllowanceHookCallCase_ = value == null ? ReceiverAllowanceHookCallOneofCase.None : ReceiverAllowanceHookCallOneofCase.PreTxReceiverAllowanceHook;
      }
    }

    /// <summary>Field number for the "pre_post_tx_receiver_allowance_hook" field.</summary>
    public const int PrePostTxReceiverAllowanceHookFieldNumber = 8;
    /// <summary>
    ///*
    /// Two calls, the first call before attempting the CryptoTransfer, to a
    /// method with logical signature allowPre(HookContext, ProposedTransfers);
    /// and the second call after attempting the CryptoTransfer, to a method
    /// with logical signature allowPost(HookContext, ProposedTransfers).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.HookCall PrePostTxReceiverAllowanceHook {
      get { return receiverAllowanceHookCallCase_ == ReceiverAllowanceHookCallOneofCase.PrePostTxReceiverAllowanceHook ? (global::Proto.HookCall) receiverAllowanceHookCall_ : null; }
      set {
        receiverAllowanceHookCall_ = value;
        receiverAllowanceHookCallCase_ = value == null ? ReceiverAllowanceHookCallOneofCase.None : ReceiverAllowanceHookCallOneofCase.PrePostTxReceiverAllowanceHook;
      }
    }

    private object senderAllowanceHookCall_;
    /// <summary>Enum of possible cases for the "sender_allowance_hook_call" oneof.</summary>
    public enum SenderAllowanceHookCallOneofCase {
      None = 0,
      PreTxSenderAllowanceHook = 5,
      PrePostTxSenderAllowanceHook = 6,
    }
    private SenderAllowanceHookCallOneofCase senderAllowanceHookCallCase_ = SenderAllowanceHookCallOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SenderAllowanceHookCallOneofCase SenderAllowanceHookCallCase {
      get { return senderAllowanceHookCallCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSenderAllowanceHookCall() {
      senderAllowanceHookCallCase_ = SenderAllowanceHookCallOneofCase.None;
      senderAllowanceHookCall_ = null;
    }

    private object receiverAllowanceHookCall_;
    /// <summary>Enum of possible cases for the "receiver_allowance_hook_call" oneof.</summary>
    public enum ReceiverAllowanceHookCallOneofCase {
      None = 0,
      PreTxReceiverAllowanceHook = 7,
      PrePostTxReceiverAllowanceHook = 8,
    }
    private ReceiverAllowanceHookCallOneofCase receiverAllowanceHookCallCase_ = ReceiverAllowanceHookCallOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ReceiverAllowanceHookCallOneofCase ReceiverAllowanceHookCallCase {
      get { return receiverAllowanceHookCallCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearReceiverAllowanceHookCall() {
      receiverAllowanceHookCallCase_ = ReceiverAllowanceHookCallOneofCase.None;
      receiverAllowanceHookCall_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as NftTransfer);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(NftTransfer other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(SenderAccountID, other.SenderAccountID)) return false;
      if (!object.Equals(ReceiverAccountID, other.ReceiverAccountID)) return false;
      if (SerialNumber != other.SerialNumber) return false;
      if (IsApproval != other.IsApproval) return false;
      if (!object.Equals(PreTxSenderAllowanceHook, other.PreTxSenderAllowanceHook)) return false;
      if (!object.Equals(PrePostTxSenderAllowanceHook, other.PrePostTxSenderAllowanceHook)) return false;
      if (!object.Equals(PreTxReceiverAllowanceHook, other.PreTxReceiverAllowanceHook)) return false;
      if (!object.Equals(PrePostTxReceiverAllowanceHook, other.PrePostTxReceiverAllowanceHook)) return false;
      if (SenderAllowanceHookCallCase != other.SenderAllowanceHookCallCase) return false;
      if (ReceiverAllowanceHookCallCase != other.ReceiverAllowanceHookCallCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (senderAccountID_ != null) hash ^= SenderAccountID.GetHashCode();
      if (receiverAccountID_ != null) hash ^= ReceiverAccountID.GetHashCode();
      if (SerialNumber != 0L) hash ^= SerialNumber.GetHashCode();
      if (IsApproval != false) hash ^= IsApproval.GetHashCode();
      if (senderAllowanceHookCallCase_ == SenderAllowanceHookCallOneofCase.PreTxSenderAllowanceHook) hash ^= PreTxSenderAllowanceHook.GetHashCode();
      if (senderAllowanceHookCallCase_ == SenderAllowanceHookCallOneofCase.PrePostTxSenderAllowanceHook) hash ^= PrePostTxSenderAllowanceHook.GetHashCode();
      if (receiverAllowanceHookCallCase_ == ReceiverAllowanceHookCallOneofCase.PreTxReceiverAllowanceHook) hash ^= PreTxReceiverAllowanceHook.GetHashCode();
      if (receiverAllowanceHookCallCase_ == ReceiverAllowanceHookCallOneofCase.PrePostTxReceiverAllowanceHook) hash ^= PrePostTxReceiverAllowanceHook.GetHashCode();
      hash ^= (int) senderAllowanceHookCallCase_;
      hash ^= (int) receiverAllowanceHookCallCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (senderAccountID_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(SenderAccountID);
      }
      if (receiverAccountID_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(ReceiverAccountID);
      }
      if (SerialNumber != 0L) {
        output.WriteRawTag(24);
        output.WriteInt64(SerialNumber);
      }
      if (IsApproval != false) {
        output.WriteRawTag(32);
        output.WriteBool(IsApproval);
      }
      if (senderAllowanceHookCallCase_ == SenderAllowanceHookCallOneofCase.PreTxSenderAllowanceHook) {
        output.WriteRawTag(42);
        output.WriteMessage(PreTxSenderAllowanceHook);
      }
      if (senderAllowanceHookCallCase_ == SenderAllowanceHookCallOneofCase.PrePostTxSenderAllowanceHook) {
        output.WriteRawTag(50);
        output.WriteMessage(PrePostTxSenderAllowanceHook);
      }
      if (receiverAllowanceHookCallCase_ == ReceiverAllowanceHookCallOneofCase.PreTxReceiverAllowanceHook) {
        output.WriteRawTag(58);
        output.WriteMessage(PreTxReceiverAllowanceHook);
      }
      if (receiverAllowanceHookCallCase_ == ReceiverAllowanceHookCallOneofCase.PrePostTxReceiverAllowanceHook) {
        output.WriteRawTag(66);
        output.WriteMessage(PrePostTxReceiverAllowanceHook);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (senderAccountID_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(SenderAccountID);
      }
      if (receiverAccountID_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(ReceiverAccountID);
      }
      if (SerialNumber != 0L) {
        output.WriteRawTag(24);
        output.WriteInt64(SerialNumber);
      }
      if (IsApproval != false) {
        output.WriteRawTag(32);
        output.WriteBool(IsApproval);
      }
      if (senderAllowanceHookCallCase_ == SenderAllowanceHookCallOneofCase.PreTxSenderAllowanceHook) {
        output.WriteRawTag(42);
        output.WriteMessage(PreTxSenderAllowanceHook);
      }
      if (senderAllowanceHookCallCase_ == SenderAllowanceHookCallOneofCase.PrePostTxSenderAllowanceHook) {
        output.WriteRawTag(50);
        output.WriteMessage(PrePostTxSenderAllowanceHook);
      }
      if (receiverAllowanceHookCallCase_ == ReceiverAllowanceHookCallOneofCase.PreTxReceiverAllowanceHook) {
        output.WriteRawTag(58);
        output.WriteMessage(PreTxReceiverAllowanceHook);
      }
      if (receiverAllowanceHookCallCase_ == ReceiverAllowanceHookCallOneofCase.PrePostTxReceiverAllowanceHook) {
        output.WriteRawTag(66);
        output.WriteMessage(PrePostTxReceiverAllowanceHook);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (senderAccountID_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SenderAccountID);
      }
      if (receiverAccountID_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ReceiverAccountID);
      }
      if (SerialNumber != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(SerialNumber);
      }
      if (IsApproval != false) {
        size += 1 + 1;
      }
      if (senderAllowanceHookCallCase_ == SenderAllowanceHookCallOneofCase.PreTxSenderAllowanceHook) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(PreTxSenderAllowanceHook);
      }
      if (senderAllowanceHookCallCase_ == SenderAllowanceHookCallOneofCase.PrePostTxSenderAllowanceHook) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(PrePostTxSenderAllowanceHook);
      }
      if (receiverAllowanceHookCallCase_ == ReceiverAllowanceHookCallOneofCase.PreTxReceiverAllowanceHook) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(PreTxReceiverAllowanceHook);
      }
      if (receiverAllowanceHookCallCase_ == ReceiverAllowanceHookCallOneofCase.PrePostTxReceiverAllowanceHook) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(PrePostTxReceiverAllowanceHook);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(NftTransfer other) {
      if (other == null) {
        return;
      }
      if (other.senderAccountID_ != null) {
        if (senderAccountID_ == null) {
          SenderAccountID = new global::Proto.AccountID();
        }
        SenderAccountID.MergeFrom(other.SenderAccountID);
      }
      if (other.receiverAccountID_ != null) {
        if (receiverAccountID_ == null) {
          ReceiverAccountID = new global::Proto.AccountID();
        }
        ReceiverAccountID.MergeFrom(other.ReceiverAccountID);
      }
      if (other.SerialNumber != 0L) {
        SerialNumber = other.SerialNumber;
      }
      if (other.IsApproval != false) {
        IsApproval = other.IsApproval;
      }
      switch (other.SenderAllowanceHookCallCase) {
        case SenderAllowanceHookCallOneofCase.PreTxSenderAllowanceHook:
          if (PreTxSenderAllowanceHook == null) {
            PreTxSenderAllowanceHook = new global::Proto.HookCall();
          }
          PreTxSenderAllowanceHook.MergeFrom(other.PreTxSenderAllowanceHook);
          break;
        case SenderAllowanceHookCallOneofCase.PrePostTxSenderAllowanceHook:
          if (PrePostTxSenderAllowanceHook == null) {
            PrePostTxSenderAllowanceHook = new global::Proto.HookCall();
          }
          PrePostTxSenderAllowanceHook.MergeFrom(other.PrePostTxSenderAllowanceHook);
          break;
      }

      switch (other.ReceiverAllowanceHookCallCase) {
        case ReceiverAllowanceHookCallOneofCase.PreTxReceiverAllowanceHook:
          if (PreTxReceiverAllowanceHook == null) {
            PreTxReceiverAllowanceHook = new global::Proto.HookCall();
          }
          PreTxReceiverAllowanceHook.MergeFrom(other.PreTxReceiverAllowanceHook);
          break;
        case ReceiverAllowanceHookCallOneofCase.PrePostTxReceiverAllowanceHook:
          if (PrePostTxReceiverAllowanceHook == null) {
            PrePostTxReceiverAllowanceHook = new global::Proto.HookCall();
          }
          PrePostTxReceiverAllowanceHook.MergeFrom(other.PrePostTxReceiverAllowanceHook);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (senderAccountID_ == null) {
              SenderAccountID = new global::Proto.AccountID();
            }
            input.ReadMessage(SenderAccountID);
            break;
          }
          case 18: {
            if (receiverAccountID_ == null) {
              ReceiverAccountID = new global::Proto.AccountID();
            }
            input.ReadMessage(ReceiverAccountID);
            break;
          }
          case 24: {
            SerialNumber = input.ReadInt64();
            break;
          }
          case 32: {
            IsApproval = input.ReadBool();
            break;
          }
          case 42: {
            global::Proto.HookCall subBuilder = new global::Proto.HookCall();
            if (senderAllowanceHookCallCase_ == SenderAllowanceHookCallOneofCase.PreTxSenderAllowanceHook) {
              subBuilder.MergeFrom(PreTxSenderAllowanceHook);
            }
            input.ReadMessage(subBuilder);
            PreTxSenderAllowanceHook = subBuilder;
            break;
          }
          case 50: {
            global::Proto.HookCall subBuilder = new global::Proto.HookCall();
            if (senderAllowanceHookCallCase_ == SenderAllowanceHookCallOneofCase.PrePostTxSenderAllowanceHook) {
              subBuilder.MergeFrom(PrePostTxSenderAllowanceHook);
            }
            input.ReadMessage(subBuilder);
            PrePostTxSenderAllowanceHook = subBuilder;
            break;
          }
          case 58: {
            global::Proto.HookCall subBuilder = new global::Proto.HookCall();
            if (receiverAllowanceHookCallCase_ == ReceiverAllowanceHookCallOneofCase.PreTxReceiverAllowanceHook) {
              subBuilder.MergeFrom(PreTxReceiverAllowanceHook);
            }
            input.ReadMessage(subBuilder);
            PreTxReceiverAllowanceHook = subBuilder;
            break;
          }
          case 66: {
            global::Proto.HookCall subBuilder = new global::Proto.HookCall();
            if (receiverAllowanceHookCallCase_ == ReceiverAllowanceHookCallOneofCase.PrePostTxReceiverAllowanceHook) {
              subBuilder.MergeFrom(PrePostTxReceiverAllowanceHook);
            }
            input.ReadMessage(subBuilder);
            PrePostTxReceiverAllowanceHook = subBuilder;
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (senderAccountID_ == null) {
              SenderAccountID = new global::Proto.AccountID();
            }
            input.ReadMessage(SenderAccountID);
            break;
          }
          case 18: {
            if (receiverAccountID_ == null) {
              ReceiverAccountID = new global::Proto.AccountID();
            }
            input.ReadMessage(ReceiverAccountID);
            break;
          }
          case 24: {
            SerialNumber = input.ReadInt64();
            break;
          }
          case 32: {
            IsApproval = input.ReadBool();
            break;
          }
          case 42: {
            global::Proto.HookCall subBuilder = new global::Proto.HookCall();
            if (senderAllowanceHookCallCase_ == SenderAllowanceHookCallOneofCase.PreTxSenderAllowanceHook) {
              subBuilder.MergeFrom(PreTxSenderAllowanceHook);
            }
            input.ReadMessage(subBuilder);
            PreTxSenderAllowanceHook = subBuilder;
            break;
          }
          case 50: {
            global::Proto.HookCall subBuilder = new global::Proto.HookCall();
            if (senderAllowanceHookCallCase_ == SenderAllowanceHookCallOneofCase.PrePostTxSenderAllowanceHook) {
              subBuilder.MergeFrom(PrePostTxSenderAllowanceHook);
            }
            input.ReadMessage(subBuilder);
            PrePostTxSenderAllowanceHook = subBuilder;
            break;
          }
          case 58: {
            global::Proto.HookCall subBuilder = new global::Proto.HookCall();
            if (receiverAllowanceHookCallCase_ == ReceiverAllowanceHookCallOneofCase.PreTxReceiverAllowanceHook) {
              subBuilder.MergeFrom(PreTxReceiverAllowanceHook);
            }
            input.ReadMessage(subBuilder);
            PreTxReceiverAllowanceHook = subBuilder;
            break;
          }
          case 66: {
            global::Proto.HookCall subBuilder = new global::Proto.HookCall();
            if (receiverAllowanceHookCallCase_ == ReceiverAllowanceHookCallOneofCase.PrePostTxReceiverAllowanceHook) {
              subBuilder.MergeFrom(PrePostTxReceiverAllowanceHook);
            }
            input.ReadMessage(subBuilder);
            PrePostTxReceiverAllowanceHook = subBuilder;
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// A list of transfers for a particular (non-HBAR) token type.
  ///
  /// A `TokenTransferList` applies to a single token type, but may contain many
  /// individual transfers.&lt;br/>
  /// Each transfer of a fungible/common token MUST specify an `accountID` and
  /// `amount`. Amount SHALL be positive when the account receives tokens, and
  /// SHALL be negative when the account sends tokens. The amount SHOULD NOT be
  /// `0`.&lt;br/>
  /// In a transfer list containing fungible/common tokens in the `transfers`
  /// list, the sum of all such transfers MUST be zero (`0`).
  /// Each transfer of a unique token SHALL specify both sender and receiver, as
  /// well as the serial number transferred.&lt;br/>
  /// A single `TokenTransferList` MUST contain `transfers` or `nftTransfers`,
  /// but MUST NOT contain both.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class TokenTransferList : pb::IMessage<TokenTransferList>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<TokenTransferList> _parser = new pb::MessageParser<TokenTransferList>(() => new TokenTransferList());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<TokenTransferList> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Proto.BasicTypesReflection.Descriptor.MessageTypes[17]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TokenTransferList() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TokenTransferList(TokenTransferList other) : this() {
      token_ = other.token_ != null ? other.token_.Clone() : null;
      transfers_ = other.transfers_.Clone();
      nftTransfers_ = other.nftTransfers_.Clone();
      ExpectedDecimals = other.ExpectedDecimals;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TokenTransferList Clone() {
      return new TokenTransferList(this);
    }

    /// <summary>Field number for the "token" field.</summary>
    public const int TokenFieldNumber = 1;
    private global::Proto.TokenID token_;
    /// <summary>
    ///*
    /// A token identifier.&lt;br/>
    /// This is the token to be transferred.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.TokenID Token {
      get { return token_; }
      set {
        token_ = value;
      }
    }

    /// <summary>Field number for the "transfers" field.</summary>
    public const int TransfersFieldNumber = 2;
    private static readonly pb::FieldCodec<global::Proto.AccountAmount> _repeated_transfers_codec
        = pb::FieldCodec.ForMessage(18, global::Proto.AccountAmount.Parser);
    private readonly pbc::RepeatedField<global::Proto.AccountAmount> transfers_ = new pbc::RepeatedField<global::Proto.AccountAmount>();
    /// <summary>
    ///*
    /// A list of account amounts.
    /// &lt;p>
    /// Each entry SHALL have an account and amount.&lt;br/>
    /// These transfers SHALL be "double-entry" style; the credits (positive
    /// amount) and debits (negative amount) MUST sum to 0, unless this
    /// transfer list is part of a `mint` or `burn` operation.&lt;br/>
    /// This SHALL be be set for fungible/common tokens and MUST be
    /// empty otherwise.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Proto.AccountAmount> Transfers {
      get { return transfers_; }
    }

    /// <summary>Field number for the "nftTransfers" field.</summary>
    public const int NftTransfersFieldNumber = 3;
    private static readonly pb::FieldCodec<global::Proto.NftTransfer> _repeated_nftTransfers_codec
        = pb::FieldCodec.ForMessage(26, global::Proto.NftTransfer.Parser);
    private readonly pbc::RepeatedField<global::Proto.NftTransfer> nftTransfers_ = new pbc::RepeatedField<global::Proto.NftTransfer>();
    /// <summary>
    ///*
    /// A list of NftTransfers.
    /// &lt;p>
    /// Each entry SHALL have a sender and receiver account, and the
    /// serial number of the unique token to transfer.&lt;br/>
    /// This SHALL be be set for non-fungible/unique tokens and SHALL be
    /// empty otherwise.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Proto.NftTransfer> NftTransfers {
      get { return nftTransfers_; }
    }

    /// <summary>Field number for the "expected_decimals" field.</summary>
    public const int ExpectedDecimalsFieldNumber = 4;
    private static readonly pb::FieldCodec<uint?> _single_expectedDecimals_codec = pb::FieldCodec.ForStructWrapper<uint>(34);
    private uint? expectedDecimals_;
    /// <summary>
    ///*
    /// An expected decimal precision.&lt;br/>
    /// This is the number of decimals a fungible/common token type is
    /// _expected_ to have.
    /// &lt;p>
    /// The transfer SHALL fail with response code `UNEXPECTED_TOKEN_DECIMALS`
    /// if this is set and the actual decimals specified for the `Token` differ
    /// from this value.&lt;br/>
    /// If `nftTransfers` is set, then this value SHOULD NOT be set.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint? ExpectedDecimals {
      get { return expectedDecimals_; }
      set {
        expectedDecimals_ = value;
      }
    }


    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as TokenTransferList);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(TokenTransferList other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Token, other.Token)) return false;
      if(!transfers_.Equals(other.transfers_)) return false;
      if(!nftTransfers_.Equals(other.nftTransfers_)) return false;
      if (ExpectedDecimals != other.ExpectedDecimals) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (token_ != null) hash ^= Token.GetHashCode();
      hash ^= transfers_.GetHashCode();
      hash ^= nftTransfers_.GetHashCode();
      if (expectedDecimals_ != null) hash ^= ExpectedDecimals.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (token_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Token);
      }
      transfers_.WriteTo(output, _repeated_transfers_codec);
      nftTransfers_.WriteTo(output, _repeated_nftTransfers_codec);
      if (expectedDecimals_ != null) {
        _single_expectedDecimals_codec.WriteTagAndValue(output, ExpectedDecimals);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (token_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Token);
      }
      transfers_.WriteTo(ref output, _repeated_transfers_codec);
      nftTransfers_.WriteTo(ref output, _repeated_nftTransfers_codec);
      if (expectedDecimals_ != null) {
        _single_expectedDecimals_codec.WriteTagAndValue(ref output, ExpectedDecimals);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (token_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Token);
      }
      size += transfers_.CalculateSize(_repeated_transfers_codec);
      size += nftTransfers_.CalculateSize(_repeated_nftTransfers_codec);
      if (expectedDecimals_ != null) {
        size += _single_expectedDecimals_codec.CalculateSizeWithTag(ExpectedDecimals);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(TokenTransferList other) {
      if (other == null) {
        return;
      }
      if (other.token_ != null) {
        if (token_ == null) {
          Token = new global::Proto.TokenID();
        }
        Token.MergeFrom(other.Token);
      }
      transfers_.Add(other.transfers_);
      nftTransfers_.Add(other.nftTransfers_);
      if (other.expectedDecimals_ != null) {
        if (expectedDecimals_ == null || other.ExpectedDecimals != 0) {
          ExpectedDecimals = other.ExpectedDecimals;
        }
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (token_ == null) {
              Token = new global::Proto.TokenID();
            }
            input.ReadMessage(Token);
            break;
          }
          case 18: {
            transfers_.AddEntriesFrom(input, _repeated_transfers_codec);
            break;
          }
          case 26: {
            nftTransfers_.AddEntriesFrom(input, _repeated_nftTransfers_codec);
            break;
          }
          case 34: {
            uint? value = _single_expectedDecimals_codec.Read(input);
            if (expectedDecimals_ == null || value != 0) {
              ExpectedDecimals = value;
            }
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (token_ == null) {
              Token = new global::Proto.TokenID();
            }
            input.ReadMessage(Token);
            break;
          }
          case 18: {
            transfers_.AddEntriesFrom(ref input, _repeated_transfers_codec);
            break;
          }
          case 26: {
            nftTransfers_.AddEntriesFrom(ref input, _repeated_nftTransfers_codec);
            break;
          }
          case 34: {
            uint? value = _single_expectedDecimals_codec.Read(ref input);
            if (expectedDecimals_ == null || value != 0) {
              ExpectedDecimals = value;
            }
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// A rational number.&lt;br/>
  /// A common use is to set the amount of a value transfer to collect as a
  /// custom fee.
  ///
  /// It is RECOMMENDED that both numerator and denominator be no larger than
  /// necessary to express the required fraction. A very large numerator, in
  /// particular, may not be reliable.
  /// Both fields are REQUIRED and SHOULD be positive integers.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class Fraction : pb::IMessage<Fraction>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Fraction> _parser = new pb::MessageParser<Fraction>(() => new Fraction());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Fraction> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Proto.BasicTypesReflection.Descriptor.MessageTypes[18]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Fraction() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Fraction(Fraction other) : this() {
      numerator_ = other.numerator_;
      denominator_ = other.denominator_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Fraction Clone() {
      return new Fraction(this);
    }

    /// <summary>Field number for the "numerator" field.</summary>
    public const int NumeratorFieldNumber = 1;
    private long numerator_;
    /// <summary>
    ///*
    /// A fractional number's numerator.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long Numerator {
      get { return numerator_; }
      set {
        numerator_ = value;
      }
    }

    /// <summary>Field number for the "denominator" field.</summary>
    public const int DenominatorFieldNumber = 2;
    private long denominator_;
    /// <summary>
    ///*
    /// A fractional number's denominator.
    /// &lt;p>
    /// A zero value SHALL fail with response code `FRACTION_DIVIDES_BY_ZERO`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long Denominator {
      get { return denominator_; }
      set {
        denominator_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Fraction);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Fraction other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Numerator != other.Numerator) return false;
      if (Denominator != other.Denominator) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Numerator != 0L) hash ^= Numerator.GetHashCode();
      if (Denominator != 0L) hash ^= Denominator.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Numerator != 0L) {
        output.WriteRawTag(8);
        output.WriteInt64(Numerator);
      }
      if (Denominator != 0L) {
        output.WriteRawTag(16);
        output.WriteInt64(Denominator);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Numerator != 0L) {
        output.WriteRawTag(8);
        output.WriteInt64(Numerator);
      }
      if (Denominator != 0L) {
        output.WriteRawTag(16);
        output.WriteInt64(Denominator);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Numerator != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(Numerator);
      }
      if (Denominator != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(Denominator);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Fraction other) {
      if (other == null) {
        return;
      }
      if (other.Numerator != 0L) {
        Numerator = other.Numerator;
      }
      if (other.Denominator != 0L) {
        Denominator = other.Denominator;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Numerator = input.ReadInt64();
            break;
          }
          case 16: {
            Denominator = input.ReadInt64();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Numerator = input.ReadInt64();
            break;
          }
          case 16: {
            Denominator = input.ReadInt64();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// A Key is an entity representing one or more cryptographic public/private key
  /// pairs and, optionally, the structure for how multiple signatures may be
  /// composed to meet complex multiple-signature authorization requirements.
  ///
  /// A Key can be a public key from either the Ed25519 or ECDSA(secp256k1)
  /// signature schemes. In the ECDSA(secp256k1) case we require the 33-byte
  /// compressed form of the public key. For simplicity, we call these
  /// cryptographic public keys `primitive` keys.&lt;br/>
  /// If an entity has a primitive key associated to it, then the corresponding
  /// private key must sign any transaction to send tokens or perform other
  /// actions requiring authorization.
  ///
  /// A Key can also be the ID of a smart contract, which SHALL authorize that
  /// contract to execute any system contract with signing requirements that are
  /// met by the key.&lt;br/>
  /// > Example
  /// >> If account `0.0.A` has a threshold key whose threshold is satisfied
  /// >> by a contract ID key for contract `0.0.C`, then when `0.0.C` is called,
  /// >> it is authorized to use system contracts to manage any asset owned by
  /// >> `0.0.A`. If the contract ID key is "delegatable", then `0.0.C` can even
  /// >> perform these actions when running code accessed via `DELEGATECALL`.
  ///
  /// A Key can be a "threshold key", which is a list of N keys, any M of which
  /// may sign in order for the signature to be considered valid. The value of
  /// M for a given threshold key MUST be less than or equal to N. A threshold
  /// key is sometimes called a "M-of-N" key.
  ///
  /// A Key can be a "key list" where all keys in the list must sign unless
  /// specified otherwise in the documentation for a specific transaction
  /// type (e.g. FileDeleteTransactionBody).&lt;br/>
  /// This implies that the use of a key list is dependent on context. For
  /// example, an Hedera file that is created with a list of keys, SHALL require
  /// that all of those keys must sign a transaction to create or modify the file,
  /// but only one key from that list MUST sign a transaction to delete the file.
  /// So it is a single list that sometimes acts as a N-of-N threshold key, and
  /// sometimes acts as a 1-of-N threshold key.&lt;br/>
  /// To reduce confusion this may cause, a key list SHALL always be considered
  /// N-of-N, unless specified otherwise in official documentation.&lt;br/>
  /// A key list MAY have repeated primitive public keys, but the signature
  /// requirement for all keys in a repeated set SHALL be satisfied by a single
  /// valid signature. There is no mechanism to require a single key to sign a
  /// single transaction more than once.
  ///
  /// Any list or threshold key MAY have nested key lists or threshold keys.
  /// This allows, for example, the keys within a threshold signature to
  /// themselves be threshold, list, contract, or primitive keys. This nesting
  /// structure enables complex asymmetric multi-party signature requirements to
  /// be met.
  ///
  /// To ensure adequate performance and transaction security, key nesting is
  /// limited to at most fifteen(15) levels.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class Key : pb::IMessage<Key>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Key> _parser = new pb::MessageParser<Key>(() => new Key());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Key> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Proto.BasicTypesReflection.Descriptor.MessageTypes[19]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Key() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Key(Key other) : this() {
      switch (other.KeyCase) {
        case KeyOneofCase.ContractID:
          ContractID = other.ContractID.Clone();
          break;
        case KeyOneofCase.Ed25519:
          Ed25519 = other.Ed25519;
          break;
        case KeyOneofCase.RSA3072:
          RSA3072 = other.RSA3072;
          break;
        case KeyOneofCase.ECDSA384:
          ECDSA384 = other.ECDSA384;
          break;
        case KeyOneofCase.ThresholdKey:
          ThresholdKey = other.ThresholdKey.Clone();
          break;
        case KeyOneofCase.KeyList:
          KeyList = other.KeyList.Clone();
          break;
        case KeyOneofCase.ECDSASecp256K1:
          ECDSASecp256K1 = other.ECDSASecp256K1;
          break;
        case KeyOneofCase.DelegatableContractId:
          DelegatableContractId = other.DelegatableContractId.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Key Clone() {
      return new Key(this);
    }

    /// <summary>Field number for the "contractID" field.</summary>
    public const int ContractIDFieldNumber = 1;
    /// <summary>
    ///*
    /// A smart contract instance that is authorized implicitly.
    /// &lt;p>
    /// This key type SHALL require that the code in the active message frame
    /// belong to the contract with the given id.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.ContractID ContractID {
      get { return keyCase_ == KeyOneofCase.ContractID ? (global::Proto.ContractID) key_ : null; }
      set {
        key_ = value;
        keyCase_ = value == null ? KeyOneofCase.None : KeyOneofCase.ContractID;
      }
    }

    /// <summary>Field number for the "ed25519" field.</summary>
    public const int Ed25519FieldNumber = 2;
    /// <summary>
    ///*
    /// An array of Ed25519 public key bytes.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString Ed25519 {
      get { return HasEd25519 ? (pb::ByteString) key_ : pb::ByteString.Empty; }
      set {
        key_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        keyCase_ = KeyOneofCase.Ed25519;
      }
    }
    /// <summary>Gets whether the "ed25519" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasEd25519 {
      get { return keyCase_ == KeyOneofCase.Ed25519; }
    }
    /// <summary> Clears the value of the oneof if it's currently set to "ed25519" </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearEd25519() {
      if (HasEd25519) {
        ClearKey();
      }
    }

    /// <summary>Field number for the "RSA_3072" field.</summary>
    public const int RSA3072FieldNumber = 3;
    /// <summary>
    ///*
    /// This option is not currently supported.&lt;br/>
    /// An array of RSA-3072 public key bytes.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString RSA3072 {
      get { return HasRSA3072 ? (pb::ByteString) key_ : pb::ByteString.Empty; }
      set {
        key_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        keyCase_ = KeyOneofCase.RSA3072;
      }
    }
    /// <summary>Gets whether the "RSA_3072" field is set</summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasRSA3072 {
      get { return keyCase_ == KeyOneofCase.RSA3072; }
    }
    /// <summary> Clears the value of the oneof if it's currently set to "RSA_3072" </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearRSA3072() {
      if (HasRSA3072) {
        ClearKey();
      }
    }

    /// <summary>Field number for the "ECDSA_384" field.</summary>
    public const int ECDSA384FieldNumber = 4;
    /// <summary>
    ///*
    /// This option is not currently supported.&lt;br/>
    /// An array of ECDSA, using the p-384 curve, public key bytes.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString ECDSA384 {
      get { return HasECDSA384 ? (pb::ByteString) key_ : pb::ByteString.Empty; }
      set {
        key_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        keyCase_ = KeyOneofCase.ECDSA384;
      }
    }
    /// <summary>Gets whether the "ECDSA_384" field is set</summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasECDSA384 {
      get { return keyCase_ == KeyOneofCase.ECDSA384; }
    }
    /// <summary> Clears the value of the oneof if it's currently set to "ECDSA_384" </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearECDSA384() {
      if (HasECDSA384) {
        ClearKey();
      }
    }

    /// <summary>Field number for the "thresholdKey" field.</summary>
    public const int ThresholdKeyFieldNumber = 5;
    /// <summary>
    ///*
    /// A threshold, M, combined with a list of N keys, any M of which are
    /// sufficient to form a valid signature.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.ThresholdKey ThresholdKey {
      get { return keyCase_ == KeyOneofCase.ThresholdKey ? (global::Proto.ThresholdKey) key_ : null; }
      set {
        key_ = value;
        keyCase_ = value == null ? KeyOneofCase.None : KeyOneofCase.ThresholdKey;
      }
    }

    /// <summary>Field number for the "keyList" field.</summary>
    public const int KeyListFieldNumber = 6;
    /// <summary>
    ///*
    /// A list of keys. This may be treated like a "N-of-N" threshold key,
    /// as a component of another key, or in some other manner as documented.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.KeyList KeyList {
      get { return keyCase_ == KeyOneofCase.KeyList ? (global::Proto.KeyList) key_ : null; }
      set {
        key_ = value;
        keyCase_ = value == null ? KeyOneofCase.None : KeyOneofCase.KeyList;
      }
    }

    /// <summary>Field number for the "ECDSA_secp256k1" field.</summary>
    public const int ECDSASecp256K1FieldNumber = 7;
    /// <summary>
    ///*
    /// A set of compressed ECDSA(secp256k1) public key bytes.&lt;br/>
    /// This is an EVM compatibility format.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString ECDSASecp256K1 {
      get { return HasECDSASecp256K1 ? (pb::ByteString) key_ : pb::ByteString.Empty; }
      set {
        key_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        keyCase_ = KeyOneofCase.ECDSASecp256K1;
      }
    }
    /// <summary>Gets whether the "ECDSA_secp256k1" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasECDSASecp256K1 {
      get { return keyCase_ == KeyOneofCase.ECDSASecp256K1; }
    }
    /// <summary> Clears the value of the oneof if it's currently set to "ECDSA_secp256k1" </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearECDSASecp256K1() {
      if (HasECDSASecp256K1) {
        ClearKey();
      }
    }

    /// <summary>Field number for the "delegatable_contract_id" field.</summary>
    public const int DelegatableContractIdFieldNumber = 8;
    /// <summary>
    ///*
    /// A smart contract that, if the recipient of the active message frame,
    /// SHALL be imputed authorization.&lt;br/>
    /// Setting this key type is a more permissive version of setting a
    /// contractID key.
    /// &lt;p>
    /// This key form SHALL NOT strictly require that the code being executed
    /// in the frame belong to the given contract. The code in frame MAY be
    /// running another contract via a `delegatecall`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.ContractID DelegatableContractId {
      get { return keyCase_ == KeyOneofCase.DelegatableContractId ? (global::Proto.ContractID) key_ : null; }
      set {
        key_ = value;
        keyCase_ = value == null ? KeyOneofCase.None : KeyOneofCase.DelegatableContractId;
      }
    }

    private object key_;
    /// <summary>Enum of possible cases for the "key" oneof.</summary>
    public enum KeyOneofCase {
      None = 0,
      ContractID = 1,
      Ed25519 = 2,
      RSA3072 = 3,
      ECDSA384 = 4,
      ThresholdKey = 5,
      KeyList = 6,
      ECDSASecp256K1 = 7,
      DelegatableContractId = 8,
    }
    private KeyOneofCase keyCase_ = KeyOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public KeyOneofCase KeyCase {
      get { return keyCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearKey() {
      keyCase_ = KeyOneofCase.None;
      key_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Key);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Key other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(ContractID, other.ContractID)) return false;
      if (Ed25519 != other.Ed25519) return false;
      if (RSA3072 != other.RSA3072) return false;
      if (ECDSA384 != other.ECDSA384) return false;
      if (!object.Equals(ThresholdKey, other.ThresholdKey)) return false;
      if (!object.Equals(KeyList, other.KeyList)) return false;
      if (ECDSASecp256K1 != other.ECDSASecp256K1) return false;
      if (!object.Equals(DelegatableContractId, other.DelegatableContractId)) return false;
      if (KeyCase != other.KeyCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (keyCase_ == KeyOneofCase.ContractID) hash ^= ContractID.GetHashCode();
      if (HasEd25519) hash ^= Ed25519.GetHashCode();
      if (HasRSA3072) hash ^= RSA3072.GetHashCode();
      if (HasECDSA384) hash ^= ECDSA384.GetHashCode();
      if (keyCase_ == KeyOneofCase.ThresholdKey) hash ^= ThresholdKey.GetHashCode();
      if (keyCase_ == KeyOneofCase.KeyList) hash ^= KeyList.GetHashCode();
      if (HasECDSASecp256K1) hash ^= ECDSASecp256K1.GetHashCode();
      if (keyCase_ == KeyOneofCase.DelegatableContractId) hash ^= DelegatableContractId.GetHashCode();
      hash ^= (int) keyCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (keyCase_ == KeyOneofCase.ContractID) {
        output.WriteRawTag(10);
        output.WriteMessage(ContractID);
      }
      if (HasEd25519) {
        output.WriteRawTag(18);
        output.WriteBytes(Ed25519);
      }
      if (HasRSA3072) {
        output.WriteRawTag(26);
        output.WriteBytes(RSA3072);
      }
      if (HasECDSA384) {
        output.WriteRawTag(34);
        output.WriteBytes(ECDSA384);
      }
      if (keyCase_ == KeyOneofCase.ThresholdKey) {
        output.WriteRawTag(42);
        output.WriteMessage(ThresholdKey);
      }
      if (keyCase_ == KeyOneofCase.KeyList) {
        output.WriteRawTag(50);
        output.WriteMessage(KeyList);
      }
      if (HasECDSASecp256K1) {
        output.WriteRawTag(58);
        output.WriteBytes(ECDSASecp256K1);
      }
      if (keyCase_ == KeyOneofCase.DelegatableContractId) {
        output.WriteRawTag(66);
        output.WriteMessage(DelegatableContractId);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (keyCase_ == KeyOneofCase.ContractID) {
        output.WriteRawTag(10);
        output.WriteMessage(ContractID);
      }
      if (HasEd25519) {
        output.WriteRawTag(18);
        output.WriteBytes(Ed25519);
      }
      if (HasRSA3072) {
        output.WriteRawTag(26);
        output.WriteBytes(RSA3072);
      }
      if (HasECDSA384) {
        output.WriteRawTag(34);
        output.WriteBytes(ECDSA384);
      }
      if (keyCase_ == KeyOneofCase.ThresholdKey) {
        output.WriteRawTag(42);
        output.WriteMessage(ThresholdKey);
      }
      if (keyCase_ == KeyOneofCase.KeyList) {
        output.WriteRawTag(50);
        output.WriteMessage(KeyList);
      }
      if (HasECDSASecp256K1) {
        output.WriteRawTag(58);
        output.WriteBytes(ECDSASecp256K1);
      }
      if (keyCase_ == KeyOneofCase.DelegatableContractId) {
        output.WriteRawTag(66);
        output.WriteMessage(DelegatableContractId);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (keyCase_ == KeyOneofCase.ContractID) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ContractID);
      }
      if (HasEd25519) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Ed25519);
      }
      if (HasRSA3072) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(RSA3072);
      }
      if (HasECDSA384) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(ECDSA384);
      }
      if (keyCase_ == KeyOneofCase.ThresholdKey) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ThresholdKey);
      }
      if (keyCase_ == KeyOneofCase.KeyList) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(KeyList);
      }
      if (HasECDSASecp256K1) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(ECDSASecp256K1);
      }
      if (keyCase_ == KeyOneofCase.DelegatableContractId) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(DelegatableContractId);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Key other) {
      if (other == null) {
        return;
      }
      switch (other.KeyCase) {
        case KeyOneofCase.ContractID:
          if (ContractID == null) {
            ContractID = new global::Proto.ContractID();
          }
          ContractID.MergeFrom(other.ContractID);
          break;
        case KeyOneofCase.Ed25519:
          Ed25519 = other.Ed25519;
          break;
        case KeyOneofCase.RSA3072:
          RSA3072 = other.RSA3072;
          break;
        case KeyOneofCase.ECDSA384:
          ECDSA384 = other.ECDSA384;
          break;
        case KeyOneofCase.ThresholdKey:
          if (ThresholdKey == null) {
            ThresholdKey = new global::Proto.ThresholdKey();
          }
          ThresholdKey.MergeFrom(other.ThresholdKey);
          break;
        case KeyOneofCase.KeyList:
          if (KeyList == null) {
            KeyList = new global::Proto.KeyList();
          }
          KeyList.MergeFrom(other.KeyList);
          break;
        case KeyOneofCase.ECDSASecp256K1:
          ECDSASecp256K1 = other.ECDSASecp256K1;
          break;
        case KeyOneofCase.DelegatableContractId:
          if (DelegatableContractId == null) {
            DelegatableContractId = new global::Proto.ContractID();
          }
          DelegatableContractId.MergeFrom(other.DelegatableContractId);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            global::Proto.ContractID subBuilder = new global::Proto.ContractID();
            if (keyCase_ == KeyOneofCase.ContractID) {
              subBuilder.MergeFrom(ContractID);
            }
            input.ReadMessage(subBuilder);
            ContractID = subBuilder;
            break;
          }
          case 18: {
            Ed25519 = input.ReadBytes();
            break;
          }
          case 26: {
            RSA3072 = input.ReadBytes();
            break;
          }
          case 34: {
            ECDSA384 = input.ReadBytes();
            break;
          }
          case 42: {
            global::Proto.ThresholdKey subBuilder = new global::Proto.ThresholdKey();
            if (keyCase_ == KeyOneofCase.ThresholdKey) {
              subBuilder.MergeFrom(ThresholdKey);
            }
            input.ReadMessage(subBuilder);
            ThresholdKey = subBuilder;
            break;
          }
          case 50: {
            global::Proto.KeyList subBuilder = new global::Proto.KeyList();
            if (keyCase_ == KeyOneofCase.KeyList) {
              subBuilder.MergeFrom(KeyList);
            }
            input.ReadMessage(subBuilder);
            KeyList = subBuilder;
            break;
          }
          case 58: {
            ECDSASecp256K1 = input.ReadBytes();
            break;
          }
          case 66: {
            global::Proto.ContractID subBuilder = new global::Proto.ContractID();
            if (keyCase_ == KeyOneofCase.DelegatableContractId) {
              subBuilder.MergeFrom(DelegatableContractId);
            }
            input.ReadMessage(subBuilder);
            DelegatableContractId = subBuilder;
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            global::Proto.ContractID subBuilder = new global::Proto.ContractID();
            if (keyCase_ == KeyOneofCase.ContractID) {
              subBuilder.MergeFrom(ContractID);
            }
            input.ReadMessage(subBuilder);
            ContractID = subBuilder;
            break;
          }
          case 18: {
            Ed25519 = input.ReadBytes();
            break;
          }
          case 26: {
            RSA3072 = input.ReadBytes();
            break;
          }
          case 34: {
            ECDSA384 = input.ReadBytes();
            break;
          }
          case 42: {
            global::Proto.ThresholdKey subBuilder = new global::Proto.ThresholdKey();
            if (keyCase_ == KeyOneofCase.ThresholdKey) {
              subBuilder.MergeFrom(ThresholdKey);
            }
            input.ReadMessage(subBuilder);
            ThresholdKey = subBuilder;
            break;
          }
          case 50: {
            global::Proto.KeyList subBuilder = new global::Proto.KeyList();
            if (keyCase_ == KeyOneofCase.KeyList) {
              subBuilder.MergeFrom(KeyList);
            }
            input.ReadMessage(subBuilder);
            KeyList = subBuilder;
            break;
          }
          case 58: {
            ECDSASecp256K1 = input.ReadBytes();
            break;
          }
          case 66: {
            global::Proto.ContractID subBuilder = new global::Proto.ContractID();
            if (keyCase_ == KeyOneofCase.DelegatableContractId) {
              subBuilder.MergeFrom(DelegatableContractId);
            }
            input.ReadMessage(subBuilder);
            DelegatableContractId = subBuilder;
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// A threshold value and a list of public keys that, together, form a threshold
  /// signature requirement. Any subset of the keys in the list may satisfy the
  /// signature requirements of this type of key, provided the number of keys meets
  /// or exceeds the threshold. For example, if a particular key has a threshold of
  /// three(3) and eight(8) keys in the list, then any three(3) signatures, from
  /// the list of eight(8), is sufficient to authorize that key.
  ///
  /// For threshold purposes, all signatures from a single `primitive` key are
  /// considered a single signature, so that signature(s) from a single key SHALL
  /// NOT _directly_ meet a threshold greater than one(1).
  ///
  /// #### Note
  /// > It is possible to construct a complex key structure that _would_ enable a
  /// > single primitive key to successfully meet a threshold requirement. All
  /// > threshold keys SHOULD be carefully audited to ensure no one `primitive`
  /// > key, or smart contract, has disproportionate capability.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class ThresholdKey : pb::IMessage<ThresholdKey>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ThresholdKey> _parser = new pb::MessageParser<ThresholdKey>(() => new ThresholdKey());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ThresholdKey> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Proto.BasicTypesReflection.Descriptor.MessageTypes[20]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ThresholdKey() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ThresholdKey(ThresholdKey other) : this() {
      threshold_ = other.threshold_;
      keys_ = other.keys_ != null ? other.keys_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ThresholdKey Clone() {
      return new ThresholdKey(this);
    }

    /// <summary>Field number for the "threshold" field.</summary>
    public const int ThresholdFieldNumber = 1;
    private uint threshold_;
    /// <summary>
    ///*
    /// A transaction MUST have valid signatures from at least this number of
    /// separate keys, from the `keys` list to be authorized by this key.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint Threshold {
      get { return threshold_; }
      set {
        threshold_ = value;
      }
    }

    /// <summary>Field number for the "keys" field.</summary>
    public const int KeysFieldNumber = 2;
    private global::Proto.KeyList keys_;
    /// <summary>
    ///*
    /// A list of the keys that MAY satisfy signature requirements of this key.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.KeyList Keys {
      get { return keys_; }
      set {
        keys_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ThresholdKey);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ThresholdKey other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Threshold != other.Threshold) return false;
      if (!object.Equals(Keys, other.Keys)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Threshold != 0) hash ^= Threshold.GetHashCode();
      if (keys_ != null) hash ^= Keys.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Threshold != 0) {
        output.WriteRawTag(8);
        output.WriteUInt32(Threshold);
      }
      if (keys_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Keys);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Threshold != 0) {
        output.WriteRawTag(8);
        output.WriteUInt32(Threshold);
      }
      if (keys_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Keys);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Threshold != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Threshold);
      }
      if (keys_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Keys);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ThresholdKey other) {
      if (other == null) {
        return;
      }
      if (other.Threshold != 0) {
        Threshold = other.Threshold;
      }
      if (other.keys_ != null) {
        if (keys_ == null) {
          Keys = new global::Proto.KeyList();
        }
        Keys.MergeFrom(other.Keys);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Threshold = input.ReadUInt32();
            break;
          }
          case 18: {
            if (keys_ == null) {
              Keys = new global::Proto.KeyList();
            }
            input.ReadMessage(Keys);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Threshold = input.ReadUInt32();
            break;
          }
          case 18: {
            if (keys_ == null) {
              Keys = new global::Proto.KeyList();
            }
            input.ReadMessage(Keys);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// A list of keys.&lt;br/>
  /// A `KeyList` requires all keys (N-of-N) to sign, unless otherwise
  /// specified in official documentation. A KeyList may contain repeated keys,
  /// but all such repeated keys are considered a single key when determining
  /// signature authorization.
  ///
  /// ### Additional Notes
  /// 1. An empty key list is the "standard" mechanism to represent an
  ///    unassigned key. For example, if the `admin_key` of a token is set
  ///    to the empty key list, then that token has no admin key, and
  ///    functionality that requires an admin key to sign the
  ///    transaction is disabled.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class KeyList : pb::IMessage<KeyList>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<KeyList> _parser = new pb::MessageParser<KeyList>(() => new KeyList());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<KeyList> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Proto.BasicTypesReflection.Descriptor.MessageTypes[21]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public KeyList() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public KeyList(KeyList other) : this() {
      keys_ = other.keys_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public KeyList Clone() {
      return new KeyList(this);
    }

    /// <summary>Field number for the "keys" field.</summary>
    public const int KeysFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Proto.Key> _repeated_keys_codec
        = pb::FieldCodec.ForMessage(10, global::Proto.Key.Parser);
    private readonly pbc::RepeatedField<global::Proto.Key> keys_ = new pbc::RepeatedField<global::Proto.Key>();
    /// <summary>
    ///*
    /// A list of keys. All values in this list SHALL be non-null.
    /// &lt;p>
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Proto.Key> Keys {
      get { return keys_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as KeyList);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(KeyList other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!keys_.Equals(other.keys_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= keys_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      keys_.WriteTo(output, _repeated_keys_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      keys_.WriteTo(ref output, _repeated_keys_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += keys_.CalculateSize(_repeated_keys_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(KeyList other) {
      if (other == null) {
        return;
      }
      keys_.Add(other.keys_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            keys_.AddEntriesFrom(input, _repeated_keys_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            keys_.AddEntriesFrom(ref input, _repeated_keys_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// This message is deprecated and MUST NOT be used to communicate with
  /// network nodes. It is retained here only for historical reasons.
  ///
  /// Client software MUST NOT include this message in any request. &lt;br/>
  /// Compliant nodes SHALL NOT accept any request containing this message.
  ///
  /// Please use the `SignaturePair` and `SignatureMap` messages instead of
  /// this message.
  /// </summary>
  [global::System.ObsoleteAttribute]
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class Signature : pb::IMessage<Signature>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Signature> _parser = new pb::MessageParser<Signature>(() => new Signature());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Signature> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Proto.BasicTypesReflection.Descriptor.MessageTypes[22]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Signature() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Signature(Signature other) : this() {
      switch (other.SignatureCase) {
        case SignatureOneofCase.Contract:
          Contract = other.Contract;
          break;
        case SignatureOneofCase.Ed25519:
          Ed25519 = other.Ed25519;
          break;
        case SignatureOneofCase.RSA3072:
          RSA3072 = other.RSA3072;
          break;
        case SignatureOneofCase.ECDSA384:
          ECDSA384 = other.ECDSA384;
          break;
        case SignatureOneofCase.ThresholdSignature:
          ThresholdSignature = other.ThresholdSignature.Clone();
          break;
        case SignatureOneofCase.SignatureList:
          SignatureList = other.SignatureList.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Signature Clone() {
      return new Signature(this);
    }

    /// <summary>Field number for the "contract" field.</summary>
    public const int ContractFieldNumber = 1;
    /// <summary>
    ///*
    /// Smart contract virtual signature (always length zero).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString Contract {
      get { return HasContract ? (pb::ByteString) signature_ : pb::ByteString.Empty; }
      set {
        signature_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        signatureCase_ = SignatureOneofCase.Contract;
      }
    }
    /// <summary>Gets whether the "contract" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasContract {
      get { return signatureCase_ == SignatureOneofCase.Contract; }
    }
    /// <summary> Clears the value of the oneof if it's currently set to "contract" </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearContract() {
      if (HasContract) {
        ClearSignature();
      }
    }

    /// <summary>Field number for the "ed25519" field.</summary>
    public const int Ed25519FieldNumber = 2;
    /// <summary>
    ///*
    /// Ed25519 signature bytes.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString Ed25519 {
      get { return HasEd25519 ? (pb::ByteString) signature_ : pb::ByteString.Empty; }
      set {
        signature_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        signatureCase_ = SignatureOneofCase.Ed25519;
      }
    }
    /// <summary>Gets whether the "ed25519" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasEd25519 {
      get { return signatureCase_ == SignatureOneofCase.Ed25519; }
    }
    /// <summary> Clears the value of the oneof if it's currently set to "ed25519" </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearEd25519() {
      if (HasEd25519) {
        ClearSignature();
      }
    }

    /// <summary>Field number for the "RSA_3072" field.</summary>
    public const int RSA3072FieldNumber = 3;
    /// <summary>
    ///*
    /// RSA-3072 signature bytes.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString RSA3072 {
      get { return HasRSA3072 ? (pb::ByteString) signature_ : pb::ByteString.Empty; }
      set {
        signature_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        signatureCase_ = SignatureOneofCase.RSA3072;
      }
    }
    /// <summary>Gets whether the "RSA_3072" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasRSA3072 {
      get { return signatureCase_ == SignatureOneofCase.RSA3072; }
    }
    /// <summary> Clears the value of the oneof if it's currently set to "RSA_3072" </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearRSA3072() {
      if (HasRSA3072) {
        ClearSignature();
      }
    }

    /// <summary>Field number for the "ECDSA_384" field.</summary>
    public const int ECDSA384FieldNumber = 4;
    /// <summary>
    ///*
    /// ECDSA p-384 signature bytes.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString ECDSA384 {
      get { return HasECDSA384 ? (pb::ByteString) signature_ : pb::ByteString.Empty; }
      set {
        signature_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        signatureCase_ = SignatureOneofCase.ECDSA384;
      }
    }
    /// <summary>Gets whether the "ECDSA_384" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasECDSA384 {
      get { return signatureCase_ == SignatureOneofCase.ECDSA384; }
    }
    /// <summary> Clears the value of the oneof if it's currently set to "ECDSA_384" </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearECDSA384() {
      if (HasECDSA384) {
        ClearSignature();
      }
    }

    /// <summary>Field number for the "thresholdSignature" field.</summary>
    public const int ThresholdSignatureFieldNumber = 5;
    /// <summary>
    ///*
    /// A list of signatures for a single N-of-M threshold Key. This must be
    /// a list of exactly M signatures, at least N of which are non-null.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.ThresholdSignature ThresholdSignature {
      get { return signatureCase_ == SignatureOneofCase.ThresholdSignature ? (global::Proto.ThresholdSignature) signature_ : null; }
      set {
        signature_ = value;
        signatureCase_ = value == null ? SignatureOneofCase.None : SignatureOneofCase.ThresholdSignature;
      }
    }

    /// <summary>Field number for the "signatureList" field.</summary>
    public const int SignatureListFieldNumber = 6;
    /// <summary>
    ///*
    /// A list of M signatures, each corresponding to a Key in a KeyList
    /// of the same length.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.SignatureList SignatureList {
      get { return signatureCase_ == SignatureOneofCase.SignatureList ? (global::Proto.SignatureList) signature_ : null; }
      set {
        signature_ = value;
        signatureCase_ = value == null ? SignatureOneofCase.None : SignatureOneofCase.SignatureList;
      }
    }

    private object signature_;
    /// <summary>Enum of possible cases for the "signature" oneof.</summary>
    public enum SignatureOneofCase {
      None = 0,
      Contract = 1,
      Ed25519 = 2,
      RSA3072 = 3,
      ECDSA384 = 4,
      ThresholdSignature = 5,
      SignatureList = 6,
    }
    private SignatureOneofCase signatureCase_ = SignatureOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SignatureOneofCase SignatureCase {
      get { return signatureCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSignature() {
      signatureCase_ = SignatureOneofCase.None;
      signature_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Signature);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Signature other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Contract != other.Contract) return false;
      if (Ed25519 != other.Ed25519) return false;
      if (RSA3072 != other.RSA3072) return false;
      if (ECDSA384 != other.ECDSA384) return false;
      if (!object.Equals(ThresholdSignature, other.ThresholdSignature)) return false;
      if (!object.Equals(SignatureList, other.SignatureList)) return false;
      if (SignatureCase != other.SignatureCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasContract) hash ^= Contract.GetHashCode();
      if (HasEd25519) hash ^= Ed25519.GetHashCode();
      if (HasRSA3072) hash ^= RSA3072.GetHashCode();
      if (HasECDSA384) hash ^= ECDSA384.GetHashCode();
      if (signatureCase_ == SignatureOneofCase.ThresholdSignature) hash ^= ThresholdSignature.GetHashCode();
      if (signatureCase_ == SignatureOneofCase.SignatureList) hash ^= SignatureList.GetHashCode();
      hash ^= (int) signatureCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasContract) {
        output.WriteRawTag(10);
        output.WriteBytes(Contract);
      }
      if (HasEd25519) {
        output.WriteRawTag(18);
        output.WriteBytes(Ed25519);
      }
      if (HasRSA3072) {
        output.WriteRawTag(26);
        output.WriteBytes(RSA3072);
      }
      if (HasECDSA384) {
        output.WriteRawTag(34);
        output.WriteBytes(ECDSA384);
      }
      if (signatureCase_ == SignatureOneofCase.ThresholdSignature) {
        output.WriteRawTag(42);
        output.WriteMessage(ThresholdSignature);
      }
      if (signatureCase_ == SignatureOneofCase.SignatureList) {
        output.WriteRawTag(50);
        output.WriteMessage(SignatureList);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasContract) {
        output.WriteRawTag(10);
        output.WriteBytes(Contract);
      }
      if (HasEd25519) {
        output.WriteRawTag(18);
        output.WriteBytes(Ed25519);
      }
      if (HasRSA3072) {
        output.WriteRawTag(26);
        output.WriteBytes(RSA3072);
      }
      if (HasECDSA384) {
        output.WriteRawTag(34);
        output.WriteBytes(ECDSA384);
      }
      if (signatureCase_ == SignatureOneofCase.ThresholdSignature) {
        output.WriteRawTag(42);
        output.WriteMessage(ThresholdSignature);
      }
      if (signatureCase_ == SignatureOneofCase.SignatureList) {
        output.WriteRawTag(50);
        output.WriteMessage(SignatureList);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasContract) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Contract);
      }
      if (HasEd25519) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Ed25519);
      }
      if (HasRSA3072) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(RSA3072);
      }
      if (HasECDSA384) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(ECDSA384);
      }
      if (signatureCase_ == SignatureOneofCase.ThresholdSignature) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ThresholdSignature);
      }
      if (signatureCase_ == SignatureOneofCase.SignatureList) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SignatureList);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Signature other) {
      if (other == null) {
        return;
      }
      switch (other.SignatureCase) {
        case SignatureOneofCase.Contract:
          Contract = other.Contract;
          break;
        case SignatureOneofCase.Ed25519:
          Ed25519 = other.Ed25519;
          break;
        case SignatureOneofCase.RSA3072:
          RSA3072 = other.RSA3072;
          break;
        case SignatureOneofCase.ECDSA384:
          ECDSA384 = other.ECDSA384;
          break;
        case SignatureOneofCase.ThresholdSignature:
          if (ThresholdSignature == null) {
            ThresholdSignature = new global::Proto.ThresholdSignature();
          }
          ThresholdSignature.MergeFrom(other.ThresholdSignature);
          break;
        case SignatureOneofCase.SignatureList:
          if (SignatureList == null) {
            SignatureList = new global::Proto.SignatureList();
          }
          SignatureList.MergeFrom(other.SignatureList);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Contract = input.ReadBytes();
            break;
          }
          case 18: {
            Ed25519 = input.ReadBytes();
            break;
          }
          case 26: {
            RSA3072 = input.ReadBytes();
            break;
          }
          case 34: {
            ECDSA384 = input.ReadBytes();
            break;
          }
          case 42: {
            global::Proto.ThresholdSignature subBuilder = new global::Proto.ThresholdSignature();
            if (signatureCase_ == SignatureOneofCase.ThresholdSignature) {
              subBuilder.MergeFrom(ThresholdSignature);
            }
            input.ReadMessage(subBuilder);
            ThresholdSignature = subBuilder;
            break;
          }
          case 50: {
            global::Proto.SignatureList subBuilder = new global::Proto.SignatureList();
            if (signatureCase_ == SignatureOneofCase.SignatureList) {
              subBuilder.MergeFrom(SignatureList);
            }
            input.ReadMessage(subBuilder);
            SignatureList = subBuilder;
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Contract = input.ReadBytes();
            break;
          }
          case 18: {
            Ed25519 = input.ReadBytes();
            break;
          }
          case 26: {
            RSA3072 = input.ReadBytes();
            break;
          }
          case 34: {
            ECDSA384 = input.ReadBytes();
            break;
          }
          case 42: {
            global::Proto.ThresholdSignature subBuilder = new global::Proto.ThresholdSignature();
            if (signatureCase_ == SignatureOneofCase.ThresholdSignature) {
              subBuilder.MergeFrom(ThresholdSignature);
            }
            input.ReadMessage(subBuilder);
            ThresholdSignature = subBuilder;
            break;
          }
          case 50: {
            global::Proto.SignatureList subBuilder = new global::Proto.SignatureList();
            if (signatureCase_ == SignatureOneofCase.SignatureList) {
              subBuilder.MergeFrom(SignatureList);
            }
            input.ReadMessage(subBuilder);
            SignatureList = subBuilder;
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// This message is deprecated and MUST NOT be used to communicate with network
  /// nodes. It is retained here only for historical reasons.
  ///
  /// Client software MUST NOT include this message in any request. &lt;br/>
  /// Compliant nodes SHALL NOT accept any request containing this message.
  ///
  /// Please use the `SignaturePair` and `SignatureMap` messages, in combination
  /// with `ThresholdKey` keys, instead of this message.
  /// </summary>
  [global::System.ObsoleteAttribute]
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class ThresholdSignature : pb::IMessage<ThresholdSignature>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ThresholdSignature> _parser = new pb::MessageParser<ThresholdSignature>(() => new ThresholdSignature());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ThresholdSignature> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Proto.BasicTypesReflection.Descriptor.MessageTypes[23]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ThresholdSignature() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ThresholdSignature(ThresholdSignature other) : this() {
      sigs_ = other.sigs_ != null ? other.sigs_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ThresholdSignature Clone() {
      return new ThresholdSignature(this);
    }

    /// <summary>Field number for the "sigs" field.</summary>
    public const int SigsFieldNumber = 2;
    private global::Proto.SignatureList sigs_;
    /// <summary>
    ///*
    /// For an N-of-M threshold key, this is a list of M signatures, at least N
    /// of which must be non-null.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.SignatureList Sigs {
      get { return sigs_; }
      set {
        sigs_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ThresholdSignature);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ThresholdSignature other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Sigs, other.Sigs)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (sigs_ != null) hash ^= Sigs.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (sigs_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Sigs);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (sigs_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Sigs);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (sigs_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Sigs);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ThresholdSignature other) {
      if (other == null) {
        return;
      }
      if (other.sigs_ != null) {
        if (sigs_ == null) {
          Sigs = new global::Proto.SignatureList();
        }
        Sigs.MergeFrom(other.Sigs);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 18: {
            if (sigs_ == null) {
              Sigs = new global::Proto.SignatureList();
            }
            input.ReadMessage(Sigs);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 18: {
            if (sigs_ == null) {
              Sigs = new global::Proto.SignatureList();
            }
            input.ReadMessage(Sigs);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// This message is deprecated and MUST NOT be used to communicate with network
  /// nodes. It is retained here only for historical reasons.
  ///
  /// Client software MUST NOT include this message in any request. &lt;br/>
  /// Compliant nodes SHALL NOT accept any request containing this message.
  ///
  /// Please use the `SignaturePair` and `SignatureMap` messages instead of
  /// this message.
  /// </summary>
  [global::System.ObsoleteAttribute]
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class SignatureList : pb::IMessage<SignatureList>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<SignatureList> _parser = new pb::MessageParser<SignatureList>(() => new SignatureList());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<SignatureList> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Proto.BasicTypesReflection.Descriptor.MessageTypes[24]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SignatureList() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SignatureList(SignatureList other) : this() {
      sigs_ = other.sigs_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SignatureList Clone() {
      return new SignatureList(this);
    }

    /// <summary>Field number for the "sigs" field.</summary>
    public const int SigsFieldNumber = 2;
    private static readonly pb::FieldCodec<global::Proto.Signature> _repeated_sigs_codec
        = pb::FieldCodec.ForMessage(18, global::Proto.Signature.Parser);
    private readonly pbc::RepeatedField<global::Proto.Signature> sigs_ = new pbc::RepeatedField<global::Proto.Signature>();
    /// <summary>
    ///*
    /// Each signature corresponds to a Key in the KeyList.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Proto.Signature> Sigs {
      get { return sigs_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as SignatureList);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(SignatureList other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!sigs_.Equals(other.sigs_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= sigs_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      sigs_.WriteTo(output, _repeated_sigs_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      sigs_.WriteTo(ref output, _repeated_sigs_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += sigs_.CalculateSize(_repeated_sigs_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(SignatureList other) {
      if (other == null) {
        return;
      }
      sigs_.Add(other.sigs_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 18: {
            sigs_.AddEntriesFrom(input, _repeated_sigs_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 18: {
            sigs_.AddEntriesFrom(ref input, _repeated_sigs_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// A public key and signature pair.&lt;br/>
  /// Only Ed25519 and ECDSA(secp256k1) keys and signatures are currently supported
  /// as cryptographic (non-implied) signatures.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class SignaturePair : pb::IMessage<SignaturePair>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<SignaturePair> _parser = new pb::MessageParser<SignaturePair>(() => new SignaturePair());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<SignaturePair> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Proto.BasicTypesReflection.Descriptor.MessageTypes[25]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SignaturePair() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SignaturePair(SignaturePair other) : this() {
      pubKeyPrefix_ = other.pubKeyPrefix_;
      switch (other.SignatureCase) {
        case SignatureOneofCase.Contract:
          Contract = other.Contract;
          break;
        case SignatureOneofCase.Ed25519:
          Ed25519 = other.Ed25519;
          break;
        case SignatureOneofCase.RSA3072:
          RSA3072 = other.RSA3072;
          break;
        case SignatureOneofCase.ECDSA384:
          ECDSA384 = other.ECDSA384;
          break;
        case SignatureOneofCase.ECDSASecp256K1:
          ECDSASecp256K1 = other.ECDSASecp256K1;
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SignaturePair Clone() {
      return new SignaturePair(this);
    }

    /// <summary>Field number for the "pubKeyPrefix" field.</summary>
    public const int PubKeyPrefixFieldNumber = 1;
    private pb::ByteString pubKeyPrefix_ = pb::ByteString.Empty;
    /// <summary>
    ///*
    /// Prefix bytes of the public key.
    /// &lt;p>
    /// The client may use any number of bytes from zero to the whole length of
    /// the public key for pubKeyPrefix. If zero bytes are used, then it MUST be
    /// true that only one cryptographic key is required to sign the associated
    /// transaction.&lt;br/>
    /// If the `pubKeyPrefix` is 0 bytes and more than a single cryptographic
    /// key is required to sign the transaction, the request SHALL resolve to
    /// `INVALID_SIGNATURE`.
    /// &lt;blockquote>Important Note&lt;blockquote>
    /// In the special case that a signature is provided to authorize a
    /// precompiled contract, the `pubKeyPrefix` MUST contain the _entire public
    /// key_.&lt;br/>
    /// That is, if the key is an Ed25519 key, the `pubKeyPrefix` MUST be
    /// 32 bytes long and contain the full public key bytes.&lt;br/>
    /// If the key is an ECDSA(secp256k1) key, the `pubKeyPrefix` MUST be
    /// 33 bytes long and contain the full _compressed_ form of the public key.
    /// &lt;/blockquote>&lt;/blockquote>
    /// &lt;p>
    /// &lt;dl>&lt;dt>Purpose&lt;/dt>
    /// &lt;dd>The `pubKeyPrefix` exists to save cost. A signed transaction with
    /// shorter prefixes will have fewer bytes, and so will have a lower
    /// transaction fee.
    /// The prefixes, however, MUST be long enough to distinguish between all
    /// of the public keys that might be signing the transaction. Therefore,
    /// software signing a transaction SHOULD evaluate which keys might possibly
    /// be required to sign a transaction, and ensure that the shortest prefix
    /// that is sufficient to unambiguously identify the correct key is used.
    /// &lt;/dd>&lt;/dl>
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString PubKeyPrefix {
      get { return pubKeyPrefix_; }
      set {
        pubKeyPrefix_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "contract" field.</summary>
    public const int ContractFieldNumber = 2;
    /// <summary>
    ///*
    /// A smart contract virtual signature.
    /// &lt;p>
    /// This value MUST be length zero, if set.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString Contract {
      get { return HasContract ? (pb::ByteString) signature_ : pb::ByteString.Empty; }
      set {
        signature_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        signatureCase_ = SignatureOneofCase.Contract;
      }
    }
    /// <summary>Gets whether the "contract" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasContract {
      get { return signatureCase_ == SignatureOneofCase.Contract; }
    }
    /// <summary> Clears the value of the oneof if it's currently set to "contract" </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearContract() {
      if (HasContract) {
        ClearSignature();
      }
    }

    /// <summary>Field number for the "ed25519" field.</summary>
    public const int Ed25519FieldNumber = 3;
    /// <summary>
    ///*
    /// An Ed25519 signature.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString Ed25519 {
      get { return HasEd25519 ? (pb::ByteString) signature_ : pb::ByteString.Empty; }
      set {
        signature_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        signatureCase_ = SignatureOneofCase.Ed25519;
      }
    }
    /// <summary>Gets whether the "ed25519" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasEd25519 {
      get { return signatureCase_ == SignatureOneofCase.Ed25519; }
    }
    /// <summary> Clears the value of the oneof if it's currently set to "ed25519" </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearEd25519() {
      if (HasEd25519) {
        ClearSignature();
      }
    }

    /// <summary>Field number for the "RSA_3072" field.</summary>
    public const int RSA3072FieldNumber = 4;
    /// <summary>
    ///*
    /// This option is not supported.&lt;br/>
    /// A RSA-3072 signature.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString RSA3072 {
      get { return HasRSA3072 ? (pb::ByteString) signature_ : pb::ByteString.Empty; }
      set {
        signature_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        signatureCase_ = SignatureOneofCase.RSA3072;
      }
    }
    /// <summary>Gets whether the "RSA_3072" field is set</summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasRSA3072 {
      get { return signatureCase_ == SignatureOneofCase.RSA3072; }
    }
    /// <summary> Clears the value of the oneof if it's currently set to "RSA_3072" </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearRSA3072() {
      if (HasRSA3072) {
        ClearSignature();
      }
    }

    /// <summary>Field number for the "ECDSA_384" field.</summary>
    public const int ECDSA384FieldNumber = 5;
    /// <summary>
    ///*
    /// This option is not supported.&lt;br/>
    /// ECDSA p-384 signature.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString ECDSA384 {
      get { return HasECDSA384 ? (pb::ByteString) signature_ : pb::ByteString.Empty; }
      set {
        signature_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        signatureCase_ = SignatureOneofCase.ECDSA384;
      }
    }
    /// <summary>Gets whether the "ECDSA_384" field is set</summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasECDSA384 {
      get { return signatureCase_ == SignatureOneofCase.ECDSA384; }
    }
    /// <summary> Clears the value of the oneof if it's currently set to "ECDSA_384" </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearECDSA384() {
      if (HasECDSA384) {
        ClearSignature();
      }
    }

    /// <summary>Field number for the "ECDSA_secp256k1" field.</summary>
    public const int ECDSASecp256K1FieldNumber = 6;
    /// <summary>
    ///*
    /// An ECDSA(secp256k1) signature.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString ECDSASecp256K1 {
      get { return HasECDSASecp256K1 ? (pb::ByteString) signature_ : pb::ByteString.Empty; }
      set {
        signature_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        signatureCase_ = SignatureOneofCase.ECDSASecp256K1;
      }
    }
    /// <summary>Gets whether the "ECDSA_secp256k1" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasECDSASecp256K1 {
      get { return signatureCase_ == SignatureOneofCase.ECDSASecp256K1; }
    }
    /// <summary> Clears the value of the oneof if it's currently set to "ECDSA_secp256k1" </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearECDSASecp256K1() {
      if (HasECDSASecp256K1) {
        ClearSignature();
      }
    }

    private object signature_;
    /// <summary>Enum of possible cases for the "signature" oneof.</summary>
    public enum SignatureOneofCase {
      None = 0,
      Contract = 2,
      Ed25519 = 3,
      RSA3072 = 4,
      ECDSA384 = 5,
      ECDSASecp256K1 = 6,
    }
    private SignatureOneofCase signatureCase_ = SignatureOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SignatureOneofCase SignatureCase {
      get { return signatureCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSignature() {
      signatureCase_ = SignatureOneofCase.None;
      signature_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as SignaturePair);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(SignaturePair other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (PubKeyPrefix != other.PubKeyPrefix) return false;
      if (Contract != other.Contract) return false;
      if (Ed25519 != other.Ed25519) return false;
      if (RSA3072 != other.RSA3072) return false;
      if (ECDSA384 != other.ECDSA384) return false;
      if (ECDSASecp256K1 != other.ECDSASecp256K1) return false;
      if (SignatureCase != other.SignatureCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (PubKeyPrefix.Length != 0) hash ^= PubKeyPrefix.GetHashCode();
      if (HasContract) hash ^= Contract.GetHashCode();
      if (HasEd25519) hash ^= Ed25519.GetHashCode();
      if (HasRSA3072) hash ^= RSA3072.GetHashCode();
      if (HasECDSA384) hash ^= ECDSA384.GetHashCode();
      if (HasECDSASecp256K1) hash ^= ECDSASecp256K1.GetHashCode();
      hash ^= (int) signatureCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (PubKeyPrefix.Length != 0) {
        output.WriteRawTag(10);
        output.WriteBytes(PubKeyPrefix);
      }
      if (HasContract) {
        output.WriteRawTag(18);
        output.WriteBytes(Contract);
      }
      if (HasEd25519) {
        output.WriteRawTag(26);
        output.WriteBytes(Ed25519);
      }
      if (HasRSA3072) {
        output.WriteRawTag(34);
        output.WriteBytes(RSA3072);
      }
      if (HasECDSA384) {
        output.WriteRawTag(42);
        output.WriteBytes(ECDSA384);
      }
      if (HasECDSASecp256K1) {
        output.WriteRawTag(50);
        output.WriteBytes(ECDSASecp256K1);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (PubKeyPrefix.Length != 0) {
        output.WriteRawTag(10);
        output.WriteBytes(PubKeyPrefix);
      }
      if (HasContract) {
        output.WriteRawTag(18);
        output.WriteBytes(Contract);
      }
      if (HasEd25519) {
        output.WriteRawTag(26);
        output.WriteBytes(Ed25519);
      }
      if (HasRSA3072) {
        output.WriteRawTag(34);
        output.WriteBytes(RSA3072);
      }
      if (HasECDSA384) {
        output.WriteRawTag(42);
        output.WriteBytes(ECDSA384);
      }
      if (HasECDSASecp256K1) {
        output.WriteRawTag(50);
        output.WriteBytes(ECDSASecp256K1);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (PubKeyPrefix.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(PubKeyPrefix);
      }
      if (HasContract) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Contract);
      }
      if (HasEd25519) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Ed25519);
      }
      if (HasRSA3072) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(RSA3072);
      }
      if (HasECDSA384) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(ECDSA384);
      }
      if (HasECDSASecp256K1) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(ECDSASecp256K1);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(SignaturePair other) {
      if (other == null) {
        return;
      }
      if (other.PubKeyPrefix.Length != 0) {
        PubKeyPrefix = other.PubKeyPrefix;
      }
      switch (other.SignatureCase) {
        case SignatureOneofCase.Contract:
          Contract = other.Contract;
          break;
        case SignatureOneofCase.Ed25519:
          Ed25519 = other.Ed25519;
          break;
        case SignatureOneofCase.RSA3072:
          RSA3072 = other.RSA3072;
          break;
        case SignatureOneofCase.ECDSA384:
          ECDSA384 = other.ECDSA384;
          break;
        case SignatureOneofCase.ECDSASecp256K1:
          ECDSASecp256K1 = other.ECDSASecp256K1;
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            PubKeyPrefix = input.ReadBytes();
            break;
          }
          case 18: {
            Contract = input.ReadBytes();
            break;
          }
          case 26: {
            Ed25519 = input.ReadBytes();
            break;
          }
          case 34: {
            RSA3072 = input.ReadBytes();
            break;
          }
          case 42: {
            ECDSA384 = input.ReadBytes();
            break;
          }
          case 50: {
            ECDSASecp256K1 = input.ReadBytes();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            PubKeyPrefix = input.ReadBytes();
            break;
          }
          case 18: {
            Contract = input.ReadBytes();
            break;
          }
          case 26: {
            Ed25519 = input.ReadBytes();
            break;
          }
          case 34: {
            RSA3072 = input.ReadBytes();
            break;
          }
          case 42: {
            ECDSA384 = input.ReadBytes();
            break;
          }
          case 50: {
            ECDSASecp256K1 = input.ReadBytes();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// A set of signatures corresponding to every unique public key that
  /// signed a given transaction.
  ///
  /// If any public key matches more than one prefix in the signature map,
  /// the transaction containing that map SHALL fail immediately with the
  /// response code `KEY_PREFIX_MISMATCH`.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class SignatureMap : pb::IMessage<SignatureMap>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<SignatureMap> _parser = new pb::MessageParser<SignatureMap>(() => new SignatureMap());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<SignatureMap> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Proto.BasicTypesReflection.Descriptor.MessageTypes[26]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SignatureMap() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SignatureMap(SignatureMap other) : this() {
      sigPair_ = other.sigPair_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SignatureMap Clone() {
      return new SignatureMap(this);
    }

    /// <summary>Field number for the "sigPair" field.</summary>
    public const int SigPairFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Proto.SignaturePair> _repeated_sigPair_codec
        = pb::FieldCodec.ForMessage(10, global::Proto.SignaturePair.Parser);
    private readonly pbc::RepeatedField<global::Proto.SignaturePair> sigPair_ = new pbc::RepeatedField<global::Proto.SignaturePair>();
    /// <summary>
    ///*
    /// A list of signature pairs for a specific transaction.&lt;br/>
    /// Each signature pair represents a single cryptographic (`primitive`)
    /// public key identified by a "prefix" value and the cryptographic
    /// signature produced for that key.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Proto.SignaturePair> SigPair {
      get { return sigPair_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as SignatureMap);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(SignatureMap other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!sigPair_.Equals(other.sigPair_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= sigPair_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      sigPair_.WriteTo(output, _repeated_sigPair_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      sigPair_.WriteTo(ref output, _repeated_sigPair_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += sigPair_.CalculateSize(_repeated_sigPair_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(SignatureMap other) {
      if (other == null) {
        return;
      }
      sigPair_.Add(other.sigPair_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            sigPair_.AddEntriesFrom(input, _repeated_sigPair_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            sigPair_.AddEntriesFrom(ref input, _repeated_sigPair_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// A set of values the nodes use in determining transaction and query fees, and
  /// constants involved in fee calculations.
  ///
  /// Nodes SHALL multiply the amount of "resources" allocated to a transaction or
  /// query by the corresponding price to calculate the appropriate fee. Units are
  /// one-thousandth of a `tinyCent`. The "resource" allocations SHALL be estimated
  /// based on transaction characteristics and current network state, and MAY be
  /// further adjusted based on network load and congestion.
  ///
  /// This SHALL be used, in different contexts, for the cost _factors_ used to
  /// calculate charged amounts, for the resource accumulation, and for actual
  /// amounts to be charged.&lt;br/>
  /// Amounts recorded here MUST be converted to tinybar according to the
  /// current active `ExchangeRate` for the network.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class FeeComponents : pb::IMessage<FeeComponents>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<FeeComponents> _parser = new pb::MessageParser<FeeComponents>(() => new FeeComponents());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<FeeComponents> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Proto.BasicTypesReflection.Descriptor.MessageTypes[27]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public FeeComponents() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public FeeComponents(FeeComponents other) : this() {
      min_ = other.min_;
      max_ = other.max_;
      constant_ = other.constant_;
      bpt_ = other.bpt_;
      vpt_ = other.vpt_;
      rbh_ = other.rbh_;
      sbh_ = other.sbh_;
      gas_ = other.gas_;
      tv_ = other.tv_;
      bpr_ = other.bpr_;
      sbpr_ = other.sbpr_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public FeeComponents Clone() {
      return new FeeComponents(this);
    }

    /// <summary>Field number for the "min" field.</summary>
    public const int MinFieldNumber = 1;
    private long min_;
    /// <summary>
    ///*
    /// Base: "minimum total fee".
    /// &lt;p>
    /// The calculated fee MUST be greater than this value.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long Min {
      get { return min_; }
      set {
        min_ = value;
      }
    }

    /// <summary>Field number for the "max" field.</summary>
    public const int MaxFieldNumber = 2;
    private long max_;
    /// <summary>
    ///*
    /// Base: "maximum total fee".
    /// &lt;p>
    /// The calculated fee MUST be less than this value.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long Max {
      get { return max_; }
      set {
        max_ = value;
      }
    }

    /// <summary>Field number for the "constant" field.</summary>
    public const int ConstantFieldNumber = 3;
    private long constant_;
    /// <summary>
    ///*
    /// Base: "constant fee".&lt;br/>
    /// A baseline constant contribution to total fee.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long Constant {
      get { return constant_; }
      set {
        constant_ = value;
      }
    }

    /// <summary>Field number for the "bpt" field.</summary>
    public const int BptFieldNumber = 4;
    private long bpt_;
    /// <summary>
    ///*
    /// Bandwidth: "bytes per transaction".&lt;br/>
    /// The fee for bandwidth consumed by a transaction, measured in bytes
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long Bpt {
      get { return bpt_; }
      set {
        bpt_ = value;
      }
    }

    /// <summary>Field number for the "vpt" field.</summary>
    public const int VptFieldNumber = 5;
    private long vpt_;
    /// <summary>
    ///*
    /// Signatures: "validations per transaction".&lt;br/>
    /// The fee for signature verifications required by a transaction
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long Vpt {
      get { return vpt_; }
      set {
        vpt_ = value;
      }
    }

    /// <summary>Field number for the "rbh" field.</summary>
    public const int RbhFieldNumber = 6;
    private long rbh_;
    /// <summary>
    ///*
    /// Memory: "RAM byte-hours".&lt;br/>
    /// The fee for RAM required to process a transaction,
    /// measured in byte-hours
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long Rbh {
      get { return rbh_; }
      set {
        rbh_ = value;
      }
    }

    /// <summary>Field number for the "sbh" field.</summary>
    public const int SbhFieldNumber = 7;
    private long sbh_;
    /// <summary>
    ///*
    /// Disk: "storage byte-hours".&lt;br/>
    /// The fee for storage required by a transaction, measured in byte-hours
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long Sbh {
      get { return sbh_; }
      set {
        sbh_ = value;
      }
    }

    /// <summary>Field number for the "gas" field.</summary>
    public const int GasFieldNumber = 8;
    private long gas_;
    /// <summary>
    ///*
    /// Compute: Ethereum term for a derivative EVM compute resource.&lt;br/>
    /// The fee of computation for a smart contract transaction. The value of
    /// gas is set by a conversion rate, and is regularly updated to reflect
    /// reasonable and customary costs.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long Gas {
      get { return gas_; }
      set {
        gas_ = value;
      }
    }

    /// <summary>Field number for the "tv" field.</summary>
    public const int TvFieldNumber = 9;
    private long tv_;
    /// <summary>
    ///*
    /// Ad valorem: "transferred value".&lt;br/>
    /// The fee for HBAR transferred by a transaction.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long Tv {
      get { return tv_; }
      set {
        tv_ = value;
      }
    }

    /// <summary>Field number for the "bpr" field.</summary>
    public const int BprFieldNumber = 10;
    private long bpr_;
    /// <summary>
    ///*
    /// Response memory: "bytes per response".&lt;br/>
    /// The fee for data retrieved from memory to deliver a response,
    /// measured in bytes
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long Bpr {
      get { return bpr_; }
      set {
        bpr_ = value;
      }
    }

    /// <summary>Field number for the "sbpr" field.</summary>
    public const int SbprFieldNumber = 11;
    private long sbpr_;
    /// <summary>
    ///*
    /// Response disk: "storage bytes per response".&lt;br/>
    /// The fee for data retrieved from disk to deliver a response,
    /// measured in bytes
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long Sbpr {
      get { return sbpr_; }
      set {
        sbpr_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as FeeComponents);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(FeeComponents other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Min != other.Min) return false;
      if (Max != other.Max) return false;
      if (Constant != other.Constant) return false;
      if (Bpt != other.Bpt) return false;
      if (Vpt != other.Vpt) return false;
      if (Rbh != other.Rbh) return false;
      if (Sbh != other.Sbh) return false;
      if (Gas != other.Gas) return false;
      if (Tv != other.Tv) return false;
      if (Bpr != other.Bpr) return false;
      if (Sbpr != other.Sbpr) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Min != 0L) hash ^= Min.GetHashCode();
      if (Max != 0L) hash ^= Max.GetHashCode();
      if (Constant != 0L) hash ^= Constant.GetHashCode();
      if (Bpt != 0L) hash ^= Bpt.GetHashCode();
      if (Vpt != 0L) hash ^= Vpt.GetHashCode();
      if (Rbh != 0L) hash ^= Rbh.GetHashCode();
      if (Sbh != 0L) hash ^= Sbh.GetHashCode();
      if (Gas != 0L) hash ^= Gas.GetHashCode();
      if (Tv != 0L) hash ^= Tv.GetHashCode();
      if (Bpr != 0L) hash ^= Bpr.GetHashCode();
      if (Sbpr != 0L) hash ^= Sbpr.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Min != 0L) {
        output.WriteRawTag(8);
        output.WriteInt64(Min);
      }
      if (Max != 0L) {
        output.WriteRawTag(16);
        output.WriteInt64(Max);
      }
      if (Constant != 0L) {
        output.WriteRawTag(24);
        output.WriteInt64(Constant);
      }
      if (Bpt != 0L) {
        output.WriteRawTag(32);
        output.WriteInt64(Bpt);
      }
      if (Vpt != 0L) {
        output.WriteRawTag(40);
        output.WriteInt64(Vpt);
      }
      if (Rbh != 0L) {
        output.WriteRawTag(48);
        output.WriteInt64(Rbh);
      }
      if (Sbh != 0L) {
        output.WriteRawTag(56);
        output.WriteInt64(Sbh);
      }
      if (Gas != 0L) {
        output.WriteRawTag(64);
        output.WriteInt64(Gas);
      }
      if (Tv != 0L) {
        output.WriteRawTag(72);
        output.WriteInt64(Tv);
      }
      if (Bpr != 0L) {
        output.WriteRawTag(80);
        output.WriteInt64(Bpr);
      }
      if (Sbpr != 0L) {
        output.WriteRawTag(88);
        output.WriteInt64(Sbpr);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Min != 0L) {
        output.WriteRawTag(8);
        output.WriteInt64(Min);
      }
      if (Max != 0L) {
        output.WriteRawTag(16);
        output.WriteInt64(Max);
      }
      if (Constant != 0L) {
        output.WriteRawTag(24);
        output.WriteInt64(Constant);
      }
      if (Bpt != 0L) {
        output.WriteRawTag(32);
        output.WriteInt64(Bpt);
      }
      if (Vpt != 0L) {
        output.WriteRawTag(40);
        output.WriteInt64(Vpt);
      }
      if (Rbh != 0L) {
        output.WriteRawTag(48);
        output.WriteInt64(Rbh);
      }
      if (Sbh != 0L) {
        output.WriteRawTag(56);
        output.WriteInt64(Sbh);
      }
      if (Gas != 0L) {
        output.WriteRawTag(64);
        output.WriteInt64(Gas);
      }
      if (Tv != 0L) {
        output.WriteRawTag(72);
        output.WriteInt64(Tv);
      }
      if (Bpr != 0L) {
        output.WriteRawTag(80);
        output.WriteInt64(Bpr);
      }
      if (Sbpr != 0L) {
        output.WriteRawTag(88);
        output.WriteInt64(Sbpr);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Min != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(Min);
      }
      if (Max != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(Max);
      }
      if (Constant != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(Constant);
      }
      if (Bpt != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(Bpt);
      }
      if (Vpt != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(Vpt);
      }
      if (Rbh != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(Rbh);
      }
      if (Sbh != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(Sbh);
      }
      if (Gas != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(Gas);
      }
      if (Tv != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(Tv);
      }
      if (Bpr != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(Bpr);
      }
      if (Sbpr != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(Sbpr);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(FeeComponents other) {
      if (other == null) {
        return;
      }
      if (other.Min != 0L) {
        Min = other.Min;
      }
      if (other.Max != 0L) {
        Max = other.Max;
      }
      if (other.Constant != 0L) {
        Constant = other.Constant;
      }
      if (other.Bpt != 0L) {
        Bpt = other.Bpt;
      }
      if (other.Vpt != 0L) {
        Vpt = other.Vpt;
      }
      if (other.Rbh != 0L) {
        Rbh = other.Rbh;
      }
      if (other.Sbh != 0L) {
        Sbh = other.Sbh;
      }
      if (other.Gas != 0L) {
        Gas = other.Gas;
      }
      if (other.Tv != 0L) {
        Tv = other.Tv;
      }
      if (other.Bpr != 0L) {
        Bpr = other.Bpr;
      }
      if (other.Sbpr != 0L) {
        Sbpr = other.Sbpr;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Min = input.ReadInt64();
            break;
          }
          case 16: {
            Max = input.ReadInt64();
            break;
          }
          case 24: {
            Constant = input.ReadInt64();
            break;
          }
          case 32: {
            Bpt = input.ReadInt64();
            break;
          }
          case 40: {
            Vpt = input.ReadInt64();
            break;
          }
          case 48: {
            Rbh = input.ReadInt64();
            break;
          }
          case 56: {
            Sbh = input.ReadInt64();
            break;
          }
          case 64: {
            Gas = input.ReadInt64();
            break;
          }
          case 72: {
            Tv = input.ReadInt64();
            break;
          }
          case 80: {
            Bpr = input.ReadInt64();
            break;
          }
          case 88: {
            Sbpr = input.ReadInt64();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Min = input.ReadInt64();
            break;
          }
          case 16: {
            Max = input.ReadInt64();
            break;
          }
          case 24: {
            Constant = input.ReadInt64();
            break;
          }
          case 32: {
            Bpt = input.ReadInt64();
            break;
          }
          case 40: {
            Vpt = input.ReadInt64();
            break;
          }
          case 48: {
            Rbh = input.ReadInt64();
            break;
          }
          case 56: {
            Sbh = input.ReadInt64();
            break;
          }
          case 64: {
            Gas = input.ReadInt64();
            break;
          }
          case 72: {
            Tv = input.ReadInt64();
            break;
          }
          case 80: {
            Bpr = input.ReadInt64();
            break;
          }
          case 88: {
            Sbpr = input.ReadInt64();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// The fee schedule for a specific transaction or query based on the fee data.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class TransactionFeeSchedule : pb::IMessage<TransactionFeeSchedule>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<TransactionFeeSchedule> _parser = new pb::MessageParser<TransactionFeeSchedule>(() => new TransactionFeeSchedule());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<TransactionFeeSchedule> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Proto.BasicTypesReflection.Descriptor.MessageTypes[28]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TransactionFeeSchedule() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TransactionFeeSchedule(TransactionFeeSchedule other) : this() {
      hederaFunctionality_ = other.hederaFunctionality_;
      feeData_ = other.feeData_ != null ? other.feeData_.Clone() : null;
      fees_ = other.fees_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TransactionFeeSchedule Clone() {
      return new TransactionFeeSchedule(this);
    }

    /// <summary>Field number for the "hederaFunctionality" field.</summary>
    public const int HederaFunctionalityFieldNumber = 1;
    private global::Proto.HederaFunctionality hederaFunctionality_ = global::Proto.HederaFunctionality.None;
    /// <summary>
    ///*
    /// An enumeration for a particular transaction or query.&lt;br/>
    /// The functionality type determines the base cost parameters.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.HederaFunctionality HederaFunctionality {
      get { return hederaFunctionality_; }
      set {
        hederaFunctionality_ = value;
      }
    }

    /// <summary>Field number for the "feeData" field.</summary>
    public const int FeeDataFieldNumber = 2;
    private global::Proto.FeeData feeData_;
    /// <summary>
    ///*
    /// Use `fees` instead of this field.&lt;br/>
    /// Resource price coefficients.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.FeeData FeeData {
      get { return feeData_; }
      set {
        feeData_ = value;
      }
    }

    /// <summary>Field number for the "fees" field.</summary>
    public const int FeesFieldNumber = 3;
    private static readonly pb::FieldCodec<global::Proto.FeeData> _repeated_fees_codec
        = pb::FieldCodec.ForMessage(26, global::Proto.FeeData.Parser);
    private readonly pbc::RepeatedField<global::Proto.FeeData> fees_ = new pbc::RepeatedField<global::Proto.FeeData>();
    /// <summary>
    ///*
    /// The resource price coefficients for transaction type and any applicable
    /// subtypes.&lt;br/>
    /// The multiple entries enable support for subtype price definitions.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Proto.FeeData> Fees {
      get { return fees_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as TransactionFeeSchedule);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(TransactionFeeSchedule other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (HederaFunctionality != other.HederaFunctionality) return false;
      if (!object.Equals(FeeData, other.FeeData)) return false;
      if(!fees_.Equals(other.fees_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HederaFunctionality != global::Proto.HederaFunctionality.None) hash ^= HederaFunctionality.GetHashCode();
      if (feeData_ != null) hash ^= FeeData.GetHashCode();
      hash ^= fees_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HederaFunctionality != global::Proto.HederaFunctionality.None) {
        output.WriteRawTag(8);
        output.WriteEnum((int) HederaFunctionality);
      }
      if (feeData_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(FeeData);
      }
      fees_.WriteTo(output, _repeated_fees_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HederaFunctionality != global::Proto.HederaFunctionality.None) {
        output.WriteRawTag(8);
        output.WriteEnum((int) HederaFunctionality);
      }
      if (feeData_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(FeeData);
      }
      fees_.WriteTo(ref output, _repeated_fees_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HederaFunctionality != global::Proto.HederaFunctionality.None) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) HederaFunctionality);
      }
      if (feeData_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(FeeData);
      }
      size += fees_.CalculateSize(_repeated_fees_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(TransactionFeeSchedule other) {
      if (other == null) {
        return;
      }
      if (other.HederaFunctionality != global::Proto.HederaFunctionality.None) {
        HederaFunctionality = other.HederaFunctionality;
      }
      if (other.feeData_ != null) {
        if (feeData_ == null) {
          FeeData = new global::Proto.FeeData();
        }
        FeeData.MergeFrom(other.FeeData);
      }
      fees_.Add(other.fees_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            HederaFunctionality = (global::Proto.HederaFunctionality) input.ReadEnum();
            break;
          }
          case 18: {
            if (feeData_ == null) {
              FeeData = new global::Proto.FeeData();
            }
            input.ReadMessage(FeeData);
            break;
          }
          case 26: {
            fees_.AddEntriesFrom(input, _repeated_fees_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            HederaFunctionality = (global::Proto.HederaFunctionality) input.ReadEnum();
            break;
          }
          case 18: {
            if (feeData_ == null) {
              FeeData = new global::Proto.FeeData();
            }
            input.ReadMessage(FeeData);
            break;
          }
          case 26: {
            fees_.AddEntriesFrom(ref input, _repeated_fees_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// A total fee, in component amounts charged for a transaction.
  ///
  /// Total fees are composed of three sets of components.
  /// - Node data, components that compensate the specific node that submitted
  ///   the transaction.
  /// - Network data, components that compensate the Hedera network for gossiping
  ///   the transaction and determining the consensus timestamp.
  /// - Service data, components that compensate the Hedera network for the ongoing
  ///   maintenance and operation of the network, as well as ongoing development
  ///   of network services.
  ///
  /// Fee components are recorded in thousandths of a tiny cent, and the network
  /// exchange rate converts these to tinybar amounts, which are what the network
  /// charges for transactions and what the network reports in the record stream.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class FeeData : pb::IMessage<FeeData>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<FeeData> _parser = new pb::MessageParser<FeeData>(() => new FeeData());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<FeeData> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Proto.BasicTypesReflection.Descriptor.MessageTypes[29]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public FeeData() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public FeeData(FeeData other) : this() {
      nodedata_ = other.nodedata_ != null ? other.nodedata_.Clone() : null;
      networkdata_ = other.networkdata_ != null ? other.networkdata_.Clone() : null;
      servicedata_ = other.servicedata_ != null ? other.servicedata_.Clone() : null;
      subType_ = other.subType_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public FeeData Clone() {
      return new FeeData(this);
    }

    /// <summary>Field number for the "nodedata" field.</summary>
    public const int NodedataFieldNumber = 1;
    private global::Proto.FeeComponents nodedata_;
    /// <summary>
    ///*
    /// Fee components to be paid to the submitting node.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.FeeComponents Nodedata {
      get { return nodedata_; }
      set {
        nodedata_ = value;
      }
    }

    /// <summary>Field number for the "networkdata" field.</summary>
    public const int NetworkdataFieldNumber = 2;
    private global::Proto.FeeComponents networkdata_;
    /// <summary>
    ///*
    /// Fee components to be paid to the network for bringing a
    /// transaction to consensus.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.FeeComponents Networkdata {
      get { return networkdata_; }
      set {
        networkdata_ = value;
      }
    }

    /// <summary>Field number for the "servicedata" field.</summary>
    public const int ServicedataFieldNumber = 3;
    private global::Proto.FeeComponents servicedata_;
    /// <summary>
    ///*
    /// Fee components to be paid to the network for providing the immediate and
    /// ongoing services associated with executing the transaction, maintaining
    /// the network, and developing the network software.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.FeeComponents Servicedata {
      get { return servicedata_; }
      set {
        servicedata_ = value;
      }
    }

    /// <summary>Field number for the "subType" field.</summary>
    public const int SubTypeFieldNumber = 4;
    private global::Proto.SubType subType_ = global::Proto.SubType.Default;
    /// <summary>
    ///*
    /// A sub-type distinguishing between different types of `FeeData` that may
    /// apply to the same base transaction type (associated with
    /// an `HederaFunctionality`).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.SubType SubType {
      get { return subType_; }
      set {
        subType_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as FeeData);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(FeeData other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Nodedata, other.Nodedata)) return false;
      if (!object.Equals(Networkdata, other.Networkdata)) return false;
      if (!object.Equals(Servicedata, other.Servicedata)) return false;
      if (SubType != other.SubType) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (nodedata_ != null) hash ^= Nodedata.GetHashCode();
      if (networkdata_ != null) hash ^= Networkdata.GetHashCode();
      if (servicedata_ != null) hash ^= Servicedata.GetHashCode();
      if (SubType != global::Proto.SubType.Default) hash ^= SubType.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (nodedata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Nodedata);
      }
      if (networkdata_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Networkdata);
      }
      if (servicedata_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Servicedata);
      }
      if (SubType != global::Proto.SubType.Default) {
        output.WriteRawTag(32);
        output.WriteEnum((int) SubType);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (nodedata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Nodedata);
      }
      if (networkdata_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Networkdata);
      }
      if (servicedata_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Servicedata);
      }
      if (SubType != global::Proto.SubType.Default) {
        output.WriteRawTag(32);
        output.WriteEnum((int) SubType);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (nodedata_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Nodedata);
      }
      if (networkdata_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Networkdata);
      }
      if (servicedata_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Servicedata);
      }
      if (SubType != global::Proto.SubType.Default) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) SubType);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(FeeData other) {
      if (other == null) {
        return;
      }
      if (other.nodedata_ != null) {
        if (nodedata_ == null) {
          Nodedata = new global::Proto.FeeComponents();
        }
        Nodedata.MergeFrom(other.Nodedata);
      }
      if (other.networkdata_ != null) {
        if (networkdata_ == null) {
          Networkdata = new global::Proto.FeeComponents();
        }
        Networkdata.MergeFrom(other.Networkdata);
      }
      if (other.servicedata_ != null) {
        if (servicedata_ == null) {
          Servicedata = new global::Proto.FeeComponents();
        }
        Servicedata.MergeFrom(other.Servicedata);
      }
      if (other.SubType != global::Proto.SubType.Default) {
        SubType = other.SubType;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (nodedata_ == null) {
              Nodedata = new global::Proto.FeeComponents();
            }
            input.ReadMessage(Nodedata);
            break;
          }
          case 18: {
            if (networkdata_ == null) {
              Networkdata = new global::Proto.FeeComponents();
            }
            input.ReadMessage(Networkdata);
            break;
          }
          case 26: {
            if (servicedata_ == null) {
              Servicedata = new global::Proto.FeeComponents();
            }
            input.ReadMessage(Servicedata);
            break;
          }
          case 32: {
            SubType = (global::Proto.SubType) input.ReadEnum();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (nodedata_ == null) {
              Nodedata = new global::Proto.FeeComponents();
            }
            input.ReadMessage(Nodedata);
            break;
          }
          case 18: {
            if (networkdata_ == null) {
              Networkdata = new global::Proto.FeeComponents();
            }
            input.ReadMessage(Networkdata);
            break;
          }
          case 26: {
            if (servicedata_ == null) {
              Servicedata = new global::Proto.FeeComponents();
            }
            input.ReadMessage(Servicedata);
            break;
          }
          case 32: {
            SubType = (global::Proto.SubType) input.ReadEnum();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// A set of fee schedules covering all transaction types and query types, along
  /// with a specific time at which this fee schedule will expire.
  ///
  /// Nodes SHALL use the most recent unexpired fee schedule to determine the fees
  /// for all transactions based on various resource components imputed to each
  /// transaction.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class FeeSchedule : pb::IMessage<FeeSchedule>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<FeeSchedule> _parser = new pb::MessageParser<FeeSchedule>(() => new FeeSchedule());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<FeeSchedule> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Proto.BasicTypesReflection.Descriptor.MessageTypes[30]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public FeeSchedule() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public FeeSchedule(FeeSchedule other) : this() {
      transactionFeeSchedule_ = other.transactionFeeSchedule_.Clone();
      expiryTime_ = other.expiryTime_ != null ? other.expiryTime_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public FeeSchedule Clone() {
      return new FeeSchedule(this);
    }

    /// <summary>Field number for the "transactionFeeSchedule" field.</summary>
    public const int TransactionFeeScheduleFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Proto.TransactionFeeSchedule> _repeated_transactionFeeSchedule_codec
        = pb::FieldCodec.ForMessage(10, global::Proto.TransactionFeeSchedule.Parser);
    private readonly pbc::RepeatedField<global::Proto.TransactionFeeSchedule> transactionFeeSchedule_ = new pbc::RepeatedField<global::Proto.TransactionFeeSchedule>();
    /// <summary>
    ///*
    /// Sets of fee coefficients for various transaction or query types.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Proto.TransactionFeeSchedule> TransactionFeeSchedule {
      get { return transactionFeeSchedule_; }
    }

    /// <summary>Field number for the "expiryTime" field.</summary>
    public const int ExpiryTimeFieldNumber = 2;
    private global::Proto.TimestampSeconds expiryTime_;
    /// <summary>
    ///*
    /// A time, in seconds since the `epoch`, when this fee schedule
    /// will expire.
    /// &lt;p>
    /// For this purpose, `epoch` SHALL be the UNIX epoch
    /// with 0 at `1970-01-01T00:00:00.000Z`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.TimestampSeconds ExpiryTime {
      get { return expiryTime_; }
      set {
        expiryTime_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as FeeSchedule);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(FeeSchedule other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!transactionFeeSchedule_.Equals(other.transactionFeeSchedule_)) return false;
      if (!object.Equals(ExpiryTime, other.ExpiryTime)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= transactionFeeSchedule_.GetHashCode();
      if (expiryTime_ != null) hash ^= ExpiryTime.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      transactionFeeSchedule_.WriteTo(output, _repeated_transactionFeeSchedule_codec);
      if (expiryTime_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(ExpiryTime);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      transactionFeeSchedule_.WriteTo(ref output, _repeated_transactionFeeSchedule_codec);
      if (expiryTime_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(ExpiryTime);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += transactionFeeSchedule_.CalculateSize(_repeated_transactionFeeSchedule_codec);
      if (expiryTime_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ExpiryTime);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(FeeSchedule other) {
      if (other == null) {
        return;
      }
      transactionFeeSchedule_.Add(other.transactionFeeSchedule_);
      if (other.expiryTime_ != null) {
        if (expiryTime_ == null) {
          ExpiryTime = new global::Proto.TimestampSeconds();
        }
        ExpiryTime.MergeFrom(other.ExpiryTime);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            transactionFeeSchedule_.AddEntriesFrom(input, _repeated_transactionFeeSchedule_codec);
            break;
          }
          case 18: {
            if (expiryTime_ == null) {
              ExpiryTime = new global::Proto.TimestampSeconds();
            }
            input.ReadMessage(ExpiryTime);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            transactionFeeSchedule_.AddEntriesFrom(ref input, _repeated_transactionFeeSchedule_codec);
            break;
          }
          case 18: {
            if (expiryTime_ == null) {
              ExpiryTime = new global::Proto.TimestampSeconds();
            }
            input.ReadMessage(ExpiryTime);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// The "current" fee schedule and the "next" fee schedule.
  ///
  /// The current fee schedule is the schedule that SHALL apply to the current
  /// transaction.&lt;br/>
  /// The next fee schedule is the schedule that SHALL apply after the current
  /// schedule expires.&lt;br/>
  /// We store both to avoid a condition where transactions are processed very
  /// near the time when a fee schedule expires and it might be indeterminate
  /// which fees to apply. With both current and next fee schedule the network
  /// can deterministically apply the correct fee schedule based on consensus
  /// timestamp for each transaction.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class CurrentAndNextFeeSchedule : pb::IMessage<CurrentAndNextFeeSchedule>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<CurrentAndNextFeeSchedule> _parser = new pb::MessageParser<CurrentAndNextFeeSchedule>(() => new CurrentAndNextFeeSchedule());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<CurrentAndNextFeeSchedule> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Proto.BasicTypesReflection.Descriptor.MessageTypes[31]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public CurrentAndNextFeeSchedule() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public CurrentAndNextFeeSchedule(CurrentAndNextFeeSchedule other) : this() {
      currentFeeSchedule_ = other.currentFeeSchedule_ != null ? other.currentFeeSchedule_.Clone() : null;
      nextFeeSchedule_ = other.nextFeeSchedule_ != null ? other.nextFeeSchedule_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public CurrentAndNextFeeSchedule Clone() {
      return new CurrentAndNextFeeSchedule(this);
    }

    /// <summary>Field number for the "currentFeeSchedule" field.</summary>
    public const int CurrentFeeScheduleFieldNumber = 1;
    private global::Proto.FeeSchedule currentFeeSchedule_;
    /// <summary>
    ///*
    /// A current, unexpired, fee schedule.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.FeeSchedule CurrentFeeSchedule {
      get { return currentFeeSchedule_; }
      set {
        currentFeeSchedule_ = value;
      }
    }

    /// <summary>Field number for the "nextFeeSchedule" field.</summary>
    public const int NextFeeScheduleFieldNumber = 2;
    private global::Proto.FeeSchedule nextFeeSchedule_;
    /// <summary>
    ///*
    /// A future fee schedule to use when the current schedule expires.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.FeeSchedule NextFeeSchedule {
      get { return nextFeeSchedule_; }
      set {
        nextFeeSchedule_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as CurrentAndNextFeeSchedule);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(CurrentAndNextFeeSchedule other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(CurrentFeeSchedule, other.CurrentFeeSchedule)) return false;
      if (!object.Equals(NextFeeSchedule, other.NextFeeSchedule)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (currentFeeSchedule_ != null) hash ^= CurrentFeeSchedule.GetHashCode();
      if (nextFeeSchedule_ != null) hash ^= NextFeeSchedule.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (currentFeeSchedule_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(CurrentFeeSchedule);
      }
      if (nextFeeSchedule_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(NextFeeSchedule);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (currentFeeSchedule_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(CurrentFeeSchedule);
      }
      if (nextFeeSchedule_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(NextFeeSchedule);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (currentFeeSchedule_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(CurrentFeeSchedule);
      }
      if (nextFeeSchedule_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(NextFeeSchedule);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(CurrentAndNextFeeSchedule other) {
      if (other == null) {
        return;
      }
      if (other.currentFeeSchedule_ != null) {
        if (currentFeeSchedule_ == null) {
          CurrentFeeSchedule = new global::Proto.FeeSchedule();
        }
        CurrentFeeSchedule.MergeFrom(other.CurrentFeeSchedule);
      }
      if (other.nextFeeSchedule_ != null) {
        if (nextFeeSchedule_ == null) {
          NextFeeSchedule = new global::Proto.FeeSchedule();
        }
        NextFeeSchedule.MergeFrom(other.NextFeeSchedule);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (currentFeeSchedule_ == null) {
              CurrentFeeSchedule = new global::Proto.FeeSchedule();
            }
            input.ReadMessage(CurrentFeeSchedule);
            break;
          }
          case 18: {
            if (nextFeeSchedule_ == null) {
              NextFeeSchedule = new global::Proto.FeeSchedule();
            }
            input.ReadMessage(NextFeeSchedule);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (currentFeeSchedule_ == null) {
              CurrentFeeSchedule = new global::Proto.FeeSchedule();
            }
            input.ReadMessage(CurrentFeeSchedule);
            break;
          }
          case 18: {
            if (nextFeeSchedule_ == null) {
              NextFeeSchedule = new global::Proto.FeeSchedule();
            }
            input.ReadMessage(NextFeeSchedule);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// A network node endpoint.&lt;br/>
  /// Each network node in the global address book publishes one or more endpoints
  /// which enable the nodes to communicate both with other nodes, for gossip, and
  /// with clients to receive transaction requests.
  ///
  /// This message supports IPv4 with address and TCP port,
  /// and MAY include a FQDN instead of an IP address.&lt;br/>
  /// IPv6 is not currently supported.
  ///
  /// When the `domain_name` field is set, the `ipAddressV4` field
  /// MUST NOT be set.&lt;br/>
  /// When the `ipAddressV4` field is set, the `domain_name` field
  /// MUST NOT be set.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class ServiceEndpoint : pb::IMessage<ServiceEndpoint>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ServiceEndpoint> _parser = new pb::MessageParser<ServiceEndpoint>(() => new ServiceEndpoint());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ServiceEndpoint> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Proto.BasicTypesReflection.Descriptor.MessageTypes[32]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ServiceEndpoint() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ServiceEndpoint(ServiceEndpoint other) : this() {
      ipAddressV4_ = other.ipAddressV4_;
      port_ = other.port_;
      domainName_ = other.domainName_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ServiceEndpoint Clone() {
      return new ServiceEndpoint(this);
    }

    /// <summary>Field number for the "ipAddressV4" field.</summary>
    public const int IpAddressV4FieldNumber = 1;
    private pb::ByteString ipAddressV4_ = pb::ByteString.Empty;
    /// <summary>
    ///*
    /// A 32-bit IPv4 address.&lt;br/>
    /// This is the address of the endpoint, encoded in pure "big-endian"
    /// (i.e. left to right) order (e.g. `127.0.0.1` has hex bytes in the
    /// order `7F`, `00`, `00`, `01`).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString IpAddressV4 {
      get { return ipAddressV4_; }
      set {
        ipAddressV4_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "port" field.</summary>
    public const int PortFieldNumber = 2;
    private int port_;
    /// <summary>
    ///*
    /// A TCP port to use.
    /// &lt;p>
    /// This value MUST be between 0 and 65535, inclusive.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int Port {
      get { return port_; }
      set {
        port_ = value;
      }
    }

    /// <summary>Field number for the "domain_name" field.</summary>
    public const int DomainNameFieldNumber = 3;
    private string domainName_ = "";
    /// <summary>
    ///*
    /// A node domain name.
    /// &lt;p>
    /// This MUST be the fully qualified domain name of the node.&lt;br/>
    /// This value MUST NOT exceed 253 characters.&lt;br/>
    /// When the `domain_name` field is set, the `ipAddressV4`
    /// field MUST NOT be set.&lt;br/>
    /// When the `ipAddressV4` field is set, the `domain_name`
    /// field MUST NOT be set.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string DomainName {
      get { return domainName_; }
      set {
        domainName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ServiceEndpoint);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ServiceEndpoint other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (IpAddressV4 != other.IpAddressV4) return false;
      if (Port != other.Port) return false;
      if (DomainName != other.DomainName) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (IpAddressV4.Length != 0) hash ^= IpAddressV4.GetHashCode();
      if (Port != 0) hash ^= Port.GetHashCode();
      if (DomainName.Length != 0) hash ^= DomainName.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (IpAddressV4.Length != 0) {
        output.WriteRawTag(10);
        output.WriteBytes(IpAddressV4);
      }
      if (Port != 0) {
        output.WriteRawTag(16);
        output.WriteInt32(Port);
      }
      if (DomainName.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(DomainName);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (IpAddressV4.Length != 0) {
        output.WriteRawTag(10);
        output.WriteBytes(IpAddressV4);
      }
      if (Port != 0) {
        output.WriteRawTag(16);
        output.WriteInt32(Port);
      }
      if (DomainName.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(DomainName);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (IpAddressV4.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(IpAddressV4);
      }
      if (Port != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(Port);
      }
      if (DomainName.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(DomainName);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ServiceEndpoint other) {
      if (other == null) {
        return;
      }
      if (other.IpAddressV4.Length != 0) {
        IpAddressV4 = other.IpAddressV4;
      }
      if (other.Port != 0) {
        Port = other.Port;
      }
      if (other.DomainName.Length != 0) {
        DomainName = other.DomainName;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            IpAddressV4 = input.ReadBytes();
            break;
          }
          case 16: {
            Port = input.ReadInt32();
            break;
          }
          case 26: {
            DomainName = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            IpAddressV4 = input.ReadBytes();
            break;
          }
          case 16: {
            Port = input.ReadInt32();
            break;
          }
          case 26: {
            DomainName = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// The data about a node, including its service endpoints and the Hedera account
  /// to be paid for services provided by the node (that is, queries answered and
  /// transactions submitted).
  ///
  /// All active fields are populated in the `0.0.102` address book file.&lt;br/>
  /// Only fields documented with "`0.0.101` field" are populated in the 0.0.101
  /// address book file.
  ///
  /// This message MAY be superseded by messages in state/addressbook/node.proto
  /// and node_get_info.proto.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class NodeAddress : pb::IMessage<NodeAddress>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<NodeAddress> _parser = new pb::MessageParser<NodeAddress>(() => new NodeAddress());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<NodeAddress> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Proto.BasicTypesReflection.Descriptor.MessageTypes[33]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NodeAddress() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NodeAddress(NodeAddress other) : this() {
      ipAddress_ = other.ipAddress_;
      portno_ = other.portno_;
      memo_ = other.memo_;
      rSAPubKey_ = other.rSAPubKey_;
      nodeId_ = other.nodeId_;
      nodeAccountId_ = other.nodeAccountId_ != null ? other.nodeAccountId_.Clone() : null;
      nodeCertHash_ = other.nodeCertHash_;
      serviceEndpoint_ = other.serviceEndpoint_.Clone();
      description_ = other.description_;
      stake_ = other.stake_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NodeAddress Clone() {
      return new NodeAddress(this);
    }

    /// <summary>Field number for the "ipAddress" field.</summary>
    public const int IpAddressFieldNumber = 1;
    private pb::ByteString ipAddress_ = pb::ByteString.Empty;
    /// <summary>
    ///*
    /// ServiceEndpoint is now used to retrieve a node's list of IP
    /// addresses and ports.&lt;br/>
    /// The IP address of the Node, as a string, encoded in UTF-8.&lt;br/>
    /// This value SHALL NOT be populated.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString IpAddress {
      get { return ipAddress_; }
      set {
        ipAddress_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "portno" field.</summary>
    public const int PortnoFieldNumber = 2;
    private int portno_;
    /// <summary>
    ///*
    /// ServiceEndpoint is now used to retrieve a node's list of IP
    /// addresses and ports.&lt;br/>
    /// The port number of the grpc server for the node.&lt;br/>
    /// This value SHALL NOT be populated.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int Portno {
      get { return portno_; }
      set {
        portno_ = value;
      }
    }

    /// <summary>Field number for the "memo" field.</summary>
    public const int MemoFieldNumber = 3;
    private pb::ByteString memo_ = pb::ByteString.Empty;
    /// <summary>
    ///*
    /// Description provides short text functionality.&lt;br/>
    /// A short description of the node.
    /// &lt;p>
    /// This field SHALL NOT be populated.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString Memo {
      get { return memo_; }
      set {
        memo_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "RSA_PubKey" field.</summary>
    public const int RSAPubKeyFieldNumber = 4;
    private string rSAPubKey_ = "";
    /// <summary>
    ///*
    /// A hexadecimal String encoding of an X509 public key.
    /// &lt;p>
    /// This X509 RSA _public_ key SHALL be used to verify record stream files
    /// (e.g., record stream files).&lt;br/>
    /// This field SHALL be a string of hexadecimal characters, encoded UTF-8,
    /// which, translated to binary, form the public key DER encoding.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string RSAPubKey {
      get { return rSAPubKey_; }
      set {
        rSAPubKey_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "nodeId" field.</summary>
    public const int NodeIdFieldNumber = 5;
    private long nodeId_;
    /// <summary>
    ///*
    /// A numeric identifier for the node.
    /// &lt;p>
    /// This value SHALL NOT be sequential.
    /// &lt;p>
    /// A `0.0.101` field
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long NodeId {
      get { return nodeId_; }
      set {
        nodeId_ = value;
      }
    }

    /// <summary>Field number for the "nodeAccountId" field.</summary>
    public const int NodeAccountIdFieldNumber = 6;
    private global::Proto.AccountID nodeAccountId_;
    /// <summary>
    ///*
    /// An account to be paid the "node" portion of transaction fees.&lt;br/>
    /// The "node" fees are paid to the node that submitted the transaction.
    /// &lt;p>
    /// A `0.0.101` field
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.AccountID NodeAccountId {
      get { return nodeAccountId_; }
      set {
        nodeAccountId_ = value;
      }
    }

    /// <summary>Field number for the "nodeCertHash" field.</summary>
    public const int NodeCertHashFieldNumber = 7;
    private pb::ByteString nodeCertHash_ = pb::ByteString.Empty;
    /// <summary>
    ///*
    /// A hash of the node's TLS certificate.
    /// &lt;p>
    /// This field SHALL be a string of hexadecimal characters, encoded UTF-8,
    /// which, translated to binary, form a SHA-384 hash of the node's TLS
    /// certificate in PEM format.
    /// This TLS certificate MUST be encoded UTF-8 and normalized according to
    /// the NFKD form prior to computing the hash value.&lt;br/>
    /// The value of this field SHALL be used to verify the node TLS
    /// certificate when presented during protocol negotiation.
    /// &lt;p>
    /// A `0.0.101` field
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString NodeCertHash {
      get { return nodeCertHash_; }
      set {
        nodeCertHash_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "serviceEndpoint" field.</summary>
    public const int ServiceEndpointFieldNumber = 8;
    private static readonly pb::FieldCodec<global::Proto.ServiceEndpoint> _repeated_serviceEndpoint_codec
        = pb::FieldCodec.ForMessage(66, global::Proto.ServiceEndpoint.Parser);
    private readonly pbc::RepeatedField<global::Proto.ServiceEndpoint> serviceEndpoint_ = new pbc::RepeatedField<global::Proto.ServiceEndpoint>();
    /// <summary>
    ///*
    /// A node's service IP addresses and TCP ports.&lt;br/>
    /// Nodes require multiple endpoints to ensure that inter-node communication
    /// (e.g. gossip) is properly separated from client communication to
    /// API endpoints.
    /// &lt;p>
    /// A `0.0.101` field
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Proto.ServiceEndpoint> ServiceEndpoint {
      get { return serviceEndpoint_; }
    }

    /// <summary>Field number for the "description" field.</summary>
    public const int DescriptionFieldNumber = 9;
    private string description_ = "";
    /// <summary>
    ///*
    /// A short description of the node.
    /// &lt;p>
    /// This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
    /// (default 100) bytes when encoded as UTF-8.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Description {
      get { return description_; }
      set {
        description_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "stake" field.</summary>
    public const int StakeFieldNumber = 10;
    private long stake_;
    /// <summary>
    ///*
    /// This is replaced by per-account stake tracking and dynamic
    /// calculation.&lt;br/>
    /// The amount of tinybar staked to the node.&lt;br/>
    /// This value SHOULD NOT be populated, and SHALL be ignored.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long Stake {
      get { return stake_; }
      set {
        stake_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as NodeAddress);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(NodeAddress other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (IpAddress != other.IpAddress) return false;
      if (Portno != other.Portno) return false;
      if (Memo != other.Memo) return false;
      if (RSAPubKey != other.RSAPubKey) return false;
      if (NodeId != other.NodeId) return false;
      if (!object.Equals(NodeAccountId, other.NodeAccountId)) return false;
      if (NodeCertHash != other.NodeCertHash) return false;
      if(!serviceEndpoint_.Equals(other.serviceEndpoint_)) return false;
      if (Description != other.Description) return false;
      if (Stake != other.Stake) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (IpAddress.Length != 0) hash ^= IpAddress.GetHashCode();
      if (Portno != 0) hash ^= Portno.GetHashCode();
      if (Memo.Length != 0) hash ^= Memo.GetHashCode();
      if (RSAPubKey.Length != 0) hash ^= RSAPubKey.GetHashCode();
      if (NodeId != 0L) hash ^= NodeId.GetHashCode();
      if (nodeAccountId_ != null) hash ^= NodeAccountId.GetHashCode();
      if (NodeCertHash.Length != 0) hash ^= NodeCertHash.GetHashCode();
      hash ^= serviceEndpoint_.GetHashCode();
      if (Description.Length != 0) hash ^= Description.GetHashCode();
      if (Stake != 0L) hash ^= Stake.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (IpAddress.Length != 0) {
        output.WriteRawTag(10);
        output.WriteBytes(IpAddress);
      }
      if (Portno != 0) {
        output.WriteRawTag(16);
        output.WriteInt32(Portno);
      }
      if (Memo.Length != 0) {
        output.WriteRawTag(26);
        output.WriteBytes(Memo);
      }
      if (RSAPubKey.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(RSAPubKey);
      }
      if (NodeId != 0L) {
        output.WriteRawTag(40);
        output.WriteInt64(NodeId);
      }
      if (nodeAccountId_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(NodeAccountId);
      }
      if (NodeCertHash.Length != 0) {
        output.WriteRawTag(58);
        output.WriteBytes(NodeCertHash);
      }
      serviceEndpoint_.WriteTo(output, _repeated_serviceEndpoint_codec);
      if (Description.Length != 0) {
        output.WriteRawTag(74);
        output.WriteString(Description);
      }
      if (Stake != 0L) {
        output.WriteRawTag(80);
        output.WriteInt64(Stake);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (IpAddress.Length != 0) {
        output.WriteRawTag(10);
        output.WriteBytes(IpAddress);
      }
      if (Portno != 0) {
        output.WriteRawTag(16);
        output.WriteInt32(Portno);
      }
      if (Memo.Length != 0) {
        output.WriteRawTag(26);
        output.WriteBytes(Memo);
      }
      if (RSAPubKey.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(RSAPubKey);
      }
      if (NodeId != 0L) {
        output.WriteRawTag(40);
        output.WriteInt64(NodeId);
      }
      if (nodeAccountId_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(NodeAccountId);
      }
      if (NodeCertHash.Length != 0) {
        output.WriteRawTag(58);
        output.WriteBytes(NodeCertHash);
      }
      serviceEndpoint_.WriteTo(ref output, _repeated_serviceEndpoint_codec);
      if (Description.Length != 0) {
        output.WriteRawTag(74);
        output.WriteString(Description);
      }
      if (Stake != 0L) {
        output.WriteRawTag(80);
        output.WriteInt64(Stake);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (IpAddress.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(IpAddress);
      }
      if (Portno != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(Portno);
      }
      if (Memo.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Memo);
      }
      if (RSAPubKey.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(RSAPubKey);
      }
      if (NodeId != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(NodeId);
      }
      if (nodeAccountId_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(NodeAccountId);
      }
      if (NodeCertHash.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(NodeCertHash);
      }
      size += serviceEndpoint_.CalculateSize(_repeated_serviceEndpoint_codec);
      if (Description.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Description);
      }
      if (Stake != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(Stake);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(NodeAddress other) {
      if (other == null) {
        return;
      }
      if (other.IpAddress.Length != 0) {
        IpAddress = other.IpAddress;
      }
      if (other.Portno != 0) {
        Portno = other.Portno;
      }
      if (other.Memo.Length != 0) {
        Memo = other.Memo;
      }
      if (other.RSAPubKey.Length != 0) {
        RSAPubKey = other.RSAPubKey;
      }
      if (other.NodeId != 0L) {
        NodeId = other.NodeId;
      }
      if (other.nodeAccountId_ != null) {
        if (nodeAccountId_ == null) {
          NodeAccountId = new global::Proto.AccountID();
        }
        NodeAccountId.MergeFrom(other.NodeAccountId);
      }
      if (other.NodeCertHash.Length != 0) {
        NodeCertHash = other.NodeCertHash;
      }
      serviceEndpoint_.Add(other.serviceEndpoint_);
      if (other.Description.Length != 0) {
        Description = other.Description;
      }
      if (other.Stake != 0L) {
        Stake = other.Stake;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            IpAddress = input.ReadBytes();
            break;
          }
          case 16: {
            Portno = input.ReadInt32();
            break;
          }
          case 26: {
            Memo = input.ReadBytes();
            break;
          }
          case 34: {
            RSAPubKey = input.ReadString();
            break;
          }
          case 40: {
            NodeId = input.ReadInt64();
            break;
          }
          case 50: {
            if (nodeAccountId_ == null) {
              NodeAccountId = new global::Proto.AccountID();
            }
            input.ReadMessage(NodeAccountId);
            break;
          }
          case 58: {
            NodeCertHash = input.ReadBytes();
            break;
          }
          case 66: {
            serviceEndpoint_.AddEntriesFrom(input, _repeated_serviceEndpoint_codec);
            break;
          }
          case 74: {
            Description = input.ReadString();
            break;
          }
          case 80: {
            Stake = input.ReadInt64();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            IpAddress = input.ReadBytes();
            break;
          }
          case 16: {
            Portno = input.ReadInt32();
            break;
          }
          case 26: {
            Memo = input.ReadBytes();
            break;
          }
          case 34: {
            RSAPubKey = input.ReadString();
            break;
          }
          case 40: {
            NodeId = input.ReadInt64();
            break;
          }
          case 50: {
            if (nodeAccountId_ == null) {
              NodeAccountId = new global::Proto.AccountID();
            }
            input.ReadMessage(NodeAccountId);
            break;
          }
          case 58: {
            NodeCertHash = input.ReadBytes();
            break;
          }
          case 66: {
            serviceEndpoint_.AddEntriesFrom(ref input, _repeated_serviceEndpoint_codec);
            break;
          }
          case 74: {
            Description = input.ReadString();
            break;
          }
          case 80: {
            Stake = input.ReadInt64();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// A list of nodes and their metadata that contains details of the nodes
  /// running the network.
  ///
  /// Used to parse the contents of system files `0.0.101` and `0.0.102`.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class NodeAddressBook : pb::IMessage<NodeAddressBook>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<NodeAddressBook> _parser = new pb::MessageParser<NodeAddressBook>(() => new NodeAddressBook());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<NodeAddressBook> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Proto.BasicTypesReflection.Descriptor.MessageTypes[34]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NodeAddressBook() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NodeAddressBook(NodeAddressBook other) : this() {
      nodeAddress_ = other.nodeAddress_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NodeAddressBook Clone() {
      return new NodeAddressBook(this);
    }

    /// <summary>Field number for the "nodeAddress" field.</summary>
    public const int NodeAddressFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Proto.NodeAddress> _repeated_nodeAddress_codec
        = pb::FieldCodec.ForMessage(10, global::Proto.NodeAddress.Parser);
    private readonly pbc::RepeatedField<global::Proto.NodeAddress> nodeAddress_ = new pbc::RepeatedField<global::Proto.NodeAddress>();
    /// <summary>
    ///*
    /// Published data for all nodes in the network
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Proto.NodeAddress> NodeAddress {
      get { return nodeAddress_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as NodeAddressBook);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(NodeAddressBook other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!nodeAddress_.Equals(other.nodeAddress_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= nodeAddress_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      nodeAddress_.WriteTo(output, _repeated_nodeAddress_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      nodeAddress_.WriteTo(ref output, _repeated_nodeAddress_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += nodeAddress_.CalculateSize(_repeated_nodeAddress_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(NodeAddressBook other) {
      if (other == null) {
        return;
      }
      nodeAddress_.Add(other.nodeAddress_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            nodeAddress_.AddEntriesFrom(input, _repeated_nodeAddress_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            nodeAddress_.AddEntriesFrom(ref input, _repeated_nodeAddress_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// A software version according to "[semantic versioning](https://semver.org/)"
  /// or "date versioning".
  ///
  /// Hedera currently modifies the "typical" semantic versioning somewhat, the
  /// `major` version is always `0`, and each release increments the `minor`
  /// version. The `patch` and `pre` components are used in the typical manner.
  /// The `build` component is not generally used.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class SemanticVersion : pb::IMessage<SemanticVersion>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<SemanticVersion> _parser = new pb::MessageParser<SemanticVersion>(() => new SemanticVersion());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<SemanticVersion> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Proto.BasicTypesReflection.Descriptor.MessageTypes[35]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SemanticVersion() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SemanticVersion(SemanticVersion other) : this() {
      major_ = other.major_;
      minor_ = other.minor_;
      patch_ = other.patch_;
      pre_ = other.pre_;
      build_ = other.build_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SemanticVersion Clone() {
      return new SemanticVersion(this);
    }

    /// <summary>Field number for the "major" field.</summary>
    public const int MajorFieldNumber = 1;
    private int major_;
    /// <summary>
    ///*
    /// A major version.&lt;br/>
    /// Hedera does not increment this value and retains a `0` value to
    /// indicate that API may change for any release.
    /// &lt;p>
    /// This value SHALL increment for an incompatible API change.&lt;br/>
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int Major {
      get { return major_; }
      set {
        major_ = value;
      }
    }

    /// <summary>Field number for the "minor" field.</summary>
    public const int MinorFieldNumber = 2;
    private int minor_;
    /// <summary>
    ///*
    /// A minor version.&lt;br/>
    /// Hedera increments this value with each release.&lt;br/>
    /// There may be incompatible API changes in any Hedera Services release.
    /// &lt;p>
    /// This value SHALL increment for backwards-compatible new
    /// functionality.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int Minor {
      get { return minor_; }
      set {
        minor_ = value;
      }
    }

    /// <summary>Field number for the "patch" field.</summary>
    public const int PatchFieldNumber = 3;
    private int patch_;
    /// <summary>
    ///*
    /// A patch version.
    /// &lt;p>
    /// This value SHALL increment for backwards-compatible bug fixes.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int Patch {
      get { return patch_; }
      set {
        patch_ = value;
      }
    }

    /// <summary>Field number for the "pre" field.</summary>
    public const int PreFieldNumber = 4;
    private string pre_ = "";
    /// <summary>
    ///*
    /// A pre-release version.
    /// &lt;p>
    /// This MAY be denoted by appending a hyphen and a series of dot separated
    /// identifiers per [Semver Specification](https://semver.org/#spec-item-9);
    /// given a string `0.14.0-alpha.1+21AF26D3`, this field would contain
    /// 'alpha.1'
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Pre {
      get { return pre_; }
      set {
        pre_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "build" field.</summary>
    public const int BuildFieldNumber = 5;
    private string build_ = "";
    /// <summary>
    ///*
    /// A build version.
    /// &lt;p>
    /// Build version MAY be denoted by appending a plus sign and a series of
    /// dot separated identifiers immediately following the patch or pre-release
    /// version per [Semver Specification](https://semver.org/#spec-item-10); so
    /// given a string `0.14.0-alpha.1+21AF26D3`, this field
    /// would contain '21AF26D3'
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Build {
      get { return build_; }
      set {
        build_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as SemanticVersion);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(SemanticVersion other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Major != other.Major) return false;
      if (Minor != other.Minor) return false;
      if (Patch != other.Patch) return false;
      if (Pre != other.Pre) return false;
      if (Build != other.Build) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Major != 0) hash ^= Major.GetHashCode();
      if (Minor != 0) hash ^= Minor.GetHashCode();
      if (Patch != 0) hash ^= Patch.GetHashCode();
      if (Pre.Length != 0) hash ^= Pre.GetHashCode();
      if (Build.Length != 0) hash ^= Build.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Major != 0) {
        output.WriteRawTag(8);
        output.WriteInt32(Major);
      }
      if (Minor != 0) {
        output.WriteRawTag(16);
        output.WriteInt32(Minor);
      }
      if (Patch != 0) {
        output.WriteRawTag(24);
        output.WriteInt32(Patch);
      }
      if (Pre.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(Pre);
      }
      if (Build.Length != 0) {
        output.WriteRawTag(42);
        output.WriteString(Build);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Major != 0) {
        output.WriteRawTag(8);
        output.WriteInt32(Major);
      }
      if (Minor != 0) {
        output.WriteRawTag(16);
        output.WriteInt32(Minor);
      }
      if (Patch != 0) {
        output.WriteRawTag(24);
        output.WriteInt32(Patch);
      }
      if (Pre.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(Pre);
      }
      if (Build.Length != 0) {
        output.WriteRawTag(42);
        output.WriteString(Build);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Major != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(Major);
      }
      if (Minor != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(Minor);
      }
      if (Patch != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(Patch);
      }
      if (Pre.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Pre);
      }
      if (Build.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Build);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(SemanticVersion other) {
      if (other == null) {
        return;
      }
      if (other.Major != 0) {
        Major = other.Major;
      }
      if (other.Minor != 0) {
        Minor = other.Minor;
      }
      if (other.Patch != 0) {
        Patch = other.Patch;
      }
      if (other.Pre.Length != 0) {
        Pre = other.Pre;
      }
      if (other.Build.Length != 0) {
        Build = other.Build;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Major = input.ReadInt32();
            break;
          }
          case 16: {
            Minor = input.ReadInt32();
            break;
          }
          case 24: {
            Patch = input.ReadInt32();
            break;
          }
          case 34: {
            Pre = input.ReadString();
            break;
          }
          case 42: {
            Build = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Major = input.ReadInt32();
            break;
          }
          case 16: {
            Minor = input.ReadInt32();
            break;
          }
          case 24: {
            Patch = input.ReadInt32();
            break;
          }
          case 34: {
            Pre = input.ReadString();
            break;
          }
          case 42: {
            Build = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// A single runtime configuration setting.
  ///
  /// Typically a name-value pair, this may also contain a small amount of
  /// associated data.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class Setting : pb::IMessage<Setting>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Setting> _parser = new pb::MessageParser<Setting>(() => new Setting());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Setting> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Proto.BasicTypesReflection.Descriptor.MessageTypes[36]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Setting() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Setting(Setting other) : this() {
      name_ = other.name_;
      value_ = other.value_;
      data_ = other.data_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Setting Clone() {
      return new Setting(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    ///*
    /// A name for this setting property.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "value" field.</summary>
    public const int ValueFieldNumber = 2;
    private string value_ = "";
    /// <summary>
    ///*
    /// A value for this setting property.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Value {
      get { return value_; }
      set {
        value_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "data" field.</summary>
    public const int DataFieldNumber = 3;
    private pb::ByteString data_ = pb::ByteString.Empty;
    /// <summary>
    ///*
    /// A small quantity of data associated with this setting.
    /// &lt;p>
    /// This SHOULD be less than 100 bytes.&lt;br/>
    /// If the value is a string, it MUST be encoded UTF-8.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString Data {
      get { return data_; }
      set {
        data_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Setting);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Setting other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (Value != other.Value) return false;
      if (Data != other.Data) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (Value.Length != 0) hash ^= Value.GetHashCode();
      if (Data.Length != 0) hash ^= Data.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (Value.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Value);
      }
      if (Data.Length != 0) {
        output.WriteRawTag(26);
        output.WriteBytes(Data);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (Value.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Value);
      }
      if (Data.Length != 0) {
        output.WriteRawTag(26);
        output.WriteBytes(Data);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (Value.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Value);
      }
      if (Data.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Data);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Setting other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.Value.Length != 0) {
        Value = other.Value;
      }
      if (other.Data.Length != 0) {
        Data = other.Data;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            Value = input.ReadString();
            break;
          }
          case 26: {
            Data = input.ReadBytes();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            Value = input.ReadString();
            break;
          }
          case 26: {
            Data = input.ReadBytes();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// Setting values representing a source of runtime configuration information.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class ServicesConfigurationList : pb::IMessage<ServicesConfigurationList>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ServicesConfigurationList> _parser = new pb::MessageParser<ServicesConfigurationList>(() => new ServicesConfigurationList());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ServicesConfigurationList> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Proto.BasicTypesReflection.Descriptor.MessageTypes[37]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ServicesConfigurationList() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ServicesConfigurationList(ServicesConfigurationList other) : this() {
      nameValue_ = other.nameValue_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ServicesConfigurationList Clone() {
      return new ServicesConfigurationList(this);
    }

    /// <summary>Field number for the "nameValue" field.</summary>
    public const int NameValueFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Proto.Setting> _repeated_nameValue_codec
        = pb::FieldCodec.ForMessage(10, global::Proto.Setting.Parser);
    private readonly pbc::RepeatedField<global::Proto.Setting> nameValue_ = new pbc::RepeatedField<global::Proto.Setting>();
    /// <summary>
    ///*
    /// A List of `Setting` values, typically read from application properties.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Proto.Setting> NameValue {
      get { return nameValue_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ServicesConfigurationList);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ServicesConfigurationList other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!nameValue_.Equals(other.nameValue_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= nameValue_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      nameValue_.WriteTo(output, _repeated_nameValue_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      nameValue_.WriteTo(ref output, _repeated_nameValue_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += nameValue_.CalculateSize(_repeated_nameValue_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ServicesConfigurationList other) {
      if (other == null) {
        return;
      }
      nameValue_.Add(other.nameValue_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            nameValue_.AddEntriesFrom(input, _repeated_nameValue_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            nameValue_.AddEntriesFrom(ref input, _repeated_nameValue_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// An Hedera Token Service token relationship. A token relationship describes
  /// the connection between an Account and a Token type, including the current
  /// account balance in that token.
  ///
  /// A `TokenRelationship` SHALL contain, for the designated token and enclosing
  /// account, The account's current balance, whether the account has KYC granted,
  /// whether the assets are frozen and whether the association was automatic.&lt;br/>
  /// A `TokenRelationship` MAY also contain the `symbol` and `decimals` values
  /// copied from the token.&lt;br/>
  /// `TokenRelationship` entries SHALL be valid only within the context of a
  /// `GetAccountDetails` query response, or other enclosing message, which
  /// specifies the account side of the relationship.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class TokenRelationship : pb::IMessage<TokenRelationship>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<TokenRelationship> _parser = new pb::MessageParser<TokenRelationship>(() => new TokenRelationship());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<TokenRelationship> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Proto.BasicTypesReflection.Descriptor.MessageTypes[38]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TokenRelationship() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TokenRelationship(TokenRelationship other) : this() {
      tokenId_ = other.tokenId_ != null ? other.tokenId_.Clone() : null;
      symbol_ = other.symbol_;
      balance_ = other.balance_;
      kycStatus_ = other.kycStatus_;
      freezeStatus_ = other.freezeStatus_;
      decimals_ = other.decimals_;
      automaticAssociation_ = other.automaticAssociation_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TokenRelationship Clone() {
      return new TokenRelationship(this);
    }

    /// <summary>Field number for the "tokenId" field.</summary>
    public const int TokenIdFieldNumber = 1;
    private global::Proto.TokenID tokenId_;
    /// <summary>
    ///*
    /// A token identifier.
    /// &lt;p>
    /// This MUST match an existing token that is not deleted.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.TokenID TokenId {
      get { return tokenId_; }
      set {
        tokenId_ = value;
      }
    }

    /// <summary>Field number for the "symbol" field.</summary>
    public const int SymbolFieldNumber = 2;
    private string symbol_ = "";
    /// <summary>
    ///*
    /// A token symbol.
    /// &lt;p>
    /// This MUST match an existing token that is not deleted.&lt;br/>
    /// This MUST match the value for the token identified in `tokenId`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Symbol {
      get { return symbol_; }
      set {
        symbol_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "balance" field.</summary>
    public const int BalanceFieldNumber = 3;
    private ulong balance_;
    /// <summary>
    ///*
    /// An account balance for this token.
    /// &lt;p>
    /// For fungible/common tokens this SHALL be the balance that the
    /// account holds of that token. The value is provided as an integer amount
    /// of the smallest unit of the token (i.e. 10&lt;sup>`-decimals`&lt;/sup> whole
    /// tokens).&lt;br/>
    /// For non-fungible/unique tokens this SHALL be the whole number of
    /// unique tokens held by the account for this token type.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ulong Balance {
      get { return balance_; }
      set {
        balance_ = value;
      }
    }

    /// <summary>Field number for the "kycStatus" field.</summary>
    public const int KycStatusFieldNumber = 4;
    private global::Proto.TokenKycStatus kycStatus_ = global::Proto.TokenKycStatus.KycNotApplicable;
    /// <summary>
    ///*
    /// A KYC status for the account with respect to this token.
    /// &lt;p>
    /// This may be `KycNotApplicable`, `Granted` or `Revoked` and, if KYC is
    /// not supported for this token (e.g. the `kyc_key` of the token is not
    /// set), this SHALL be `KycNotApplicable`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.TokenKycStatus KycStatus {
      get { return kycStatus_; }
      set {
        kycStatus_ = value;
      }
    }

    /// <summary>Field number for the "freezeStatus" field.</summary>
    public const int FreezeStatusFieldNumber = 5;
    private global::Proto.TokenFreezeStatus freezeStatus_ = global::Proto.TokenFreezeStatus.FreezeNotApplicable;
    /// <summary>
    ///*
    /// A Freeze status for the account with respect to this token.
    /// &lt;p>
    /// This value SHALL be one of `FreezeNotApplicable`, `Frozen`
    /// or `Unfrozen`.&lt;br/>
    /// If the token cannot freeze account assets (e.g. the `freeze_key` of the
    /// token is not set), this SHALL be `FreezeNotApplicable`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.TokenFreezeStatus FreezeStatus {
      get { return freezeStatus_; }
      set {
        freezeStatus_ = value;
      }
    }

    /// <summary>Field number for the "decimals" field.</summary>
    public const int DecimalsFieldNumber = 6;
    private uint decimals_;
    /// <summary>
    ///*
    /// A maximum "precision" for this token.
    /// &lt;p>
    /// This value MUST match the `decimals` field of the token identified in
    /// the `tokenId` field.&lt;br/>
    /// A single whole token SHALL be divided into at most
    /// 10&lt;sup>`decimals`&lt;/sup> sub-units.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint Decimals {
      get { return decimals_; }
      set {
        decimals_ = value;
      }
    }

    /// <summary>Field number for the "automatic_association" field.</summary>
    public const int AutomaticAssociationFieldNumber = 7;
    private bool automaticAssociation_;
    /// <summary>
    ///*
    /// An automatic association flag.
    /// &lt;p>
    /// This SHALL be set if the relationship was created implicitly
    /// (automatically).&lt;br/>
    /// This SHALL be unset if the relationship was created explicitly
    /// (manually) via a `TokenAssociate` transaction.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool AutomaticAssociation {
      get { return automaticAssociation_; }
      set {
        automaticAssociation_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as TokenRelationship);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(TokenRelationship other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(TokenId, other.TokenId)) return false;
      if (Symbol != other.Symbol) return false;
      if (Balance != other.Balance) return false;
      if (KycStatus != other.KycStatus) return false;
      if (FreezeStatus != other.FreezeStatus) return false;
      if (Decimals != other.Decimals) return false;
      if (AutomaticAssociation != other.AutomaticAssociation) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (tokenId_ != null) hash ^= TokenId.GetHashCode();
      if (Symbol.Length != 0) hash ^= Symbol.GetHashCode();
      if (Balance != 0UL) hash ^= Balance.GetHashCode();
      if (KycStatus != global::Proto.TokenKycStatus.KycNotApplicable) hash ^= KycStatus.GetHashCode();
      if (FreezeStatus != global::Proto.TokenFreezeStatus.FreezeNotApplicable) hash ^= FreezeStatus.GetHashCode();
      if (Decimals != 0) hash ^= Decimals.GetHashCode();
      if (AutomaticAssociation != false) hash ^= AutomaticAssociation.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (tokenId_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(TokenId);
      }
      if (Symbol.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Symbol);
      }
      if (Balance != 0UL) {
        output.WriteRawTag(24);
        output.WriteUInt64(Balance);
      }
      if (KycStatus != global::Proto.TokenKycStatus.KycNotApplicable) {
        output.WriteRawTag(32);
        output.WriteEnum((int) KycStatus);
      }
      if (FreezeStatus != global::Proto.TokenFreezeStatus.FreezeNotApplicable) {
        output.WriteRawTag(40);
        output.WriteEnum((int) FreezeStatus);
      }
      if (Decimals != 0) {
        output.WriteRawTag(48);
        output.WriteUInt32(Decimals);
      }
      if (AutomaticAssociation != false) {
        output.WriteRawTag(56);
        output.WriteBool(AutomaticAssociation);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (tokenId_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(TokenId);
      }
      if (Symbol.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Symbol);
      }
      if (Balance != 0UL) {
        output.WriteRawTag(24);
        output.WriteUInt64(Balance);
      }
      if (KycStatus != global::Proto.TokenKycStatus.KycNotApplicable) {
        output.WriteRawTag(32);
        output.WriteEnum((int) KycStatus);
      }
      if (FreezeStatus != global::Proto.TokenFreezeStatus.FreezeNotApplicable) {
        output.WriteRawTag(40);
        output.WriteEnum((int) FreezeStatus);
      }
      if (Decimals != 0) {
        output.WriteRawTag(48);
        output.WriteUInt32(Decimals);
      }
      if (AutomaticAssociation != false) {
        output.WriteRawTag(56);
        output.WriteBool(AutomaticAssociation);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (tokenId_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TokenId);
      }
      if (Symbol.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Symbol);
      }
      if (Balance != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(Balance);
      }
      if (KycStatus != global::Proto.TokenKycStatus.KycNotApplicable) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) KycStatus);
      }
      if (FreezeStatus != global::Proto.TokenFreezeStatus.FreezeNotApplicable) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) FreezeStatus);
      }
      if (Decimals != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Decimals);
      }
      if (AutomaticAssociation != false) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(TokenRelationship other) {
      if (other == null) {
        return;
      }
      if (other.tokenId_ != null) {
        if (tokenId_ == null) {
          TokenId = new global::Proto.TokenID();
        }
        TokenId.MergeFrom(other.TokenId);
      }
      if (other.Symbol.Length != 0) {
        Symbol = other.Symbol;
      }
      if (other.Balance != 0UL) {
        Balance = other.Balance;
      }
      if (other.KycStatus != global::Proto.TokenKycStatus.KycNotApplicable) {
        KycStatus = other.KycStatus;
      }
      if (other.FreezeStatus != global::Proto.TokenFreezeStatus.FreezeNotApplicable) {
        FreezeStatus = other.FreezeStatus;
      }
      if (other.Decimals != 0) {
        Decimals = other.Decimals;
      }
      if (other.AutomaticAssociation != false) {
        AutomaticAssociation = other.AutomaticAssociation;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (tokenId_ == null) {
              TokenId = new global::Proto.TokenID();
            }
            input.ReadMessage(TokenId);
            break;
          }
          case 18: {
            Symbol = input.ReadString();
            break;
          }
          case 24: {
            Balance = input.ReadUInt64();
            break;
          }
          case 32: {
            KycStatus = (global::Proto.TokenKycStatus) input.ReadEnum();
            break;
          }
          case 40: {
            FreezeStatus = (global::Proto.TokenFreezeStatus) input.ReadEnum();
            break;
          }
          case 48: {
            Decimals = input.ReadUInt32();
            break;
          }
          case 56: {
            AutomaticAssociation = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (tokenId_ == null) {
              TokenId = new global::Proto.TokenID();
            }
            input.ReadMessage(TokenId);
            break;
          }
          case 18: {
            Symbol = input.ReadString();
            break;
          }
          case 24: {
            Balance = input.ReadUInt64();
            break;
          }
          case 32: {
            KycStatus = (global::Proto.TokenKycStatus) input.ReadEnum();
            break;
          }
          case 40: {
            FreezeStatus = (global::Proto.TokenFreezeStatus) input.ReadEnum();
            break;
          }
          case 48: {
            Decimals = input.ReadUInt32();
            break;
          }
          case 56: {
            AutomaticAssociation = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// A number of _transferable units_ of a specified token.
  ///
  /// The transferable unit of a token is its smallest denomination, as given by
  /// the token's `decimals` property. Each minted token contains
  /// 10&lt;sup>`decimals`&lt;/sup> transferable units. For example, we could think of
  /// the cent as the transferable unit of the US dollar (`decimals=2`); and the
  /// tinybar as the transferable unit of HBAR (`decimals=8`).
  ///
  /// Transferable units are not directly comparable across different tokens.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class TokenBalance : pb::IMessage<TokenBalance>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<TokenBalance> _parser = new pb::MessageParser<TokenBalance>(() => new TokenBalance());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<TokenBalance> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Proto.BasicTypesReflection.Descriptor.MessageTypes[39]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TokenBalance() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TokenBalance(TokenBalance other) : this() {
      tokenId_ = other.tokenId_ != null ? other.tokenId_.Clone() : null;
      balance_ = other.balance_;
      decimals_ = other.decimals_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TokenBalance Clone() {
      return new TokenBalance(this);
    }

    /// <summary>Field number for the "tokenId" field.</summary>
    public const int TokenIdFieldNumber = 1;
    private global::Proto.TokenID tokenId_;
    /// <summary>
    ///*
    /// A token identifier.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.TokenID TokenId {
      get { return tokenId_; }
      set {
        tokenId_ = value;
      }
    }

    /// <summary>Field number for the "balance" field.</summary>
    public const int BalanceFieldNumber = 2;
    private ulong balance_;
    /// <summary>
    ///*
    /// A number of transferable units of the identified token.
    /// &lt;p>
    /// For fungible/common tokens this SHALL be the balance, in units of
    /// 10&lt;sup>`-decimals`&lt;/sup> whole tokens.&lt;br/>
    /// For non-fungible/unique tokens, this SHALL be the number of
    /// individual unique tokens in this balance.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ulong Balance {
      get { return balance_; }
      set {
        balance_ = value;
      }
    }

    /// <summary>Field number for the "decimals" field.</summary>
    public const int DecimalsFieldNumber = 3;
    private uint decimals_;
    /// <summary>
    ///*
    /// A number of "decimals" precision.
    /// &lt;p>
    /// This MUST match the `decimals` value for the token identified by the
    /// `tokenId` field.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint Decimals {
      get { return decimals_; }
      set {
        decimals_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as TokenBalance);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(TokenBalance other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(TokenId, other.TokenId)) return false;
      if (Balance != other.Balance) return false;
      if (Decimals != other.Decimals) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (tokenId_ != null) hash ^= TokenId.GetHashCode();
      if (Balance != 0UL) hash ^= Balance.GetHashCode();
      if (Decimals != 0) hash ^= Decimals.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (tokenId_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(TokenId);
      }
      if (Balance != 0UL) {
        output.WriteRawTag(16);
        output.WriteUInt64(Balance);
      }
      if (Decimals != 0) {
        output.WriteRawTag(24);
        output.WriteUInt32(Decimals);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (tokenId_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(TokenId);
      }
      if (Balance != 0UL) {
        output.WriteRawTag(16);
        output.WriteUInt64(Balance);
      }
      if (Decimals != 0) {
        output.WriteRawTag(24);
        output.WriteUInt32(Decimals);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (tokenId_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TokenId);
      }
      if (Balance != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(Balance);
      }
      if (Decimals != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Decimals);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(TokenBalance other) {
      if (other == null) {
        return;
      }
      if (other.tokenId_ != null) {
        if (tokenId_ == null) {
          TokenId = new global::Proto.TokenID();
        }
        TokenId.MergeFrom(other.TokenId);
      }
      if (other.Balance != 0UL) {
        Balance = other.Balance;
      }
      if (other.Decimals != 0) {
        Decimals = other.Decimals;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (tokenId_ == null) {
              TokenId = new global::Proto.TokenID();
            }
            input.ReadMessage(TokenId);
            break;
          }
          case 16: {
            Balance = input.ReadUInt64();
            break;
          }
          case 24: {
            Decimals = input.ReadUInt32();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (tokenId_ == null) {
              TokenId = new global::Proto.TokenID();
            }
            input.ReadMessage(TokenId);
            break;
          }
          case 16: {
            Balance = input.ReadUInt64();
            break;
          }
          case 24: {
            Decimals = input.ReadUInt32();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// A set of token balance values.
  ///
  /// Each entry describes the balance the enclosing account holds for a specific
  /// token. The balance is an amount for a fungible/common token or a count for
  /// a non-fungible/unique token.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class TokenBalances : pb::IMessage<TokenBalances>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<TokenBalances> _parser = new pb::MessageParser<TokenBalances>(() => new TokenBalances());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<TokenBalances> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Proto.BasicTypesReflection.Descriptor.MessageTypes[40]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TokenBalances() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TokenBalances(TokenBalances other) : this() {
      tokenBalances_ = other.tokenBalances_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TokenBalances Clone() {
      return new TokenBalances(this);
    }

    /// <summary>Field number for the "tokenBalances" field.</summary>
    public const int TokenBalances_FieldNumber = 1;
    private static readonly pb::FieldCodec<global::Proto.TokenBalance> _repeated_tokenBalances_codec
        = pb::FieldCodec.ForMessage(10, global::Proto.TokenBalance.Parser);
    private readonly pbc::RepeatedField<global::Proto.TokenBalance> tokenBalances_ = new pbc::RepeatedField<global::Proto.TokenBalance>();
    /// <summary>
    ///*
    /// A list of token balance values.&lt;br/>
    /// Each entry represents a single account balance for a single token.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Proto.TokenBalance> TokenBalances_ {
      get { return tokenBalances_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as TokenBalances);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(TokenBalances other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!tokenBalances_.Equals(other.tokenBalances_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= tokenBalances_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      tokenBalances_.WriteTo(output, _repeated_tokenBalances_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      tokenBalances_.WriteTo(ref output, _repeated_tokenBalances_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += tokenBalances_.CalculateSize(_repeated_tokenBalances_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(TokenBalances other) {
      if (other == null) {
        return;
      }
      tokenBalances_.Add(other.tokenBalances_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            tokenBalances_.AddEntriesFrom(input, _repeated_tokenBalances_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            tokenBalances_.AddEntriesFrom(ref input, _repeated_tokenBalances_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// An association between a token and an account.
  ///
  /// An account must be associated with a token before that account can transact
  /// in (send or receive) that token.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class TokenAssociation : pb::IMessage<TokenAssociation>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<TokenAssociation> _parser = new pb::MessageParser<TokenAssociation>(() => new TokenAssociation());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<TokenAssociation> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Proto.BasicTypesReflection.Descriptor.MessageTypes[41]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TokenAssociation() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TokenAssociation(TokenAssociation other) : this() {
      tokenId_ = other.tokenId_ != null ? other.tokenId_.Clone() : null;
      accountId_ = other.accountId_ != null ? other.accountId_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TokenAssociation Clone() {
      return new TokenAssociation(this);
    }

    /// <summary>Field number for the "token_id" field.</summary>
    public const int TokenIdFieldNumber = 1;
    private global::Proto.TokenID tokenId_;
    /// <summary>
    ///*
    /// A token identifier for the associated token.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.TokenID TokenId {
      get { return tokenId_; }
      set {
        tokenId_ = value;
      }
    }

    /// <summary>Field number for the "account_id" field.</summary>
    public const int AccountIdFieldNumber = 2;
    private global::Proto.AccountID accountId_;
    /// <summary>
    ///*
    /// An account identifier for the associated account.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.AccountID AccountId {
      get { return accountId_; }
      set {
        accountId_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as TokenAssociation);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(TokenAssociation other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(TokenId, other.TokenId)) return false;
      if (!object.Equals(AccountId, other.AccountId)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (tokenId_ != null) hash ^= TokenId.GetHashCode();
      if (accountId_ != null) hash ^= AccountId.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (tokenId_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(TokenId);
      }
      if (accountId_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(AccountId);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (tokenId_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(TokenId);
      }
      if (accountId_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(AccountId);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (tokenId_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TokenId);
      }
      if (accountId_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(AccountId);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(TokenAssociation other) {
      if (other == null) {
        return;
      }
      if (other.tokenId_ != null) {
        if (tokenId_ == null) {
          TokenId = new global::Proto.TokenID();
        }
        TokenId.MergeFrom(other.TokenId);
      }
      if (other.accountId_ != null) {
        if (accountId_ == null) {
          AccountId = new global::Proto.AccountID();
        }
        AccountId.MergeFrom(other.AccountId);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (tokenId_ == null) {
              TokenId = new global::Proto.TokenID();
            }
            input.ReadMessage(TokenId);
            break;
          }
          case 18: {
            if (accountId_ == null) {
              AccountId = new global::Proto.AccountID();
            }
            input.ReadMessage(AccountId);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (tokenId_ == null) {
              TokenId = new global::Proto.TokenID();
            }
            input.ReadMessage(TokenId);
            break;
          }
          case 18: {
            if (accountId_ == null) {
              AccountId = new global::Proto.AccountID();
            }
            input.ReadMessage(AccountId);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// Staking information for an account or a contract.
  ///
  /// This is used for responses returned from `CryptoGetInfo` or
  /// `ContractGetInfo` queries.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class StakingInfo : pb::IMessage<StakingInfo>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<StakingInfo> _parser = new pb::MessageParser<StakingInfo>(() => new StakingInfo());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<StakingInfo> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Proto.BasicTypesReflection.Descriptor.MessageTypes[42]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public StakingInfo() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public StakingInfo(StakingInfo other) : this() {
      declineReward_ = other.declineReward_;
      stakePeriodStart_ = other.stakePeriodStart_ != null ? other.stakePeriodStart_.Clone() : null;
      pendingReward_ = other.pendingReward_;
      stakedToMe_ = other.stakedToMe_;
      switch (other.StakedIdCase) {
        case StakedIdOneofCase.StakedAccountId:
          StakedAccountId = other.StakedAccountId.Clone();
          break;
        case StakedIdOneofCase.StakedNodeId:
          StakedNodeId = other.StakedNodeId;
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public StakingInfo Clone() {
      return new StakingInfo(this);
    }

    /// <summary>Field number for the "decline_reward" field.</summary>
    public const int DeclineRewardFieldNumber = 1;
    private bool declineReward_;
    /// <summary>
    ///*
    /// A flag indicating that the holder of this account has chosen to decline
    /// staking rewards.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool DeclineReward {
      get { return declineReward_; }
      set {
        declineReward_ = value;
      }
    }

    /// <summary>Field number for the "stake_period_start" field.</summary>
    public const int StakePeriodStartFieldNumber = 2;
    private global::Proto.Timestamp stakePeriodStart_;
    /// <summary>
    ///*
    /// A `Timestamp` of the start time for the latest active staking period.
    /// &lt;p>
    /// This MUST be a period during which either the staking settings for this
    /// account or contract changed or the account or contract received staking
    /// rewards, whichever is later. Examples of a change in staking settings
    /// include starting staking or changing the staked_node_id.&lt;br/>
    /// If this account or contract is not currently staked to a node, then this
    /// field SHALL NOT be set.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.Timestamp StakePeriodStart {
      get { return stakePeriodStart_; }
      set {
        stakePeriodStart_ = value;
      }
    }

    /// <summary>Field number for the "pending_reward" field.</summary>
    public const int PendingRewardFieldNumber = 3;
    private long pendingReward_;
    /// <summary>
    ///*
    /// An amount, in tinybar, to be received in the next reward payout.&lt;br/>
    /// Rewards are not paid out immediately; for efficiency reasons rewards are
    /// only paid out as part of another transaction involving that account.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long PendingReward {
      get { return pendingReward_; }
      set {
        pendingReward_ = value;
      }
    }

    /// <summary>Field number for the "staked_to_me" field.</summary>
    public const int StakedToMeFieldNumber = 4;
    private long stakedToMe_;
    /// <summary>
    ///*
    /// A proxy-staked balance.&lt;br/>
    /// The total HBAR balance of all accounts that delegate staking to this
    /// account or contract.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long StakedToMe {
      get { return stakedToMe_; }
      set {
        stakedToMe_ = value;
      }
    }

    /// <summary>Field number for the "staked_account_id" field.</summary>
    public const int StakedAccountIdFieldNumber = 5;
    /// <summary>
    ///*
    /// A delegated stake.
    /// &lt;p>
    /// This account delegates to the indicated account for staking purposes.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.AccountID StakedAccountId {
      get { return stakedIdCase_ == StakedIdOneofCase.StakedAccountId ? (global::Proto.AccountID) stakedId_ : null; }
      set {
        stakedId_ = value;
        stakedIdCase_ = value == null ? StakedIdOneofCase.None : StakedIdOneofCase.StakedAccountId;
      }
    }

    /// <summary>Field number for the "staked_node_id" field.</summary>
    public const int StakedNodeIdFieldNumber = 6;
    /// <summary>
    ///*
    /// A direct stake.
    /// &lt;p>
    /// This accounts stakes its balance to the designated node.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long StakedNodeId {
      get { return HasStakedNodeId ? (long) stakedId_ : 0L; }
      set {
        stakedId_ = value;
        stakedIdCase_ = StakedIdOneofCase.StakedNodeId;
      }
    }
    /// <summary>Gets whether the "staked_node_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasStakedNodeId {
      get { return stakedIdCase_ == StakedIdOneofCase.StakedNodeId; }
    }
    /// <summary> Clears the value of the oneof if it's currently set to "staked_node_id" </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearStakedNodeId() {
      if (HasStakedNodeId) {
        ClearStakedId();
      }
    }

    private object stakedId_;
    /// <summary>Enum of possible cases for the "staked_id" oneof.</summary>
    public enum StakedIdOneofCase {
      None = 0,
      StakedAccountId = 5,
      StakedNodeId = 6,
    }
    private StakedIdOneofCase stakedIdCase_ = StakedIdOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public StakedIdOneofCase StakedIdCase {
      get { return stakedIdCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearStakedId() {
      stakedIdCase_ = StakedIdOneofCase.None;
      stakedId_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as StakingInfo);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(StakingInfo other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (DeclineReward != other.DeclineReward) return false;
      if (!object.Equals(StakePeriodStart, other.StakePeriodStart)) return false;
      if (PendingReward != other.PendingReward) return false;
      if (StakedToMe != other.StakedToMe) return false;
      if (!object.Equals(StakedAccountId, other.StakedAccountId)) return false;
      if (StakedNodeId != other.StakedNodeId) return false;
      if (StakedIdCase != other.StakedIdCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (DeclineReward != false) hash ^= DeclineReward.GetHashCode();
      if (stakePeriodStart_ != null) hash ^= StakePeriodStart.GetHashCode();
      if (PendingReward != 0L) hash ^= PendingReward.GetHashCode();
      if (StakedToMe != 0L) hash ^= StakedToMe.GetHashCode();
      if (stakedIdCase_ == StakedIdOneofCase.StakedAccountId) hash ^= StakedAccountId.GetHashCode();
      if (HasStakedNodeId) hash ^= StakedNodeId.GetHashCode();
      hash ^= (int) stakedIdCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (DeclineReward != false) {
        output.WriteRawTag(8);
        output.WriteBool(DeclineReward);
      }
      if (stakePeriodStart_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(StakePeriodStart);
      }
      if (PendingReward != 0L) {
        output.WriteRawTag(24);
        output.WriteInt64(PendingReward);
      }
      if (StakedToMe != 0L) {
        output.WriteRawTag(32);
        output.WriteInt64(StakedToMe);
      }
      if (stakedIdCase_ == StakedIdOneofCase.StakedAccountId) {
        output.WriteRawTag(42);
        output.WriteMessage(StakedAccountId);
      }
      if (HasStakedNodeId) {
        output.WriteRawTag(48);
        output.WriteInt64(StakedNodeId);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (DeclineReward != false) {
        output.WriteRawTag(8);
        output.WriteBool(DeclineReward);
      }
      if (stakePeriodStart_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(StakePeriodStart);
      }
      if (PendingReward != 0L) {
        output.WriteRawTag(24);
        output.WriteInt64(PendingReward);
      }
      if (StakedToMe != 0L) {
        output.WriteRawTag(32);
        output.WriteInt64(StakedToMe);
      }
      if (stakedIdCase_ == StakedIdOneofCase.StakedAccountId) {
        output.WriteRawTag(42);
        output.WriteMessage(StakedAccountId);
      }
      if (HasStakedNodeId) {
        output.WriteRawTag(48);
        output.WriteInt64(StakedNodeId);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (DeclineReward != false) {
        size += 1 + 1;
      }
      if (stakePeriodStart_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(StakePeriodStart);
      }
      if (PendingReward != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(PendingReward);
      }
      if (StakedToMe != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(StakedToMe);
      }
      if (stakedIdCase_ == StakedIdOneofCase.StakedAccountId) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(StakedAccountId);
      }
      if (HasStakedNodeId) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(StakedNodeId);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(StakingInfo other) {
      if (other == null) {
        return;
      }
      if (other.DeclineReward != false) {
        DeclineReward = other.DeclineReward;
      }
      if (other.stakePeriodStart_ != null) {
        if (stakePeriodStart_ == null) {
          StakePeriodStart = new global::Proto.Timestamp();
        }
        StakePeriodStart.MergeFrom(other.StakePeriodStart);
      }
      if (other.PendingReward != 0L) {
        PendingReward = other.PendingReward;
      }
      if (other.StakedToMe != 0L) {
        StakedToMe = other.StakedToMe;
      }
      switch (other.StakedIdCase) {
        case StakedIdOneofCase.StakedAccountId:
          if (StakedAccountId == null) {
            StakedAccountId = new global::Proto.AccountID();
          }
          StakedAccountId.MergeFrom(other.StakedAccountId);
          break;
        case StakedIdOneofCase.StakedNodeId:
          StakedNodeId = other.StakedNodeId;
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            DeclineReward = input.ReadBool();
            break;
          }
          case 18: {
            if (stakePeriodStart_ == null) {
              StakePeriodStart = new global::Proto.Timestamp();
            }
            input.ReadMessage(StakePeriodStart);
            break;
          }
          case 24: {
            PendingReward = input.ReadInt64();
            break;
          }
          case 32: {
            StakedToMe = input.ReadInt64();
            break;
          }
          case 42: {
            global::Proto.AccountID subBuilder = new global::Proto.AccountID();
            if (stakedIdCase_ == StakedIdOneofCase.StakedAccountId) {
              subBuilder.MergeFrom(StakedAccountId);
            }
            input.ReadMessage(subBuilder);
            StakedAccountId = subBuilder;
            break;
          }
          case 48: {
            StakedNodeId = input.ReadInt64();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            DeclineReward = input.ReadBool();
            break;
          }
          case 18: {
            if (stakePeriodStart_ == null) {
              StakePeriodStart = new global::Proto.Timestamp();
            }
            input.ReadMessage(StakePeriodStart);
            break;
          }
          case 24: {
            PendingReward = input.ReadInt64();
            break;
          }
          case 32: {
            StakedToMe = input.ReadInt64();
            break;
          }
          case 42: {
            global::Proto.AccountID subBuilder = new global::Proto.AccountID();
            if (stakedIdCase_ == StakedIdOneofCase.StakedAccountId) {
              subBuilder.MergeFrom(StakedAccountId);
            }
            input.ReadMessage(subBuilder);
            StakedAccountId = subBuilder;
            break;
          }
          case 48: {
            StakedNodeId = input.ReadInt64();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// A unique, composite, identifier for a pending airdrop.
  ///
  /// Each pending airdrop SHALL be uniquely identified by
  /// a `PendingAirdropId`.&lt;br/>
  /// A `PendingAirdropId` SHALL be recorded when created and MUST be provided in
  /// any transaction that would modify that pending airdrop
  /// (such as a `claimAirdrop` or `cancelAirdrop`).
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class PendingAirdropId : pb::IMessage<PendingAirdropId>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<PendingAirdropId> _parser = new pb::MessageParser<PendingAirdropId>(() => new PendingAirdropId());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<PendingAirdropId> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Proto.BasicTypesReflection.Descriptor.MessageTypes[43]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PendingAirdropId() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PendingAirdropId(PendingAirdropId other) : this() {
      senderId_ = other.senderId_ != null ? other.senderId_.Clone() : null;
      receiverId_ = other.receiverId_ != null ? other.receiverId_.Clone() : null;
      switch (other.TokenReferenceCase) {
        case TokenReferenceOneofCase.FungibleTokenType:
          FungibleTokenType = other.FungibleTokenType.Clone();
          break;
        case TokenReferenceOneofCase.NonFungibleToken:
          NonFungibleToken = other.NonFungibleToken.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PendingAirdropId Clone() {
      return new PendingAirdropId(this);
    }

    /// <summary>Field number for the "sender_id" field.</summary>
    public const int SenderIdFieldNumber = 1;
    private global::Proto.AccountID senderId_;
    /// <summary>
    ///*
    /// A sending account.
    /// &lt;p>
    /// This is the account that initiated, and SHALL fund,
    /// this pending airdrop.&lt;br/>
    /// This field is REQUIRED.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.AccountID SenderId {
      get { return senderId_; }
      set {
        senderId_ = value;
      }
    }

    /// <summary>Field number for the "receiver_id" field.</summary>
    public const int ReceiverIdFieldNumber = 2;
    private global::Proto.AccountID receiverId_;
    /// <summary>
    ///*
    /// A receiving account.
    /// &lt;p>
    /// This is the ID of the account that SHALL receive the airdrop.&lt;br/>
    /// This field is REQUIRED.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.AccountID ReceiverId {
      get { return receiverId_; }
      set {
        receiverId_ = value;
      }
    }

    /// <summary>Field number for the "fungible_token_type" field.</summary>
    public const int FungibleTokenTypeFieldNumber = 3;
    /// <summary>
    ///*
    /// A token identifier.&lt;br/>
    /// This is the type of token for a fungible/common token airdrop.
    /// &lt;p>
    /// This field is REQUIRED for a fungible/common token and MUST NOT
    /// be used for a non-fungible/unique token.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.TokenID FungibleTokenType {
      get { return tokenReferenceCase_ == TokenReferenceOneofCase.FungibleTokenType ? (global::Proto.TokenID) tokenReference_ : null; }
      set {
        tokenReference_ = value;
        tokenReferenceCase_ = value == null ? TokenReferenceOneofCase.None : TokenReferenceOneofCase.FungibleTokenType;
      }
    }

    /// <summary>Field number for the "non_fungible_token" field.</summary>
    public const int NonFungibleTokenFieldNumber = 4;
    /// <summary>
    ///*
    /// The id of a single NFT&lt;br/>
    /// This is the type of token for a non-fungible/unique token airdrop
    /// and consists of a Token ID and serial number.
    /// &lt;p>
    /// This field is REQUIRED for a non-fungible/unique token and
    /// MUST NOT be used for a fungible/common token.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.NftID NonFungibleToken {
      get { return tokenReferenceCase_ == TokenReferenceOneofCase.NonFungibleToken ? (global::Proto.NftID) tokenReference_ : null; }
      set {
        tokenReference_ = value;
        tokenReferenceCase_ = value == null ? TokenReferenceOneofCase.None : TokenReferenceOneofCase.NonFungibleToken;
      }
    }

    private object tokenReference_;
    /// <summary>Enum of possible cases for the "token_reference" oneof.</summary>
    public enum TokenReferenceOneofCase {
      None = 0,
      FungibleTokenType = 3,
      NonFungibleToken = 4,
    }
    private TokenReferenceOneofCase tokenReferenceCase_ = TokenReferenceOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TokenReferenceOneofCase TokenReferenceCase {
      get { return tokenReferenceCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearTokenReference() {
      tokenReferenceCase_ = TokenReferenceOneofCase.None;
      tokenReference_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as PendingAirdropId);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(PendingAirdropId other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(SenderId, other.SenderId)) return false;
      if (!object.Equals(ReceiverId, other.ReceiverId)) return false;
      if (!object.Equals(FungibleTokenType, other.FungibleTokenType)) return false;
      if (!object.Equals(NonFungibleToken, other.NonFungibleToken)) return false;
      if (TokenReferenceCase != other.TokenReferenceCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (senderId_ != null) hash ^= SenderId.GetHashCode();
      if (receiverId_ != null) hash ^= ReceiverId.GetHashCode();
      if (tokenReferenceCase_ == TokenReferenceOneofCase.FungibleTokenType) hash ^= FungibleTokenType.GetHashCode();
      if (tokenReferenceCase_ == TokenReferenceOneofCase.NonFungibleToken) hash ^= NonFungibleToken.GetHashCode();
      hash ^= (int) tokenReferenceCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (senderId_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(SenderId);
      }
      if (receiverId_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(ReceiverId);
      }
      if (tokenReferenceCase_ == TokenReferenceOneofCase.FungibleTokenType) {
        output.WriteRawTag(26);
        output.WriteMessage(FungibleTokenType);
      }
      if (tokenReferenceCase_ == TokenReferenceOneofCase.NonFungibleToken) {
        output.WriteRawTag(34);
        output.WriteMessage(NonFungibleToken);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (senderId_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(SenderId);
      }
      if (receiverId_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(ReceiverId);
      }
      if (tokenReferenceCase_ == TokenReferenceOneofCase.FungibleTokenType) {
        output.WriteRawTag(26);
        output.WriteMessage(FungibleTokenType);
      }
      if (tokenReferenceCase_ == TokenReferenceOneofCase.NonFungibleToken) {
        output.WriteRawTag(34);
        output.WriteMessage(NonFungibleToken);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (senderId_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SenderId);
      }
      if (receiverId_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ReceiverId);
      }
      if (tokenReferenceCase_ == TokenReferenceOneofCase.FungibleTokenType) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(FungibleTokenType);
      }
      if (tokenReferenceCase_ == TokenReferenceOneofCase.NonFungibleToken) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(NonFungibleToken);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(PendingAirdropId other) {
      if (other == null) {
        return;
      }
      if (other.senderId_ != null) {
        if (senderId_ == null) {
          SenderId = new global::Proto.AccountID();
        }
        SenderId.MergeFrom(other.SenderId);
      }
      if (other.receiverId_ != null) {
        if (receiverId_ == null) {
          ReceiverId = new global::Proto.AccountID();
        }
        ReceiverId.MergeFrom(other.ReceiverId);
      }
      switch (other.TokenReferenceCase) {
        case TokenReferenceOneofCase.FungibleTokenType:
          if (FungibleTokenType == null) {
            FungibleTokenType = new global::Proto.TokenID();
          }
          FungibleTokenType.MergeFrom(other.FungibleTokenType);
          break;
        case TokenReferenceOneofCase.NonFungibleToken:
          if (NonFungibleToken == null) {
            NonFungibleToken = new global::Proto.NftID();
          }
          NonFungibleToken.MergeFrom(other.NonFungibleToken);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (senderId_ == null) {
              SenderId = new global::Proto.AccountID();
            }
            input.ReadMessage(SenderId);
            break;
          }
          case 18: {
            if (receiverId_ == null) {
              ReceiverId = new global::Proto.AccountID();
            }
            input.ReadMessage(ReceiverId);
            break;
          }
          case 26: {
            global::Proto.TokenID subBuilder = new global::Proto.TokenID();
            if (tokenReferenceCase_ == TokenReferenceOneofCase.FungibleTokenType) {
              subBuilder.MergeFrom(FungibleTokenType);
            }
            input.ReadMessage(subBuilder);
            FungibleTokenType = subBuilder;
            break;
          }
          case 34: {
            global::Proto.NftID subBuilder = new global::Proto.NftID();
            if (tokenReferenceCase_ == TokenReferenceOneofCase.NonFungibleToken) {
              subBuilder.MergeFrom(NonFungibleToken);
            }
            input.ReadMessage(subBuilder);
            NonFungibleToken = subBuilder;
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (senderId_ == null) {
              SenderId = new global::Proto.AccountID();
            }
            input.ReadMessage(SenderId);
            break;
          }
          case 18: {
            if (receiverId_ == null) {
              ReceiverId = new global::Proto.AccountID();
            }
            input.ReadMessage(ReceiverId);
            break;
          }
          case 26: {
            global::Proto.TokenID subBuilder = new global::Proto.TokenID();
            if (tokenReferenceCase_ == TokenReferenceOneofCase.FungibleTokenType) {
              subBuilder.MergeFrom(FungibleTokenType);
            }
            input.ReadMessage(subBuilder);
            FungibleTokenType = subBuilder;
            break;
          }
          case 34: {
            global::Proto.NftID subBuilder = new global::Proto.NftID();
            if (tokenReferenceCase_ == TokenReferenceOneofCase.NonFungibleToken) {
              subBuilder.MergeFrom(NonFungibleToken);
            }
            input.ReadMessage(subBuilder);
            NonFungibleToken = subBuilder;
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// A single pending airdrop value.
  ///
  /// This message SHALL record the airdrop amount for a
  /// fungible/common token.&lt;br/>
  /// This message SHOULD be null for a non-fungible/unique token.&lt;br/>
  /// If a non-null `PendingAirdropValue` is set for a non-fungible/unique
  /// token, the amount field MUST be `0`.
  ///
  /// It is RECOMMENDED that implementations store pending airdrop information
  /// as a key-value map from `PendingAirdropId` to `PendingAirdropValue`, with
  /// a `null` value used for non-fungible pending airdrops.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class PendingAirdropValue : pb::IMessage<PendingAirdropValue>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<PendingAirdropValue> _parser = new pb::MessageParser<PendingAirdropValue>(() => new PendingAirdropValue());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<PendingAirdropValue> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Proto.BasicTypesReflection.Descriptor.MessageTypes[44]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PendingAirdropValue() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PendingAirdropValue(PendingAirdropValue other) : this() {
      amount_ = other.amount_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PendingAirdropValue Clone() {
      return new PendingAirdropValue(this);
    }

    /// <summary>Field number for the "amount" field.</summary>
    public const int AmountFieldNumber = 1;
    private ulong amount_;
    /// <summary>
    ///*
    /// An amount to transfer for fungible/common tokens.&lt;br/>
    /// This is expressed in the smallest available units for that token
    /// (i.e. 10&lt;sup>-`decimals`&lt;/sup> whole tokens).
    /// &lt;p>
    /// This amount SHALL be transferred from the sender to the receiver,
    /// if claimed.&lt;br/>
    /// If the token is a fungible/common token, this value MUST be strictly
    /// greater than `0`.&lt;br/>
    /// If the token is a non-fungible/unique token, this message SHOULD NOT
    /// be set, and if set, this field MUST be `0`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ulong Amount {
      get { return amount_; }
      set {
        amount_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as PendingAirdropValue);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(PendingAirdropValue other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Amount != other.Amount) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Amount != 0UL) hash ^= Amount.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Amount != 0UL) {
        output.WriteRawTag(8);
        output.WriteUInt64(Amount);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Amount != 0UL) {
        output.WriteRawTag(8);
        output.WriteUInt64(Amount);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Amount != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(Amount);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(PendingAirdropValue other) {
      if (other == null) {
        return;
      }
      if (other.Amount != 0UL) {
        Amount = other.Amount;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Amount = input.ReadUInt64();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Amount = input.ReadUInt64();
            break;
          }
        }
      }
    }
    #endif

  }

  #endregion

}

#endregion Designer generated code
