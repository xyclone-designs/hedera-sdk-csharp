// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: topic.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021, 8981
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Hedera.Hashgraph.Proto {

  /// <summary>Holder for reflection information generated from topic.proto</summary>
  public static partial class TopicReflection {

    #region Descriptor
    /// <summary>File descriptor for topic.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static TopicReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "Cgt0b3BpYy5wcm90bxIFcHJvdG8aEWJhc2ljX3R5cGVzLnByb3RvGhFjdXN0",
            "b21fZmVlcy5wcm90byKYAwoFVG9waWMSIAoIdG9waWNfaWQYASABKAsyDi5w",
            "cm90by5Ub3BpY0lEEhcKD3NlcXVlbmNlX251bWJlchgCIAEoAxIZChFleHBp",
            "cmF0aW9uX3NlY29uZBgDIAEoAxIZChFhdXRvX3JlbmV3X3BlcmlvZBgEIAEo",
            "AxIvChVhdXRvX3JlbmV3X2FjY291bnRfaWQYBSABKAsyEC5wcm90by5BY2Nv",
            "dW50SUQSDwoHZGVsZXRlZBgGIAEoCBIUCgxydW5uaW5nX2hhc2gYByABKAwS",
            "DAoEbWVtbxgIIAEoCRIdCglhZG1pbl9rZXkYCSABKAsyCi5wcm90by5LZXkS",
            "HgoKc3VibWl0X2tleRgKIAEoCzIKLnByb3RvLktleRIkChBmZWVfc2NoZWR1",
            "bGVfa2V5GAsgASgLMgoucHJvdG8uS2V5EicKE2ZlZV9leGVtcHRfa2V5X2xp",
            "c3QYDCADKAsyCi5wcm90by5LZXkSKgoLY3VzdG9tX2ZlZXMYDSADKAsyFS5w",
            "cm90by5GaXhlZEN1c3RvbUZlZUI5Ch5jb20uaGVkZXJhLmhhc2hncmFwaC5z",
            "ZGsucHJvdG+qAhZIZWRlcmEuSGFzaGdyYXBoLlByb3RvYgZwcm90bzM="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Hedera.Hashgraph.Proto.BasicTypesReflection.Descriptor, global::Hedera.Hashgraph.Proto.CustomFeesReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Hedera.Hashgraph.Proto.Topic), global::Hedera.Hashgraph.Proto.Topic.Parser, new[]{ "TopicId", "SequenceNumber", "ExpirationSecond", "AutoRenewPeriod", "AutoRenewAccountId", "Deleted", "RunningHash", "Memo", "AdminKey", "SubmitKey", "FeeScheduleKey", "FeeExemptKeyList", "CustomFees" }, null, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  ///*
  /// Representation of an Hedera Consensus Service(HCS) topic.
  ///
  /// As with all network entities, a topic has a unique entity number, which is
  /// usually given along with the network's shard and realm in the form of a
  /// shard.realm.number id.&lt;br/>
  /// An HCS topic is an ordered logical stream of messages united and secured by
  /// a running hash of those messages. The integrity of any message on a topic,
  /// and the topic stream as a whole, can always be ascertained from block stream
  /// data by recomputing the running hash across any subset of messages on the
  /// topic.&lt;br/>
  /// The messages on a topic SHALL NOT be stored in network state, but are
  /// available in the network block stream, and may be queried via the
  /// Mirror Node system.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class Topic : pb::IMessage<Topic>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Topic> _parser = new pb::MessageParser<Topic>(() => new Topic());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Topic> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Hedera.Hashgraph.Proto.TopicReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Topic() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Topic(Topic other) : this() {
      topicId_ = other.topicId_ != null ? other.topicId_.Clone() : null;
      sequenceNumber_ = other.sequenceNumber_;
      expirationSecond_ = other.expirationSecond_;
      autoRenewPeriod_ = other.autoRenewPeriod_;
      autoRenewAccountId_ = other.autoRenewAccountId_ != null ? other.autoRenewAccountId_.Clone() : null;
      deleted_ = other.deleted_;
      runningHash_ = other.runningHash_;
      memo_ = other.memo_;
      adminKey_ = other.adminKey_ != null ? other.adminKey_.Clone() : null;
      submitKey_ = other.submitKey_ != null ? other.submitKey_.Clone() : null;
      feeScheduleKey_ = other.feeScheduleKey_ != null ? other.feeScheduleKey_.Clone() : null;
      feeExemptKeyList_ = other.feeExemptKeyList_.Clone();
      customFees_ = other.customFees_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Topic Clone() {
      return new Topic(this);
    }

    /// <summary>Field number for the "topic_id" field.</summary>
    public const int TopicIdFieldNumber = 1;
    private global::Hedera.Hashgraph.Proto.TopicID topicId_;
    /// <summary>
    ///*
    /// The topic's ID.
    /// &lt;p>
    /// This value SHALL be unique within the network.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Hedera.Hashgraph.Proto.TopicID TopicId {
      get { return topicId_; }
      set {
        topicId_ = value;
      }
    }

    /// <summary>Field number for the "sequence_number" field.</summary>
    public const int SequenceNumberFieldNumber = 2;
    private long sequenceNumber_;
    /// <summary>
    ///*
    /// The number of messages sent to the topic.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long SequenceNumber {
      get { return sequenceNumber_; }
      set {
        sequenceNumber_ = value;
      }
    }

    /// <summary>Field number for the "expiration_second" field.</summary>
    public const int ExpirationSecondFieldNumber = 3;
    private long expirationSecond_;
    /// <summary>
    ///*
    /// The expiration time for this topic, in seconds since the epoch.
    /// &lt;p>
    /// For this purpose, `epoch` SHALL be the UNIX epoch with 0 at `1970-01-01T00:00:00.000Z`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long ExpirationSecond {
      get { return expirationSecond_; }
      set {
        expirationSecond_ = value;
      }
    }

    /// <summary>Field number for the "auto_renew_period" field.</summary>
    public const int AutoRenewPeriodFieldNumber = 4;
    private long autoRenewPeriod_;
    /// <summary>
    ///*
    /// The number of seconds for which the topic will be automatically renewed
    /// upon expiring (if it has a valid auto-renew account).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long AutoRenewPeriod {
      get { return autoRenewPeriod_; }
      set {
        autoRenewPeriod_ = value;
      }
    }

    /// <summary>Field number for the "auto_renew_account_id" field.</summary>
    public const int AutoRenewAccountIdFieldNumber = 5;
    private global::Hedera.Hashgraph.Proto.AccountID autoRenewAccountId_;
    /// <summary>
    ///*
    /// The id of the account (if any) that the network will attempt to charge
    /// fees to complete auto-renewal of this topic, upon expiration.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Hedera.Hashgraph.Proto.AccountID AutoRenewAccountId {
      get { return autoRenewAccountId_; }
      set {
        autoRenewAccountId_ = value;
      }
    }

    /// <summary>Field number for the "deleted" field.</summary>
    public const int DeletedFieldNumber = 6;
    private bool deleted_;
    /// <summary>
    ///*
    /// A flag indicating that this topic is deleted.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Deleted {
      get { return deleted_; }
      set {
        deleted_ = value;
      }
    }

    /// <summary>Field number for the "running_hash" field.</summary>
    public const int RunningHashFieldNumber = 7;
    private pb::ByteString runningHash_ = pb::ByteString.Empty;
    /// <summary>
    ///*
    /// The current running hash of this topic.
    /// &lt;p>
    /// This 48-byte field is the output of a SHA-384 digest with input data
    /// determined by the current version of the running hash algorithm used
    /// by the network.&lt;br/>
    /// All topics in state SHALL use running hash algorithm version `3`.&lt;br/>
    /// The bytes of each uint64 or uint32 encoded for the hash input MUST be in
    /// Big-Endian format.
    /// &lt;p>
    /// &lt;hr/>
    /// If the algorithm version is '3', then the input data to the SHA-384
    /// digest are, in order:
    /// &lt;ol>
    ///   &lt;li>The previous running hash of the topic (48 bytes)&lt;/li>
    ///   &lt;li>The `topicRunningHashVersion` (8 bytes)&lt;/li>
    ///   &lt;li>The payer account's shard (8 bytes)&lt;/li>
    ///   &lt;li>The payer account's realm (8 bytes)&lt;/li>
    ///   &lt;li>The payer account's number (8 bytes)&lt;/li>
    ///   &lt;li>The topic's shard (8 bytes)&lt;/li>
    ///   &lt;li>The topic's realm (8 bytes)&lt;/li>
    ///   &lt;li>The topic's number (8 bytes)&lt;/li>
    ///   &lt;li>The number of seconds since the epoch when the
    ///       `ConsensusSubmitMessage` reached consensus (8 bytes)&lt;/li>
    ///   &lt;li>The number of nanoseconds within the second when the
    ///       `ConsensusSubmitMessage` reached consensus (4 bytes)&lt;/li>
    ///   &lt;li>The `topicSequenceNumber` (8 bytes)&lt;/li>
    ///   &lt;li>The output of a SHA-384 digest of the message bytes from the
    ///       `ConsensusSubmitMessage` (48 bytes)&lt;/li>
    /// &lt;/ol>
    /// &lt;blockquote>Note that older messages on a topic, which are available in
    /// the block stream, MAY use older algorithm versions, and the block stream
    /// record incorporates a running hash version field to ensure the correct
    /// hash calculation for each such historical message.&lt;/blockquote>
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString RunningHash {
      get { return runningHash_; }
      set {
        runningHash_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "memo" field.</summary>
    public const int MemoFieldNumber = 8;
    private string memo_ = "";
    /// <summary>
    ///*
    /// A short description of this topic.
    /// &lt;p>
    /// This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
    /// (default 100) bytes when encoded as UTF-8.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Memo {
      get { return memo_; }
      set {
        memo_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "admin_key" field.</summary>
    public const int AdminKeyFieldNumber = 9;
    private global::Hedera.Hashgraph.Proto.Key adminKey_;
    /// <summary>
    ///*
    /// Access control for modification of the topic.
    /// &lt;p>
    /// If this field is set, that key MUST sign each message to update or delete
    /// this topic.&lt;br/>
    /// A topic without an admin key SHALL be immutable, except for expiration
    /// and renewal.&lt;br/>
    /// If this field is not set, the `auto_renew_account_id` MUST NOT be set.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Hedera.Hashgraph.Proto.Key AdminKey {
      get { return adminKey_; }
      set {
        adminKey_ = value;
      }
    }

    /// <summary>Field number for the "submit_key" field.</summary>
    public const int SubmitKeyFieldNumber = 10;
    private global::Hedera.Hashgraph.Proto.Key submitKey_;
    /// <summary>
    ///*
    /// Access control for message submission to the topic.
    /// &lt;p>
    /// If this field is set, that key MUST sign each consensus submit message
    /// for this topic.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Hedera.Hashgraph.Proto.Key SubmitKey {
      get { return submitKey_; }
      set {
        submitKey_ = value;
      }
    }

    /// <summary>Field number for the "fee_schedule_key" field.</summary>
    public const int FeeScheduleKeyFieldNumber = 11;
    private global::Hedera.Hashgraph.Proto.Key feeScheduleKey_;
    /// <summary>
    ///*
    /// Access control for update/delete of custom fees.
    /// &lt;p>
    /// If this field is unset, the current custom fees CANNOT be changed.&lt;br/>
    /// If this field is set, that `Key` MUST sign any transaction to update
    /// the custom fee schedule for this topic.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Hedera.Hashgraph.Proto.Key FeeScheduleKey {
      get { return feeScheduleKey_; }
      set {
        feeScheduleKey_ = value;
      }
    }

    /// <summary>Field number for the "fee_exempt_key_list" field.</summary>
    public const int FeeExemptKeyListFieldNumber = 12;
    private static readonly pb::FieldCodec<global::Hedera.Hashgraph.Proto.Key> _repeated_feeExemptKeyList_codec
        = pb::FieldCodec.ForMessage(98, global::Hedera.Hashgraph.Proto.Key.Parser);
    private readonly pbc::RepeatedField<global::Hedera.Hashgraph.Proto.Key> feeExemptKeyList_ = new pbc::RepeatedField<global::Hedera.Hashgraph.Proto.Key>();
    /// <summary>
    ///*
    /// A set of "privileged payer" keys&lt;br/>
    /// Keys in this list are permitted to submit messages to this topic without
    /// paying custom fees associated with this topic.
    /// &lt;p>
    /// If a submit transaction is signed by _any_ key included in this set,
    /// custom fees SHALL NOT be charged for that transaction.&lt;br/>
    /// A `fee_exempt_key_list` MUST NOT contain more than
    /// `MAX_ENTRIES_FOR_FEE_EXEMPT_KEY_LIST` keys.&lt;br/>
    /// A `fee_exempt_key_list` MUST NOT contain any duplicate keys.&lt;br/>
    /// A `fee_exempt_key_list` MAY contain keys for accounts that are inactive,
    /// deleted, or non-existent.
    /// If not set, there SHALL NOT be any fee-exempt keys.  In particular, the
    /// following keys SHALL NOT be implicitly or automatically added to this
    /// list: `adminKey`, `submitKey`, `fee_schedule_key`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Hedera.Hashgraph.Proto.Key> FeeExemptKeyList {
      get { return feeExemptKeyList_; }
    }

    /// <summary>Field number for the "custom_fees" field.</summary>
    public const int CustomFeesFieldNumber = 13;
    private static readonly pb::FieldCodec<global::Hedera.Hashgraph.Proto.FixedCustomFee> _repeated_customFees_codec
        = pb::FieldCodec.ForMessage(106, global::Hedera.Hashgraph.Proto.FixedCustomFee.Parser);
    private readonly pbc::RepeatedField<global::Hedera.Hashgraph.Proto.FixedCustomFee> customFees_ = new pbc::RepeatedField<global::Hedera.Hashgraph.Proto.FixedCustomFee>();
    /// <summary>
    ///*
    /// A set of custom fee definitions.&lt;br/>
    /// These are fees to be assessed for each submit to this topic.
    /// &lt;p>
    /// If this list is empty, the only fees charged for a submit to this
    /// topic SHALL be the network and node fees.&lt;br/>
    /// If this list is not empty, each fee defined in this set SHALL
    /// be evaluated for each message submitted to this topic, and the
    /// resultant total assessed fees SHALL be charged.&lt;br/>
    /// If this list is not empty, custom fees defined here SHALL be
    /// charged _in addition to_ the base network and node fees.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Hedera.Hashgraph.Proto.FixedCustomFee> CustomFees {
      get { return customFees_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Topic);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Topic other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(TopicId, other.TopicId)) return false;
      if (SequenceNumber != other.SequenceNumber) return false;
      if (ExpirationSecond != other.ExpirationSecond) return false;
      if (AutoRenewPeriod != other.AutoRenewPeriod) return false;
      if (!object.Equals(AutoRenewAccountId, other.AutoRenewAccountId)) return false;
      if (Deleted != other.Deleted) return false;
      if (RunningHash != other.RunningHash) return false;
      if (Memo != other.Memo) return false;
      if (!object.Equals(AdminKey, other.AdminKey)) return false;
      if (!object.Equals(SubmitKey, other.SubmitKey)) return false;
      if (!object.Equals(FeeScheduleKey, other.FeeScheduleKey)) return false;
      if(!feeExemptKeyList_.Equals(other.feeExemptKeyList_)) return false;
      if(!customFees_.Equals(other.customFees_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (topicId_ != null) hash ^= TopicId.GetHashCode();
      if (SequenceNumber != 0L) hash ^= SequenceNumber.GetHashCode();
      if (ExpirationSecond != 0L) hash ^= ExpirationSecond.GetHashCode();
      if (AutoRenewPeriod != 0L) hash ^= AutoRenewPeriod.GetHashCode();
      if (autoRenewAccountId_ != null) hash ^= AutoRenewAccountId.GetHashCode();
      if (Deleted != false) hash ^= Deleted.GetHashCode();
      if (RunningHash.Length != 0) hash ^= RunningHash.GetHashCode();
      if (Memo.Length != 0) hash ^= Memo.GetHashCode();
      if (adminKey_ != null) hash ^= AdminKey.GetHashCode();
      if (submitKey_ != null) hash ^= SubmitKey.GetHashCode();
      if (feeScheduleKey_ != null) hash ^= FeeScheduleKey.GetHashCode();
      hash ^= feeExemptKeyList_.GetHashCode();
      hash ^= customFees_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (topicId_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(TopicId);
      }
      if (SequenceNumber != 0L) {
        output.WriteRawTag(16);
        output.WriteInt64(SequenceNumber);
      }
      if (ExpirationSecond != 0L) {
        output.WriteRawTag(24);
        output.WriteInt64(ExpirationSecond);
      }
      if (AutoRenewPeriod != 0L) {
        output.WriteRawTag(32);
        output.WriteInt64(AutoRenewPeriod);
      }
      if (autoRenewAccountId_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(AutoRenewAccountId);
      }
      if (Deleted != false) {
        output.WriteRawTag(48);
        output.WriteBool(Deleted);
      }
      if (RunningHash.Length != 0) {
        output.WriteRawTag(58);
        output.WriteBytes(RunningHash);
      }
      if (Memo.Length != 0) {
        output.WriteRawTag(66);
        output.WriteString(Memo);
      }
      if (adminKey_ != null) {
        output.WriteRawTag(74);
        output.WriteMessage(AdminKey);
      }
      if (submitKey_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(SubmitKey);
      }
      if (feeScheduleKey_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(FeeScheduleKey);
      }
      feeExemptKeyList_.WriteTo(output, _repeated_feeExemptKeyList_codec);
      customFees_.WriteTo(output, _repeated_customFees_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (topicId_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(TopicId);
      }
      if (SequenceNumber != 0L) {
        output.WriteRawTag(16);
        output.WriteInt64(SequenceNumber);
      }
      if (ExpirationSecond != 0L) {
        output.WriteRawTag(24);
        output.WriteInt64(ExpirationSecond);
      }
      if (AutoRenewPeriod != 0L) {
        output.WriteRawTag(32);
        output.WriteInt64(AutoRenewPeriod);
      }
      if (autoRenewAccountId_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(AutoRenewAccountId);
      }
      if (Deleted != false) {
        output.WriteRawTag(48);
        output.WriteBool(Deleted);
      }
      if (RunningHash.Length != 0) {
        output.WriteRawTag(58);
        output.WriteBytes(RunningHash);
      }
      if (Memo.Length != 0) {
        output.WriteRawTag(66);
        output.WriteString(Memo);
      }
      if (adminKey_ != null) {
        output.WriteRawTag(74);
        output.WriteMessage(AdminKey);
      }
      if (submitKey_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(SubmitKey);
      }
      if (feeScheduleKey_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(FeeScheduleKey);
      }
      feeExemptKeyList_.WriteTo(ref output, _repeated_feeExemptKeyList_codec);
      customFees_.WriteTo(ref output, _repeated_customFees_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (topicId_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TopicId);
      }
      if (SequenceNumber != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(SequenceNumber);
      }
      if (ExpirationSecond != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(ExpirationSecond);
      }
      if (AutoRenewPeriod != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(AutoRenewPeriod);
      }
      if (autoRenewAccountId_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(AutoRenewAccountId);
      }
      if (Deleted != false) {
        size += 1 + 1;
      }
      if (RunningHash.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(RunningHash);
      }
      if (Memo.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Memo);
      }
      if (adminKey_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(AdminKey);
      }
      if (submitKey_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SubmitKey);
      }
      if (feeScheduleKey_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(FeeScheduleKey);
      }
      size += feeExemptKeyList_.CalculateSize(_repeated_feeExemptKeyList_codec);
      size += customFees_.CalculateSize(_repeated_customFees_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Topic other) {
      if (other == null) {
        return;
      }
      if (other.topicId_ != null) {
        if (topicId_ == null) {
          TopicId = new global::Hedera.Hashgraph.Proto.TopicID();
        }
        TopicId.MergeFrom(other.TopicId);
      }
      if (other.SequenceNumber != 0L) {
        SequenceNumber = other.SequenceNumber;
      }
      if (other.ExpirationSecond != 0L) {
        ExpirationSecond = other.ExpirationSecond;
      }
      if (other.AutoRenewPeriod != 0L) {
        AutoRenewPeriod = other.AutoRenewPeriod;
      }
      if (other.autoRenewAccountId_ != null) {
        if (autoRenewAccountId_ == null) {
          AutoRenewAccountId = new global::Hedera.Hashgraph.Proto.AccountID();
        }
        AutoRenewAccountId.MergeFrom(other.AutoRenewAccountId);
      }
      if (other.Deleted != false) {
        Deleted = other.Deleted;
      }
      if (other.RunningHash.Length != 0) {
        RunningHash = other.RunningHash;
      }
      if (other.Memo.Length != 0) {
        Memo = other.Memo;
      }
      if (other.adminKey_ != null) {
        if (adminKey_ == null) {
          AdminKey = new global::Hedera.Hashgraph.Proto.Key();
        }
        AdminKey.MergeFrom(other.AdminKey);
      }
      if (other.submitKey_ != null) {
        if (submitKey_ == null) {
          SubmitKey = new global::Hedera.Hashgraph.Proto.Key();
        }
        SubmitKey.MergeFrom(other.SubmitKey);
      }
      if (other.feeScheduleKey_ != null) {
        if (feeScheduleKey_ == null) {
          FeeScheduleKey = new global::Hedera.Hashgraph.Proto.Key();
        }
        FeeScheduleKey.MergeFrom(other.FeeScheduleKey);
      }
      feeExemptKeyList_.Add(other.feeExemptKeyList_);
      customFees_.Add(other.customFees_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (topicId_ == null) {
              TopicId = new global::Hedera.Hashgraph.Proto.TopicID();
            }
            input.ReadMessage(TopicId);
            break;
          }
          case 16: {
            SequenceNumber = input.ReadInt64();
            break;
          }
          case 24: {
            ExpirationSecond = input.ReadInt64();
            break;
          }
          case 32: {
            AutoRenewPeriod = input.ReadInt64();
            break;
          }
          case 42: {
            if (autoRenewAccountId_ == null) {
              AutoRenewAccountId = new global::Hedera.Hashgraph.Proto.AccountID();
            }
            input.ReadMessage(AutoRenewAccountId);
            break;
          }
          case 48: {
            Deleted = input.ReadBool();
            break;
          }
          case 58: {
            RunningHash = input.ReadBytes();
            break;
          }
          case 66: {
            Memo = input.ReadString();
            break;
          }
          case 74: {
            if (adminKey_ == null) {
              AdminKey = new global::Hedera.Hashgraph.Proto.Key();
            }
            input.ReadMessage(AdminKey);
            break;
          }
          case 82: {
            if (submitKey_ == null) {
              SubmitKey = new global::Hedera.Hashgraph.Proto.Key();
            }
            input.ReadMessage(SubmitKey);
            break;
          }
          case 90: {
            if (feeScheduleKey_ == null) {
              FeeScheduleKey = new global::Hedera.Hashgraph.Proto.Key();
            }
            input.ReadMessage(FeeScheduleKey);
            break;
          }
          case 98: {
            feeExemptKeyList_.AddEntriesFrom(input, _repeated_feeExemptKeyList_codec);
            break;
          }
          case 106: {
            customFees_.AddEntriesFrom(input, _repeated_customFees_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (topicId_ == null) {
              TopicId = new global::Hedera.Hashgraph.Proto.TopicID();
            }
            input.ReadMessage(TopicId);
            break;
          }
          case 16: {
            SequenceNumber = input.ReadInt64();
            break;
          }
          case 24: {
            ExpirationSecond = input.ReadInt64();
            break;
          }
          case 32: {
            AutoRenewPeriod = input.ReadInt64();
            break;
          }
          case 42: {
            if (autoRenewAccountId_ == null) {
              AutoRenewAccountId = new global::Hedera.Hashgraph.Proto.AccountID();
            }
            input.ReadMessage(AutoRenewAccountId);
            break;
          }
          case 48: {
            Deleted = input.ReadBool();
            break;
          }
          case 58: {
            RunningHash = input.ReadBytes();
            break;
          }
          case 66: {
            Memo = input.ReadString();
            break;
          }
          case 74: {
            if (adminKey_ == null) {
              AdminKey = new global::Hedera.Hashgraph.Proto.Key();
            }
            input.ReadMessage(AdminKey);
            break;
          }
          case 82: {
            if (submitKey_ == null) {
              SubmitKey = new global::Hedera.Hashgraph.Proto.Key();
            }
            input.ReadMessage(SubmitKey);
            break;
          }
          case 90: {
            if (feeScheduleKey_ == null) {
              FeeScheduleKey = new global::Hedera.Hashgraph.Proto.Key();
            }
            input.ReadMessage(FeeScheduleKey);
            break;
          }
          case 98: {
            feeExemptKeyList_.AddEntriesFrom(ref input, _repeated_feeExemptKeyList_codec);
            break;
          }
          case 106: {
            customFees_.AddEntriesFrom(ref input, _repeated_customFees_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  #endregion

}

#endregion Designer generated code
