// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: throttle_definitions.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021, 8981
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Proto {

  /// <summary>Holder for reflection information generated from throttle_definitions.proto</summary>
  public static partial class ThrottleDefinitionsReflection {

    #region Descriptor
    /// <summary>File descriptor for throttle_definitions.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static ThrottleDefinitionsReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "Chp0aHJvdHRsZV9kZWZpbml0aW9ucy5wcm90bxIFcHJvdG8aEWJhc2ljX3R5",
            "cGVzLnByb3RvIlcKDVRocm90dGxlR3JvdXASLgoKb3BlcmF0aW9ucxgBIAMo",
            "DjIaLnByb3RvLkhlZGVyYUZ1bmN0aW9uYWxpdHkSFgoObWlsbGlPcHNQZXJT",
            "ZWMYAiABKAQiYwoOVGhyb3R0bGVCdWNrZXQSDAoEbmFtZRgBIAEoCRIVCg1i",
            "dXJzdFBlcmlvZE1zGAIgASgEEiwKDnRocm90dGxlR3JvdXBzGAMgAygLMhQu",
            "cHJvdG8uVGhyb3R0bGVHcm91cCJFChNUaHJvdHRsZURlZmluaXRpb25zEi4K",
            "D3Rocm90dGxlQnVja2V0cxgBIAMoCzIVLnByb3RvLlRocm90dGxlQnVja2V0",
            "QiIKHmNvbS5oZWRlcmEuaGFzaGdyYXBoLnNkay5wcm90b1ABYgZwcm90bzM="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Proto.BasicTypesReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Proto.ThrottleGroup), global::Proto.ThrottleGroup.Parser, new[]{ "Operations", "MilliOpsPerSec" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Proto.ThrottleBucket), global::Proto.ThrottleBucket.Parser, new[]{ "Name", "BurstPeriodMs", "ThrottleGroups" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Proto.ThrottleDefinitions), global::Proto.ThrottleDefinitions.Parser, new[]{ "ThrottleBuckets" }, null, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  ///*
  /// A single throttle limit applied to one or more operations.
  ///
  /// The list of operations MUST contain at least one entry.&lt;br/>
  /// The throttle limit SHALL be specified in thousandths of an operation
  /// per second; one operation per second for the network would be `1000`.&lt;br/>
  /// The throttle limit MUST be greater than zero (`0`).
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class ThrottleGroup : pb::IMessage<ThrottleGroup>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ThrottleGroup> _parser = new pb::MessageParser<ThrottleGroup>(() => new ThrottleGroup());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ThrottleGroup> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Proto.ThrottleDefinitionsReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ThrottleGroup() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ThrottleGroup(ThrottleGroup other) : this() {
      operations_ = other.operations_.Clone();
      milliOpsPerSec_ = other.milliOpsPerSec_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ThrottleGroup Clone() {
      return new ThrottleGroup(this);
    }

    /// <summary>Field number for the "operations" field.</summary>
    public const int OperationsFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Proto.HederaFunctionality> _repeated_operations_codec
        = pb::FieldCodec.ForEnum(10, x => (int) x, x => (global::Proto.HederaFunctionality) x);
    private readonly pbc::RepeatedField<global::Proto.HederaFunctionality> operations_ = new pbc::RepeatedField<global::Proto.HederaFunctionality>();
    /// <summary>
    ///*
    /// A list of operations to be throttled.
    /// &lt;p>
    /// This list MUST contain at least one item.&lt;br/>
    /// This list SHOULD NOT contain any item included in any other
    /// active `ThrottleGroup`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Proto.HederaFunctionality> Operations {
      get { return operations_; }
    }

    /// <summary>Field number for the "milliOpsPerSec" field.</summary>
    public const int MilliOpsPerSecFieldNumber = 2;
    private ulong milliOpsPerSec_;
    /// <summary>
    ///*
    /// A throttle limit for this group.&lt;br/>
    /// This is a total number of operations, in thousandths, the network may
    /// perform each second for this group. Every node executes every transaction,
    /// so this limit effectively applies individually to each node as well.&lt;br/>
    /// &lt;p>
    /// This value MUST be greater than zero (`0`).&lt;br/>
    /// This value SHOULD be less than `9,223,372`.&lt;br/>
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ulong MilliOpsPerSec {
      get { return milliOpsPerSec_; }
      set {
        milliOpsPerSec_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ThrottleGroup);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ThrottleGroup other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!operations_.Equals(other.operations_)) return false;
      if (MilliOpsPerSec != other.MilliOpsPerSec) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= operations_.GetHashCode();
      if (MilliOpsPerSec != 0UL) hash ^= MilliOpsPerSec.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      operations_.WriteTo(output, _repeated_operations_codec);
      if (MilliOpsPerSec != 0UL) {
        output.WriteRawTag(16);
        output.WriteUInt64(MilliOpsPerSec);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      operations_.WriteTo(ref output, _repeated_operations_codec);
      if (MilliOpsPerSec != 0UL) {
        output.WriteRawTag(16);
        output.WriteUInt64(MilliOpsPerSec);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += operations_.CalculateSize(_repeated_operations_codec);
      if (MilliOpsPerSec != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(MilliOpsPerSec);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ThrottleGroup other) {
      if (other == null) {
        return;
      }
      operations_.Add(other.operations_);
      if (other.MilliOpsPerSec != 0UL) {
        MilliOpsPerSec = other.MilliOpsPerSec;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10:
          case 8: {
            operations_.AddEntriesFrom(input, _repeated_operations_codec);
            break;
          }
          case 16: {
            MilliOpsPerSec = input.ReadUInt64();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10:
          case 8: {
            operations_.AddEntriesFrom(ref input, _repeated_operations_codec);
            break;
          }
          case 16: {
            MilliOpsPerSec = input.ReadUInt64();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// A "bucket" of performance allocated across one or more throttle groups.&lt;br/>
  /// This entry combines one or more throttle groups into a single unit to
  /// calculate limitations and congestion. Each "bucket" "fills" as operations
  /// are completed, then "drains" over a period of time defined for each bucket.
  /// This fill-and-drain characteristic enables the network to process sudden
  /// bursts of heavy traffic while still observing throttle limits over longer
  /// timeframes.
  ///
  /// The value of `burstPeriodMs` is combined with the `milliOpsPerSec`
  /// values for the individual throttle groups to determine the total
  /// bucket "capacity". This combination MUST be less than the maximum
  /// value of a signed long integer (`9223372036854775807`), when scaled to
  /// a nanosecond measurement resolution.
  ///
  /// > Note
  /// >> There is some question regarding the mechanism of calculating the
  /// >> combination of `burstPeriodMs` and `milliOpsPerSec`. The calculation
  /// >> Is implemented in difficult-to-find code, and very likely does not
  /// >> match the approach described here.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class ThrottleBucket : pb::IMessage<ThrottleBucket>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ThrottleBucket> _parser = new pb::MessageParser<ThrottleBucket>(() => new ThrottleBucket());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ThrottleBucket> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Proto.ThrottleDefinitionsReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ThrottleBucket() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ThrottleBucket(ThrottleBucket other) : this() {
      name_ = other.name_;
      burstPeriodMs_ = other.burstPeriodMs_;
      throttleGroups_ = other.throttleGroups_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ThrottleBucket Clone() {
      return new ThrottleBucket(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    ///*
    /// A name for this bucket.&lt;br/>
    /// This is used for log entries.
    /// &lt;p>
    /// This value SHOULD NOT exceed 20 characters.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "burstPeriodMs" field.</summary>
    public const int BurstPeriodMsFieldNumber = 2;
    private ulong burstPeriodMs_;
    /// <summary>
    ///*
    /// A burst duration limit, in milliseconds.&lt;br/>
    /// This value determines the total "capacity" of the bucket. The rate
    /// at which the bucket "drains" is set by the throttles, and this duration
    /// sets how long that rate must be sustained to empty a "full" bucket.
    /// That combination (calculated as the product of this value and the least
    /// common multiple of the `milliOpsPerSec` values for all throttle groups)
    /// determines the maximum amount of operations this bucket can "hold".
    /// &lt;p>
    /// The calculated capacity of this bucket MUST NOT exceed `9,223,372,036,854`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ulong BurstPeriodMs {
      get { return burstPeriodMs_; }
      set {
        burstPeriodMs_ = value;
      }
    }

    /// <summary>Field number for the "throttleGroups" field.</summary>
    public const int ThrottleGroupsFieldNumber = 3;
    private static readonly pb::FieldCodec<global::Proto.ThrottleGroup> _repeated_throttleGroups_codec
        = pb::FieldCodec.ForMessage(26, global::Proto.ThrottleGroup.Parser);
    private readonly pbc::RepeatedField<global::Proto.ThrottleGroup> throttleGroups_ = new pbc::RepeatedField<global::Proto.ThrottleGroup>();
    /// <summary>
    ///*
    /// A list of throttle groups.&lt;br/>
    /// These throttle groups combined define the effective throttle
    /// rate for the bucket.
    /// &lt;p>
    /// This list MUST contain at least one entry.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Proto.ThrottleGroup> ThrottleGroups {
      get { return throttleGroups_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ThrottleBucket);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ThrottleBucket other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (BurstPeriodMs != other.BurstPeriodMs) return false;
      if(!throttleGroups_.Equals(other.throttleGroups_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (BurstPeriodMs != 0UL) hash ^= BurstPeriodMs.GetHashCode();
      hash ^= throttleGroups_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (BurstPeriodMs != 0UL) {
        output.WriteRawTag(16);
        output.WriteUInt64(BurstPeriodMs);
      }
      throttleGroups_.WriteTo(output, _repeated_throttleGroups_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (BurstPeriodMs != 0UL) {
        output.WriteRawTag(16);
        output.WriteUInt64(BurstPeriodMs);
      }
      throttleGroups_.WriteTo(ref output, _repeated_throttleGroups_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (BurstPeriodMs != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(BurstPeriodMs);
      }
      size += throttleGroups_.CalculateSize(_repeated_throttleGroups_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ThrottleBucket other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.BurstPeriodMs != 0UL) {
        BurstPeriodMs = other.BurstPeriodMs;
      }
      throttleGroups_.Add(other.throttleGroups_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 16: {
            BurstPeriodMs = input.ReadUInt64();
            break;
          }
          case 26: {
            throttleGroups_.AddEntriesFrom(input, _repeated_throttleGroups_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 16: {
            BurstPeriodMs = input.ReadUInt64();
            break;
          }
          case 26: {
            throttleGroups_.AddEntriesFrom(ref input, _repeated_throttleGroups_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// A list of throttle buckets.&lt;br/>
  /// This list, simultaneously enforced, defines a complete throttling policy.
  ///
  ///  1. When an operation appears in more than one throttling bucket,
  ///     that operation SHALL be throttled unless all of the buckets where
  ///     the operation appears have "capacity" available.
  ///  1. An operation assigned to no buckets is SHALL be throttled in every
  ///     instance.  The _effective_ throttle for this case is `0`.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class ThrottleDefinitions : pb::IMessage<ThrottleDefinitions>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ThrottleDefinitions> _parser = new pb::MessageParser<ThrottleDefinitions>(() => new ThrottleDefinitions());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ThrottleDefinitions> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Proto.ThrottleDefinitionsReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ThrottleDefinitions() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ThrottleDefinitions(ThrottleDefinitions other) : this() {
      throttleBuckets_ = other.throttleBuckets_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ThrottleDefinitions Clone() {
      return new ThrottleDefinitions(this);
    }

    /// <summary>Field number for the "throttleBuckets" field.</summary>
    public const int ThrottleBucketsFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Proto.ThrottleBucket> _repeated_throttleBuckets_codec
        = pb::FieldCodec.ForMessage(10, global::Proto.ThrottleBucket.Parser);
    private readonly pbc::RepeatedField<global::Proto.ThrottleBucket> throttleBuckets_ = new pbc::RepeatedField<global::Proto.ThrottleBucket>();
    /// <summary>
    ///*
    /// A list of throttle buckets.
    /// &lt;p>
    /// This list MUST be set, and SHOULD NOT be empty.&lt;br/>
    /// An empty list SHALL have the effect of setting all operations to
    /// a single group with throttle limit of `0` operations per second for the
    /// entire network.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Proto.ThrottleBucket> ThrottleBuckets {
      get { return throttleBuckets_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ThrottleDefinitions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ThrottleDefinitions other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!throttleBuckets_.Equals(other.throttleBuckets_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= throttleBuckets_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      throttleBuckets_.WriteTo(output, _repeated_throttleBuckets_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      throttleBuckets_.WriteTo(ref output, _repeated_throttleBuckets_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += throttleBuckets_.CalculateSize(_repeated_throttleBuckets_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ThrottleDefinitions other) {
      if (other == null) {
        return;
      }
      throttleBuckets_.Add(other.throttleBuckets_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            throttleBuckets_.AddEntriesFrom(input, _repeated_throttleBuckets_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            throttleBuckets_.AddEntriesFrom(ref input, _repeated_throttleBuckets_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  #endregion

}

#endregion Designer generated code
