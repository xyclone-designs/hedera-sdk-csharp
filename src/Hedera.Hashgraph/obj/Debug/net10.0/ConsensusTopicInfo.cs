// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: consensus_topic_info.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021, 8981
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Hedera.Hashgraph.Proto {

  /// <summary>Holder for reflection information generated from consensus_topic_info.proto</summary>
  public static partial class ConsensusTopicInfoReflection {

    #region Descriptor
    /// <summary>File descriptor for consensus_topic_info.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static ConsensusTopicInfoReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "Chpjb25zZW5zdXNfdG9waWNfaW5mby5wcm90bxIFcHJvdG8aEWJhc2ljX3R5",
            "cGVzLnByb3RvGhFjdXN0b21fZmVlcy5wcm90bxoOZHVyYXRpb24ucHJvdG8a",
            "D3RpbWVzdGFtcC5wcm90byKaAwoSQ29uc2Vuc3VzVG9waWNJbmZvEgwKBG1l",
            "bW8YASABKAkSEwoLcnVubmluZ0hhc2gYAiABKAwSFgoOc2VxdWVuY2VOdW1i",
            "ZXIYAyABKAQSKAoOZXhwaXJhdGlvblRpbWUYBCABKAsyEC5wcm90by5UaW1l",
            "c3RhbXASHAoIYWRtaW5LZXkYBSABKAsyCi5wcm90by5LZXkSHQoJc3VibWl0",
            "S2V5GAYgASgLMgoucHJvdG8uS2V5EigKD2F1dG9SZW5ld1BlcmlvZBgHIAEo",
            "CzIPLnByb3RvLkR1cmF0aW9uEioKEGF1dG9SZW5ld0FjY291bnQYCCABKAsy",
            "EC5wcm90by5BY2NvdW50SUQSEQoJbGVkZ2VyX2lkGAkgASgMEiQKEGZlZV9z",
            "Y2hlZHVsZV9rZXkYCiABKAsyCi5wcm90by5LZXkSJwoTZmVlX2V4ZW1wdF9r",
            "ZXlfbGlzdBgLIAMoCzIKLnByb3RvLktleRIqCgtjdXN0b21fZmVlcxgMIAMo",
            "CzIVLnByb3RvLkZpeGVkQ3VzdG9tRmVlQjkKHmNvbS5oZWRlcmEuaGFzaGdy",
            "YXBoLnNkay5wcm90b6oCFkhlZGVyYS5IYXNoZ3JhcGguUHJvdG9iBnByb3Rv",
            "Mw=="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Hedera.Hashgraph.Proto.BasicTypesReflection.Descriptor, global::Hedera.Hashgraph.Proto.CustomFeesReflection.Descriptor, global::Hedera.Hashgraph.Proto.DurationReflection.Descriptor, global::Hedera.Hashgraph.Proto.TimestampReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Hedera.Hashgraph.Proto.ConsensusTopicInfo), global::Hedera.Hashgraph.Proto.ConsensusTopicInfo.Parser, new[]{ "Memo", "RunningHash", "SequenceNumber", "ExpirationTime", "AdminKey", "SubmitKey", "AutoRenewPeriod", "AutoRenewAccount", "LedgerId", "FeeScheduleKey", "FeeExemptKeyList", "CustomFees" }, null, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  ///*
  /// A query response describing the current state of a topic for the Hedera
  /// Consensus Service (HCS).
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class ConsensusTopicInfo : pb::IMessage<ConsensusTopicInfo>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ConsensusTopicInfo> _parser = new pb::MessageParser<ConsensusTopicInfo>(() => new ConsensusTopicInfo());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ConsensusTopicInfo> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Hedera.Hashgraph.Proto.ConsensusTopicInfoReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ConsensusTopicInfo() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ConsensusTopicInfo(ConsensusTopicInfo other) : this() {
      memo_ = other.memo_;
      runningHash_ = other.runningHash_;
      sequenceNumber_ = other.sequenceNumber_;
      expirationTime_ = other.expirationTime_ != null ? other.expirationTime_.Clone() : null;
      adminKey_ = other.adminKey_ != null ? other.adminKey_.Clone() : null;
      submitKey_ = other.submitKey_ != null ? other.submitKey_.Clone() : null;
      autoRenewPeriod_ = other.autoRenewPeriod_ != null ? other.autoRenewPeriod_.Clone() : null;
      autoRenewAccount_ = other.autoRenewAccount_ != null ? other.autoRenewAccount_.Clone() : null;
      ledgerId_ = other.ledgerId_;
      feeScheduleKey_ = other.feeScheduleKey_ != null ? other.feeScheduleKey_.Clone() : null;
      feeExemptKeyList_ = other.feeExemptKeyList_.Clone();
      customFees_ = other.customFees_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ConsensusTopicInfo Clone() {
      return new ConsensusTopicInfo(this);
    }

    /// <summary>Field number for the "memo" field.</summary>
    public const int MemoFieldNumber = 1;
    private string memo_ = "";
    /// <summary>
    ///*
    /// A short description of this topic.
    /// &lt;p>
    /// This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
    /// (default 100) bytes when encoded as UTF-8.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Memo {
      get { return memo_; }
      set {
        memo_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "runningHash" field.</summary>
    public const int RunningHashFieldNumber = 2;
    private pb::ByteString runningHash_ = pb::ByteString.Empty;
    /// <summary>
    ///*
    /// The latest running hash of the topic.
    /// &lt;p>
    /// This 48-byte field is the output of a SHA-384 digest with input
    /// data determined by the current version of the running hash algorithm
    /// used by the network.&lt;br/>
    /// All new transactions SHALL use algorithm version `3`.&lt;br/>
    /// The bytes of each uint64 or uint32 encoded for the hash input
    /// MUST be in Big-Endian format.
    /// &lt;p>
    /// &lt;hr/>
    /// If the algorithm version is '3', then the input data to the
    /// SHA-384 digest are, in order:
    /// &lt;ol>
    ///   &lt;li>The previous running hash of the topic (48 bytes)&lt;/li>
    ///   &lt;li>The `topicRunningHashVersion` (8 bytes)&lt;/li>
    ///   &lt;li>The payer account's shard (8 bytes)&lt;/li>
    ///   &lt;li>The payer account's realm (8 bytes)&lt;/li>
    ///   &lt;li>The payer account's number (8 bytes)&lt;/li>
    ///   &lt;li>The topic's shard (8 bytes)&lt;/li>
    ///   &lt;li>The topic's realm (8 bytes)&lt;/li>
    ///   &lt;li>The topic's number (8 bytes)&lt;/li>
    ///   &lt;li>The number of seconds since the epoch when the
    ///       `ConsensusSubmitMessage` reached consensus (8 bytes)&lt;/li>
    ///   &lt;li>The number of nanoseconds within the second when the
    ///       `ConsensusSubmitMessage` reached consensus (4 bytes)&lt;/li>
    ///   &lt;li>The `topicSequenceNumber` (8 bytes)&lt;/li>
    ///   &lt;li>The output of a SHA-384 digest of the message bytes from the
    ///       `ConsensusSubmitMessage` (48 bytes)&lt;/li>
    /// &lt;/ol>
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString RunningHash {
      get { return runningHash_; }
      set {
        runningHash_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "sequenceNumber" field.</summary>
    public const int SequenceNumberFieldNumber = 3;
    private ulong sequenceNumber_;
    /// <summary>
    ///*
    /// A current sequence number (starting at 1 for the first message)
    /// for messages on this topic.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ulong SequenceNumber {
      get { return sequenceNumber_; }
      set {
        sequenceNumber_ = value;
      }
    }

    /// <summary>Field number for the "expirationTime" field.</summary>
    public const int ExpirationTimeFieldNumber = 4;
    private global::Hedera.Hashgraph.Proto.Timestamp expirationTime_;
    /// <summary>
    ///*
    /// An expiration time for this topic, in seconds since the epoch.
    /// &lt;p>
    /// For this purpose, `epoch` SHALL be the UNIX epoch
    /// with 0 at `1970-01-01T00:00:00.000Z`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Hedera.Hashgraph.Proto.Timestamp ExpirationTime {
      get { return expirationTime_; }
      set {
        expirationTime_ = value;
      }
    }

    /// <summary>Field number for the "adminKey" field.</summary>
    public const int AdminKeyFieldNumber = 5;
    private global::Hedera.Hashgraph.Proto.Key adminKey_;
    /// <summary>
    ///*
    /// A key that MUST sign any transaction to update or delete this topic.
    /// &lt;p>
    /// If this value is not set (null) then the topic CANNOT be deleted,
    /// modified, or updated.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Hedera.Hashgraph.Proto.Key AdminKey {
      get { return adminKey_; }
      set {
        adminKey_ = value;
      }
    }

    /// <summary>Field number for the "submitKey" field.</summary>
    public const int SubmitKeyFieldNumber = 6;
    private global::Hedera.Hashgraph.Proto.Key submitKey_;
    /// <summary>
    ///*
    /// A key that MUST sign any transaction to submit a message to this topic.
    /// &lt;p>
    /// If this value is not set (null) then any account MAY submit messages to
    /// this topic.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Hedera.Hashgraph.Proto.Key SubmitKey {
      get { return submitKey_; }
      set {
        submitKey_ = value;
      }
    }

    /// <summary>Field number for the "autoRenewPeriod" field.</summary>
    public const int AutoRenewPeriodFieldNumber = 7;
    private global::Hedera.Hashgraph.Proto.Duration autoRenewPeriod_;
    /// <summary>
    ///*
    /// A duration, in seconds, to extend the `expirationTime` value when
    /// this topic is automatically renewed.
    /// &lt;p>
    /// If the `autoRenewAccount` value for this topic is set to a valid account
    /// with sufficient HBAR balance to pay renewal fees when this topic
    /// expires, the system SHALL automatically renew this topic, extending the
    /// `expirationTime` value by the number of seconds described here.&lt;br/>
    /// If, however, the `autoRenewAccount` lacks sufficient HBAR balance
    /// to pay renewal fees when this topic expires, this topic SHALL be
    /// deleted after the time period specified in the `AUTORENEW_GRACE_PERIOD`
    /// configuration value.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Hedera.Hashgraph.Proto.Duration AutoRenewPeriod {
      get { return autoRenewPeriod_; }
      set {
        autoRenewPeriod_ = value;
      }
    }

    /// <summary>Field number for the "autoRenewAccount" field.</summary>
    public const int AutoRenewAccountFieldNumber = 8;
    private global::Hedera.Hashgraph.Proto.AccountID autoRenewAccount_;
    /// <summary>
    ///*
    /// An account that is designated to pay automatic renewal fees.
    /// &lt;p>
    /// If this value is a valid account ID when this topic expires,
    /// this account SHALL be charged the renewal fees for this topic,
    /// if it holds sufficient HBAR balance. If the account does not hold
    /// sufficient HBAR balance to pay renewal fees when necessary, then
    /// this topic SHALL be deleted.&lt;br/>
    /// If this value is not set (null), or is not a valid account ID, when
    /// this topic expires, then this topic SHALL be deleted after the time
    /// period specified in the `AUTORENEW_GRACE_PERIOD` configuration value.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Hedera.Hashgraph.Proto.AccountID AutoRenewAccount {
      get { return autoRenewAccount_; }
      set {
        autoRenewAccount_ = value;
      }
    }

    /// <summary>Field number for the "ledger_id" field.</summary>
    public const int LedgerIdFieldNumber = 9;
    private pb::ByteString ledgerId_ = pb::ByteString.Empty;
    /// <summary>
    ///*
    /// A ledger ID of the network that generated this response.
    /// &lt;p>
    /// This value SHALL identify the distributed ledger that responded to
    /// this query.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString LedgerId {
      get { return ledgerId_; }
      set {
        ledgerId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "fee_schedule_key" field.</summary>
    public const int FeeScheduleKeyFieldNumber = 10;
    private global::Hedera.Hashgraph.Proto.Key feeScheduleKey_;
    /// <summary>
    ///*
    /// Access control for update/delete of custom fees.
    /// &lt;p>
    /// If unset, custom fees CANNOT be set for this topic.&lt;br/>
    /// If not set when the topic is created, this field CANNOT be set via
    /// update.&lt;br/>
    /// If set when the topic is created, this field MAY be changed via update.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Hedera.Hashgraph.Proto.Key FeeScheduleKey {
      get { return feeScheduleKey_; }
      set {
        feeScheduleKey_ = value;
      }
    }

    /// <summary>Field number for the "fee_exempt_key_list" field.</summary>
    public const int FeeExemptKeyListFieldNumber = 11;
    private static readonly pb::FieldCodec<global::Hedera.Hashgraph.Proto.Key> _repeated_feeExemptKeyList_codec
        = pb::FieldCodec.ForMessage(90, global::Hedera.Hashgraph.Proto.Key.Parser);
    private readonly pbc::RepeatedField<global::Hedera.Hashgraph.Proto.Key> feeExemptKeyList_ = new pbc::RepeatedField<global::Hedera.Hashgraph.Proto.Key>();
    /// <summary>
    ///*
    /// A set of keys.&lt;br/>
    /// Keys in this list are permitted to submit messages to this topic without
    /// paying custom fees associated with this topic.
    /// &lt;p>
    /// If a topic submit message is signed by _any_ key included in this set,
    /// custom fees SHALL NOT be charged for that transaction.&lt;br/>
    /// `fee_exempt_key_list` MAY contain keys for accounts that are inactive,
    /// deleted, or non-existent.&lt;br/>
    /// If not set, there SHALL NOT be any fee-exempt keys.  In particular, the
    /// following keys SHALL NOT be implicitly or automatically added to this
    /// list: `adminKey`, `submitKey`, `fee_schedule_key`.
    /// A `fee_exempt_key_list` MUST NOT contain more than
    /// `MAX_ENTRIES_FOR_FEE_EXEMPT_KEY_LIST` keys.
    /// A `fee_exempt_key_list` MUST NOT contain any duplicate keys.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Hedera.Hashgraph.Proto.Key> FeeExemptKeyList {
      get { return feeExemptKeyList_; }
    }

    /// <summary>Field number for the "custom_fees" field.</summary>
    public const int CustomFeesFieldNumber = 12;
    private static readonly pb::FieldCodec<global::Hedera.Hashgraph.Proto.FixedCustomFee> _repeated_customFees_codec
        = pb::FieldCodec.ForMessage(98, global::Hedera.Hashgraph.Proto.FixedCustomFee.Parser);
    private readonly pbc::RepeatedField<global::Hedera.Hashgraph.Proto.FixedCustomFee> customFees_ = new pbc::RepeatedField<global::Hedera.Hashgraph.Proto.FixedCustomFee>();
    /// <summary>
    ///*
    /// A set of custom fee definitions.&lt;br/>
    /// These are fees to be assessed for each submit to this topic.
    /// &lt;p>
    /// Each fee defined in this set SHALL be evaluated for
    /// each message submitted to this topic, and the resultant
    /// total assessed fees SHALL be charged.&lt;br/>
    /// Custom fees defined here SHALL be assessed in addition to the base
    /// network and node fees.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Hedera.Hashgraph.Proto.FixedCustomFee> CustomFees {
      get { return customFees_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ConsensusTopicInfo);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ConsensusTopicInfo other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Memo != other.Memo) return false;
      if (RunningHash != other.RunningHash) return false;
      if (SequenceNumber != other.SequenceNumber) return false;
      if (!object.Equals(ExpirationTime, other.ExpirationTime)) return false;
      if (!object.Equals(AdminKey, other.AdminKey)) return false;
      if (!object.Equals(SubmitKey, other.SubmitKey)) return false;
      if (!object.Equals(AutoRenewPeriod, other.AutoRenewPeriod)) return false;
      if (!object.Equals(AutoRenewAccount, other.AutoRenewAccount)) return false;
      if (LedgerId != other.LedgerId) return false;
      if (!object.Equals(FeeScheduleKey, other.FeeScheduleKey)) return false;
      if(!feeExemptKeyList_.Equals(other.feeExemptKeyList_)) return false;
      if(!customFees_.Equals(other.customFees_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Memo.Length != 0) hash ^= Memo.GetHashCode();
      if (RunningHash.Length != 0) hash ^= RunningHash.GetHashCode();
      if (SequenceNumber != 0UL) hash ^= SequenceNumber.GetHashCode();
      if (expirationTime_ != null) hash ^= ExpirationTime.GetHashCode();
      if (adminKey_ != null) hash ^= AdminKey.GetHashCode();
      if (submitKey_ != null) hash ^= SubmitKey.GetHashCode();
      if (autoRenewPeriod_ != null) hash ^= AutoRenewPeriod.GetHashCode();
      if (autoRenewAccount_ != null) hash ^= AutoRenewAccount.GetHashCode();
      if (LedgerId.Length != 0) hash ^= LedgerId.GetHashCode();
      if (feeScheduleKey_ != null) hash ^= FeeScheduleKey.GetHashCode();
      hash ^= feeExemptKeyList_.GetHashCode();
      hash ^= customFees_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Memo.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Memo);
      }
      if (RunningHash.Length != 0) {
        output.WriteRawTag(18);
        output.WriteBytes(RunningHash);
      }
      if (SequenceNumber != 0UL) {
        output.WriteRawTag(24);
        output.WriteUInt64(SequenceNumber);
      }
      if (expirationTime_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(ExpirationTime);
      }
      if (adminKey_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(AdminKey);
      }
      if (submitKey_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(SubmitKey);
      }
      if (autoRenewPeriod_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(AutoRenewPeriod);
      }
      if (autoRenewAccount_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(AutoRenewAccount);
      }
      if (LedgerId.Length != 0) {
        output.WriteRawTag(74);
        output.WriteBytes(LedgerId);
      }
      if (feeScheduleKey_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(FeeScheduleKey);
      }
      feeExemptKeyList_.WriteTo(output, _repeated_feeExemptKeyList_codec);
      customFees_.WriteTo(output, _repeated_customFees_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Memo.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Memo);
      }
      if (RunningHash.Length != 0) {
        output.WriteRawTag(18);
        output.WriteBytes(RunningHash);
      }
      if (SequenceNumber != 0UL) {
        output.WriteRawTag(24);
        output.WriteUInt64(SequenceNumber);
      }
      if (expirationTime_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(ExpirationTime);
      }
      if (adminKey_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(AdminKey);
      }
      if (submitKey_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(SubmitKey);
      }
      if (autoRenewPeriod_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(AutoRenewPeriod);
      }
      if (autoRenewAccount_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(AutoRenewAccount);
      }
      if (LedgerId.Length != 0) {
        output.WriteRawTag(74);
        output.WriteBytes(LedgerId);
      }
      if (feeScheduleKey_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(FeeScheduleKey);
      }
      feeExemptKeyList_.WriteTo(ref output, _repeated_feeExemptKeyList_codec);
      customFees_.WriteTo(ref output, _repeated_customFees_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Memo.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Memo);
      }
      if (RunningHash.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(RunningHash);
      }
      if (SequenceNumber != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(SequenceNumber);
      }
      if (expirationTime_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ExpirationTime);
      }
      if (adminKey_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(AdminKey);
      }
      if (submitKey_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SubmitKey);
      }
      if (autoRenewPeriod_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(AutoRenewPeriod);
      }
      if (autoRenewAccount_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(AutoRenewAccount);
      }
      if (LedgerId.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(LedgerId);
      }
      if (feeScheduleKey_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(FeeScheduleKey);
      }
      size += feeExemptKeyList_.CalculateSize(_repeated_feeExemptKeyList_codec);
      size += customFees_.CalculateSize(_repeated_customFees_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ConsensusTopicInfo other) {
      if (other == null) {
        return;
      }
      if (other.Memo.Length != 0) {
        Memo = other.Memo;
      }
      if (other.RunningHash.Length != 0) {
        RunningHash = other.RunningHash;
      }
      if (other.SequenceNumber != 0UL) {
        SequenceNumber = other.SequenceNumber;
      }
      if (other.expirationTime_ != null) {
        if (expirationTime_ == null) {
          ExpirationTime = new global::Hedera.Hashgraph.Proto.Timestamp();
        }
        ExpirationTime.MergeFrom(other.ExpirationTime);
      }
      if (other.adminKey_ != null) {
        if (adminKey_ == null) {
          AdminKey = new global::Hedera.Hashgraph.Proto.Key();
        }
        AdminKey.MergeFrom(other.AdminKey);
      }
      if (other.submitKey_ != null) {
        if (submitKey_ == null) {
          SubmitKey = new global::Hedera.Hashgraph.Proto.Key();
        }
        SubmitKey.MergeFrom(other.SubmitKey);
      }
      if (other.autoRenewPeriod_ != null) {
        if (autoRenewPeriod_ == null) {
          AutoRenewPeriod = new global::Hedera.Hashgraph.Proto.Duration();
        }
        AutoRenewPeriod.MergeFrom(other.AutoRenewPeriod);
      }
      if (other.autoRenewAccount_ != null) {
        if (autoRenewAccount_ == null) {
          AutoRenewAccount = new global::Hedera.Hashgraph.Proto.AccountID();
        }
        AutoRenewAccount.MergeFrom(other.AutoRenewAccount);
      }
      if (other.LedgerId.Length != 0) {
        LedgerId = other.LedgerId;
      }
      if (other.feeScheduleKey_ != null) {
        if (feeScheduleKey_ == null) {
          FeeScheduleKey = new global::Hedera.Hashgraph.Proto.Key();
        }
        FeeScheduleKey.MergeFrom(other.FeeScheduleKey);
      }
      feeExemptKeyList_.Add(other.feeExemptKeyList_);
      customFees_.Add(other.customFees_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Memo = input.ReadString();
            break;
          }
          case 18: {
            RunningHash = input.ReadBytes();
            break;
          }
          case 24: {
            SequenceNumber = input.ReadUInt64();
            break;
          }
          case 34: {
            if (expirationTime_ == null) {
              ExpirationTime = new global::Hedera.Hashgraph.Proto.Timestamp();
            }
            input.ReadMessage(ExpirationTime);
            break;
          }
          case 42: {
            if (adminKey_ == null) {
              AdminKey = new global::Hedera.Hashgraph.Proto.Key();
            }
            input.ReadMessage(AdminKey);
            break;
          }
          case 50: {
            if (submitKey_ == null) {
              SubmitKey = new global::Hedera.Hashgraph.Proto.Key();
            }
            input.ReadMessage(SubmitKey);
            break;
          }
          case 58: {
            if (autoRenewPeriod_ == null) {
              AutoRenewPeriod = new global::Hedera.Hashgraph.Proto.Duration();
            }
            input.ReadMessage(AutoRenewPeriod);
            break;
          }
          case 66: {
            if (autoRenewAccount_ == null) {
              AutoRenewAccount = new global::Hedera.Hashgraph.Proto.AccountID();
            }
            input.ReadMessage(AutoRenewAccount);
            break;
          }
          case 74: {
            LedgerId = input.ReadBytes();
            break;
          }
          case 82: {
            if (feeScheduleKey_ == null) {
              FeeScheduleKey = new global::Hedera.Hashgraph.Proto.Key();
            }
            input.ReadMessage(FeeScheduleKey);
            break;
          }
          case 90: {
            feeExemptKeyList_.AddEntriesFrom(input, _repeated_feeExemptKeyList_codec);
            break;
          }
          case 98: {
            customFees_.AddEntriesFrom(input, _repeated_customFees_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Memo = input.ReadString();
            break;
          }
          case 18: {
            RunningHash = input.ReadBytes();
            break;
          }
          case 24: {
            SequenceNumber = input.ReadUInt64();
            break;
          }
          case 34: {
            if (expirationTime_ == null) {
              ExpirationTime = new global::Hedera.Hashgraph.Proto.Timestamp();
            }
            input.ReadMessage(ExpirationTime);
            break;
          }
          case 42: {
            if (adminKey_ == null) {
              AdminKey = new global::Hedera.Hashgraph.Proto.Key();
            }
            input.ReadMessage(AdminKey);
            break;
          }
          case 50: {
            if (submitKey_ == null) {
              SubmitKey = new global::Hedera.Hashgraph.Proto.Key();
            }
            input.ReadMessage(SubmitKey);
            break;
          }
          case 58: {
            if (autoRenewPeriod_ == null) {
              AutoRenewPeriod = new global::Hedera.Hashgraph.Proto.Duration();
            }
            input.ReadMessage(AutoRenewPeriod);
            break;
          }
          case 66: {
            if (autoRenewAccount_ == null) {
              AutoRenewAccount = new global::Hedera.Hashgraph.Proto.AccountID();
            }
            input.ReadMessage(AutoRenewAccount);
            break;
          }
          case 74: {
            LedgerId = input.ReadBytes();
            break;
          }
          case 82: {
            if (feeScheduleKey_ == null) {
              FeeScheduleKey = new global::Hedera.Hashgraph.Proto.Key();
            }
            input.ReadMessage(FeeScheduleKey);
            break;
          }
          case 90: {
            feeExemptKeyList_.AddEntriesFrom(ref input, _repeated_feeExemptKeyList_codec);
            break;
          }
          case 98: {
            customFees_.AddEntriesFrom(ref input, _repeated_customFees_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  #endregion

}

#endregion Designer generated code
