// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: token_service.proto
// </auto-generated>
// Original file comments:
// *
// # Token Service
// gRPC definitions for token service transactions.
//
// ### Keywords
// The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
// "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
// document are to be interpreted as described in
// [RFC2119](https://www.ietf.org/rfc/rfc2119) and clarified in
// [RFC8174](https://www.ietf.org/rfc/rfc8174).
#pragma warning disable 0414, 1591, 8981, 0612
#region Designer generated code

using grpc = global::Grpc.Core;

namespace Hedera.Hashgraph.Proto {
  /// <summary>
  ///*
  /// Transactions and queries for the Token Service
  /// </summary>
  public static partial class TokenService
  {
    static readonly string __ServiceName = "proto.TokenService";

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static void __Helper_SerializeMessage(global::Google.Protobuf.IMessage message, grpc::SerializationContext context)
    {
      #if !GRPC_DISABLE_PROTOBUF_BUFFER_SERIALIZATION
      if (message is global::Google.Protobuf.IBufferMessage)
      {
        context.SetPayloadLength(message.CalculateSize());
        global::Google.Protobuf.MessageExtensions.WriteTo(message, context.GetBufferWriter());
        context.Complete();
        return;
      }
      #endif
      context.Complete(global::Google.Protobuf.MessageExtensions.ToByteArray(message));
    }

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static class __Helper_MessageCache<T>
    {
      public static readonly bool IsBufferMessage = global::System.Reflection.IntrospectionExtensions.GetTypeInfo(typeof(global::Google.Protobuf.IBufferMessage)).IsAssignableFrom(typeof(T));
    }

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static T __Helper_DeserializeMessage<T>(grpc::DeserializationContext context, global::Google.Protobuf.MessageParser<T> parser) where T : global::Google.Protobuf.IMessage<T>
    {
      #if !GRPC_DISABLE_PROTOBUF_BUFFER_SERIALIZATION
      if (__Helper_MessageCache<T>.IsBufferMessage)
      {
        return parser.ParseFrom(context.PayloadAsReadOnlySequence());
      }
      #endif
      return parser.ParseFrom(context.PayloadAsNewBuffer());
    }

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::Hedera.Hashgraph.Proto.Transaction> __Marshaller_proto_Transaction = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Hedera.Hashgraph.Proto.Transaction.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::Hedera.Hashgraph.Proto.TransactionResponse> __Marshaller_proto_TransactionResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Hedera.Hashgraph.Proto.TransactionResponse.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::Hedera.Hashgraph.Proto.Query> __Marshaller_proto_Query = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Hedera.Hashgraph.Proto.Query.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::Hedera.Hashgraph.Proto.Response> __Marshaller_proto_Response = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Hedera.Hashgraph.Proto.Response.Parser));

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse> __Method_createToken = new grpc::Method<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "createToken",
        __Marshaller_proto_Transaction,
        __Marshaller_proto_TransactionResponse);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse> __Method_updateToken = new grpc::Method<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "updateToken",
        __Marshaller_proto_Transaction,
        __Marshaller_proto_TransactionResponse);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse> __Method_mintToken = new grpc::Method<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "mintToken",
        __Marshaller_proto_Transaction,
        __Marshaller_proto_TransactionResponse);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse> __Method_burnToken = new grpc::Method<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "burnToken",
        __Marshaller_proto_Transaction,
        __Marshaller_proto_TransactionResponse);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse> __Method_deleteToken = new grpc::Method<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "deleteToken",
        __Marshaller_proto_Transaction,
        __Marshaller_proto_TransactionResponse);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse> __Method_wipeTokenAccount = new grpc::Method<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "wipeTokenAccount",
        __Marshaller_proto_Transaction,
        __Marshaller_proto_TransactionResponse);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse> __Method_freezeTokenAccount = new grpc::Method<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "freezeTokenAccount",
        __Marshaller_proto_Transaction,
        __Marshaller_proto_TransactionResponse);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse> __Method_unfreezeTokenAccount = new grpc::Method<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "unfreezeTokenAccount",
        __Marshaller_proto_Transaction,
        __Marshaller_proto_TransactionResponse);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse> __Method_grantKycToTokenAccount = new grpc::Method<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "grantKycToTokenAccount",
        __Marshaller_proto_Transaction,
        __Marshaller_proto_TransactionResponse);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse> __Method_revokeKycFromTokenAccount = new grpc::Method<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "revokeKycFromTokenAccount",
        __Marshaller_proto_Transaction,
        __Marshaller_proto_TransactionResponse);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse> __Method_associateTokens = new grpc::Method<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "associateTokens",
        __Marshaller_proto_Transaction,
        __Marshaller_proto_TransactionResponse);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse> __Method_dissociateTokens = new grpc::Method<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "dissociateTokens",
        __Marshaller_proto_Transaction,
        __Marshaller_proto_TransactionResponse);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse> __Method_updateTokenFeeSchedule = new grpc::Method<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "updateTokenFeeSchedule",
        __Marshaller_proto_Transaction,
        __Marshaller_proto_TransactionResponse);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::Hedera.Hashgraph.Proto.Query, global::Hedera.Hashgraph.Proto.Response> __Method_getTokenInfo = new grpc::Method<global::Hedera.Hashgraph.Proto.Query, global::Hedera.Hashgraph.Proto.Response>(
        grpc::MethodType.Unary,
        __ServiceName,
        "getTokenInfo",
        __Marshaller_proto_Query,
        __Marshaller_proto_Response);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::Hedera.Hashgraph.Proto.Query, global::Hedera.Hashgraph.Proto.Response> __Method_getTokenNftInfo = new grpc::Method<global::Hedera.Hashgraph.Proto.Query, global::Hedera.Hashgraph.Proto.Response>(
        grpc::MethodType.Unary,
        __ServiceName,
        "getTokenNftInfo",
        __Marshaller_proto_Query,
        __Marshaller_proto_Response);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse> __Method_pauseToken = new grpc::Method<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "pauseToken",
        __Marshaller_proto_Transaction,
        __Marshaller_proto_TransactionResponse);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse> __Method_unpauseToken = new grpc::Method<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "unpauseToken",
        __Marshaller_proto_Transaction,
        __Marshaller_proto_TransactionResponse);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse> __Method_updateNfts = new grpc::Method<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "updateNfts",
        __Marshaller_proto_Transaction,
        __Marshaller_proto_TransactionResponse);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse> __Method_rejectToken = new grpc::Method<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "rejectToken",
        __Marshaller_proto_Transaction,
        __Marshaller_proto_TransactionResponse);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse> __Method_airdropTokens = new grpc::Method<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "airdropTokens",
        __Marshaller_proto_Transaction,
        __Marshaller_proto_TransactionResponse);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse> __Method_cancelAirdrop = new grpc::Method<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "cancelAirdrop",
        __Marshaller_proto_Transaction,
        __Marshaller_proto_TransactionResponse);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse> __Method_claimAirdrop = new grpc::Method<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "claimAirdrop",
        __Marshaller_proto_Transaction,
        __Marshaller_proto_TransactionResponse);

    /// <summary>Service descriptor</summary>
    public static global::Google.Protobuf.Reflection.ServiceDescriptor Descriptor
    {
      get { return global::Hedera.Hashgraph.Proto.TokenServiceReflection.Descriptor.Services[0]; }
    }

    /// <summary>Base class for server-side implementations of TokenService</summary>
    [grpc::BindServiceMethod(typeof(TokenService), "BindService")]
    public abstract partial class TokenServiceBase
    {
      /// <summary>
      ///*
      /// Create a new token.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::Hedera.Hashgraph.Proto.TransactionResponse> createToken(global::Hedera.Hashgraph.Proto.Transaction request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///*
      /// Update a token.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::Hedera.Hashgraph.Proto.TransactionResponse> updateToken(global::Hedera.Hashgraph.Proto.Transaction request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///*
      /// Mint one or more tokens to the treasury account.
      /// &lt;p>
      /// This MAY specify a quantity of fungible/common tokens or
      /// a list of specific non-fungible/unique tokes, but
      /// MUST NOT specify both.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::Hedera.Hashgraph.Proto.TransactionResponse> mintToken(global::Hedera.Hashgraph.Proto.Transaction request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///*
      /// Burn one or more tokens from the treasury account.
      /// &lt;p>
      /// This MAY specify a quantity of fungible/common tokens or
      /// a list of specific non-fungible/unique tokes, but
      /// MUST NOT specify both.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::Hedera.Hashgraph.Proto.TransactionResponse> burnToken(global::Hedera.Hashgraph.Proto.Transaction request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///*
      /// Delete a token.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::Hedera.Hashgraph.Proto.TransactionResponse> deleteToken(global::Hedera.Hashgraph.Proto.Transaction request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///*
      /// Wipe one or more tokens from an identified Account.
      /// &lt;p>
      /// This MAY specify a quantity of fungible/common tokens or
      /// a list of specific non-fungible/unique tokes, but
      /// MUST NOT specify both.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::Hedera.Hashgraph.Proto.TransactionResponse> wipeTokenAccount(global::Hedera.Hashgraph.Proto.Transaction request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///*
      /// Freeze the transfer of tokens to or from an identified Account.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::Hedera.Hashgraph.Proto.TransactionResponse> freezeTokenAccount(global::Hedera.Hashgraph.Proto.Transaction request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///*
      /// Unfreeze the transfer of tokens to or from an identified Account.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::Hedera.Hashgraph.Proto.TransactionResponse> unfreezeTokenAccount(global::Hedera.Hashgraph.Proto.Transaction request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///*
      /// Assert that KYC requirements are met for a specific account with
      /// respect to a specific token.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::Hedera.Hashgraph.Proto.TransactionResponse> grantKycToTokenAccount(global::Hedera.Hashgraph.Proto.Transaction request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///*
      /// Assert that KYC requirements are _not_ met for a specific account with
      /// respect to a specific token.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::Hedera.Hashgraph.Proto.TransactionResponse> revokeKycFromTokenAccount(global::Hedera.Hashgraph.Proto.Transaction request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///*
      /// Associate one or more tokens to an account.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::Hedera.Hashgraph.Proto.TransactionResponse> associateTokens(global::Hedera.Hashgraph.Proto.Transaction request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///*
      /// Dissociate one or more tokens from an account.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::Hedera.Hashgraph.Proto.TransactionResponse> dissociateTokens(global::Hedera.Hashgraph.Proto.Transaction request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///*
      /// Update the custom fee schedule for a token.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::Hedera.Hashgraph.Proto.TransactionResponse> updateTokenFeeSchedule(global::Hedera.Hashgraph.Proto.Transaction request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///*
      /// Retrieve the detail characteristics for a token.
      /// &lt;p>
      /// This query SHALL return information for the token type as a whole.&lt;br/>
      /// This query SHALL NOT return information for individual tokens.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::Hedera.Hashgraph.Proto.Response> getTokenInfo(global::Hedera.Hashgraph.Proto.Query request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///*
      /// Retrieve the metadata for a specific non-fungible/unique token.&lt;br/>
      /// The NFT to query is identified by token identifier and serial number.
      /// &lt;p>
      /// This query SHALL return token metadata and, if an allowance is defined,
      /// the designated "spender" account for the queried NFT.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::Hedera.Hashgraph.Proto.Response> getTokenNftInfo(global::Hedera.Hashgraph.Proto.Query request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///*
      /// Pause a token.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::Hedera.Hashgraph.Proto.TransactionResponse> pauseToken(global::Hedera.Hashgraph.Proto.Transaction request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///*
      /// Unpause (resume) a token.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::Hedera.Hashgraph.Proto.TransactionResponse> unpauseToken(global::Hedera.Hashgraph.Proto.Transaction request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///*
      /// Update multiple non-fungible/unique tokens (NFTs) in a collection.&lt;br/>
      /// The NFTs are identified by token identifier and one or more
      /// serial numbers.
      /// &lt;p>
      /// This transaction SHALL update NFT metadata only.&lt;br/>
      /// This transaction MUST be signed by the token `metadata_key`.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::Hedera.Hashgraph.Proto.TransactionResponse> updateNfts(global::Hedera.Hashgraph.Proto.Transaction request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///*
      /// Reject one or more tokens.
      /// &lt;p>
      /// This transaction SHALL transfer the full balance of one or more tokens
      /// from the requesting account to the treasury for each token.&lt;br/>
      /// This transfer SHALL NOT charge any custom fee or royalty defined for
      /// the token(s) to be rejected.&lt;br/>
      /// ### Effects on success
      /// &lt;ul>
      ///   &lt;li>If the rejected token is fungible/common, the requesting account
      ///       SHALL have a balance of 0 for the rejected token.&lt;br/>
      ///       The treasury balance SHALL increase by the amount that the
      ///       requesting account decreased.&lt;/li>
      ///   &lt;li>If the rejected token is non-fungible/unique the requesting
      ///       account SHALL NOT hold the specific serialized token that
      ///       is rejected.&lt;br/>
      ///       The treasury account SHALL hold each specific serialized token
      ///       that was rejected.&lt;/li>
      /// &lt;/li>
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::Hedera.Hashgraph.Proto.TransactionResponse> rejectToken(global::Hedera.Hashgraph.Proto.Transaction request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///*
      /// Airdrop one or more tokens to one or more accounts.
      /// &lt;p>
      /// This transaction SHALL distribute tokens from the balance of one or
      /// more sending account(s) to the balance of one or more
      /// recipient accounts.&lt;br/>
      /// Accounts SHALL receive the tokens in one of four ways.
      /// &lt;ul>
      ///   &lt;li>An account already associated to the token to be distributed
      ///       SHALL receive the airdropped tokens immediately to the
      ///       recipient account balance.&lt;/li>
      ///   &lt;li>An account with available automatic association slots SHALL
      ///       be automatically associated to the token, and SHALL
      ///       immediately receive the airdropped tokens to the recipient
      ///       account balance.&lt;/li>
      ///   &lt;li>An account with "receiver signature required" set SHALL have
      ///       a "Pending Airdrop" created and MUST claim that airdrop with
      ///       a `claimAirdrop` transaction.&lt;/li>
      ///   &lt;li>An account with no available automatic association slots SHALL
      ///       have a "Pending Airdrop" created and MUST claim that airdrop
      ///       with a `claimAirdrop` transaction. &lt;/li>
      /// &lt;/ul>
      /// Any airdrop that completes immediately SHALL be irreversible.&lt;br/>
      /// Any airdrop that results in a "Pending Airdrop" MAY be canceled via
      /// a `cancelAirdrop` transaction.&lt;br/>
      /// All transfer fees (including custom fees and royalties), as well as
      /// the rent cost for the first auto-renewal period for any
      /// automatic-association slot occupied by the airdropped tokens,
      /// SHALL be charged to the account submitting this transaction.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::Hedera.Hashgraph.Proto.TransactionResponse> airdropTokens(global::Hedera.Hashgraph.Proto.Transaction request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///*
      /// Cancel one or more pending airdrops.
      /// &lt;p>
      /// This transaction MUST be signed by _each_ account *sending* an
      /// airdrop to be canceled.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::Hedera.Hashgraph.Proto.TransactionResponse> cancelAirdrop(global::Hedera.Hashgraph.Proto.Transaction request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///*
      /// Claim one or more pending airdrops.
      /// &lt;p>
      /// This transaction MUST be signed by _each_ account **receiving**
      /// an airdrop to be claimed.&lt;br>
      /// If a "Sender" lacks sufficient balance to fulfill the airdrop at
      /// the time the claim is made, that claim SHALL fail.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::Hedera.Hashgraph.Proto.TransactionResponse> claimAirdrop(global::Hedera.Hashgraph.Proto.Transaction request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

    }

    /// <summary>Client for TokenService</summary>
    public partial class TokenServiceClient : grpc::ClientBase<TokenServiceClient>
    {
      /// <summary>Creates a new client for TokenService</summary>
      /// <param name="channel">The channel to use to make remote calls.</param>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public TokenServiceClient(grpc::ChannelBase channel) : base(channel)
      {
      }
      /// <summary>Creates a new client for TokenService that uses a custom <c>CallInvoker</c>.</summary>
      /// <param name="callInvoker">The callInvoker to use to make remote calls.</param>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public TokenServiceClient(grpc::CallInvoker callInvoker) : base(callInvoker)
      {
      }
      /// <summary>Protected parameterless constructor to allow creation of test doubles.</summary>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      protected TokenServiceClient() : base()
      {
      }
      /// <summary>Protected constructor to allow creation of configured clients.</summary>
      /// <param name="configuration">The client configuration.</param>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      protected TokenServiceClient(ClientBaseConfiguration configuration) : base(configuration)
      {
      }

      /// <summary>
      ///*
      /// Create a new token.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Hedera.Hashgraph.Proto.TransactionResponse createToken(global::Hedera.Hashgraph.Proto.Transaction request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return createToken(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      /// Create a new token.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Hedera.Hashgraph.Proto.TransactionResponse createToken(global::Hedera.Hashgraph.Proto.Transaction request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_createToken, null, options, request);
      }
      /// <summary>
      ///*
      /// Create a new token.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Hedera.Hashgraph.Proto.TransactionResponse> createTokenAsync(global::Hedera.Hashgraph.Proto.Transaction request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return createTokenAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      /// Create a new token.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Hedera.Hashgraph.Proto.TransactionResponse> createTokenAsync(global::Hedera.Hashgraph.Proto.Transaction request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_createToken, null, options, request);
      }
      /// <summary>
      ///*
      /// Update a token.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Hedera.Hashgraph.Proto.TransactionResponse updateToken(global::Hedera.Hashgraph.Proto.Transaction request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return updateToken(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      /// Update a token.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Hedera.Hashgraph.Proto.TransactionResponse updateToken(global::Hedera.Hashgraph.Proto.Transaction request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_updateToken, null, options, request);
      }
      /// <summary>
      ///*
      /// Update a token.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Hedera.Hashgraph.Proto.TransactionResponse> updateTokenAsync(global::Hedera.Hashgraph.Proto.Transaction request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return updateTokenAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      /// Update a token.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Hedera.Hashgraph.Proto.TransactionResponse> updateTokenAsync(global::Hedera.Hashgraph.Proto.Transaction request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_updateToken, null, options, request);
      }
      /// <summary>
      ///*
      /// Mint one or more tokens to the treasury account.
      /// &lt;p>
      /// This MAY specify a quantity of fungible/common tokens or
      /// a list of specific non-fungible/unique tokes, but
      /// MUST NOT specify both.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Hedera.Hashgraph.Proto.TransactionResponse mintToken(global::Hedera.Hashgraph.Proto.Transaction request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return mintToken(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      /// Mint one or more tokens to the treasury account.
      /// &lt;p>
      /// This MAY specify a quantity of fungible/common tokens or
      /// a list of specific non-fungible/unique tokes, but
      /// MUST NOT specify both.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Hedera.Hashgraph.Proto.TransactionResponse mintToken(global::Hedera.Hashgraph.Proto.Transaction request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_mintToken, null, options, request);
      }
      /// <summary>
      ///*
      /// Mint one or more tokens to the treasury account.
      /// &lt;p>
      /// This MAY specify a quantity of fungible/common tokens or
      /// a list of specific non-fungible/unique tokes, but
      /// MUST NOT specify both.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Hedera.Hashgraph.Proto.TransactionResponse> mintTokenAsync(global::Hedera.Hashgraph.Proto.Transaction request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return mintTokenAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      /// Mint one or more tokens to the treasury account.
      /// &lt;p>
      /// This MAY specify a quantity of fungible/common tokens or
      /// a list of specific non-fungible/unique tokes, but
      /// MUST NOT specify both.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Hedera.Hashgraph.Proto.TransactionResponse> mintTokenAsync(global::Hedera.Hashgraph.Proto.Transaction request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_mintToken, null, options, request);
      }
      /// <summary>
      ///*
      /// Burn one or more tokens from the treasury account.
      /// &lt;p>
      /// This MAY specify a quantity of fungible/common tokens or
      /// a list of specific non-fungible/unique tokes, but
      /// MUST NOT specify both.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Hedera.Hashgraph.Proto.TransactionResponse burnToken(global::Hedera.Hashgraph.Proto.Transaction request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return burnToken(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      /// Burn one or more tokens from the treasury account.
      /// &lt;p>
      /// This MAY specify a quantity of fungible/common tokens or
      /// a list of specific non-fungible/unique tokes, but
      /// MUST NOT specify both.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Hedera.Hashgraph.Proto.TransactionResponse burnToken(global::Hedera.Hashgraph.Proto.Transaction request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_burnToken, null, options, request);
      }
      /// <summary>
      ///*
      /// Burn one or more tokens from the treasury account.
      /// &lt;p>
      /// This MAY specify a quantity of fungible/common tokens or
      /// a list of specific non-fungible/unique tokes, but
      /// MUST NOT specify both.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Hedera.Hashgraph.Proto.TransactionResponse> burnTokenAsync(global::Hedera.Hashgraph.Proto.Transaction request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return burnTokenAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      /// Burn one or more tokens from the treasury account.
      /// &lt;p>
      /// This MAY specify a quantity of fungible/common tokens or
      /// a list of specific non-fungible/unique tokes, but
      /// MUST NOT specify both.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Hedera.Hashgraph.Proto.TransactionResponse> burnTokenAsync(global::Hedera.Hashgraph.Proto.Transaction request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_burnToken, null, options, request);
      }
      /// <summary>
      ///*
      /// Delete a token.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Hedera.Hashgraph.Proto.TransactionResponse deleteToken(global::Hedera.Hashgraph.Proto.Transaction request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return deleteToken(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      /// Delete a token.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Hedera.Hashgraph.Proto.TransactionResponse deleteToken(global::Hedera.Hashgraph.Proto.Transaction request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_deleteToken, null, options, request);
      }
      /// <summary>
      ///*
      /// Delete a token.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Hedera.Hashgraph.Proto.TransactionResponse> deleteTokenAsync(global::Hedera.Hashgraph.Proto.Transaction request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return deleteTokenAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      /// Delete a token.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Hedera.Hashgraph.Proto.TransactionResponse> deleteTokenAsync(global::Hedera.Hashgraph.Proto.Transaction request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_deleteToken, null, options, request);
      }
      /// <summary>
      ///*
      /// Wipe one or more tokens from an identified Account.
      /// &lt;p>
      /// This MAY specify a quantity of fungible/common tokens or
      /// a list of specific non-fungible/unique tokes, but
      /// MUST NOT specify both.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Hedera.Hashgraph.Proto.TransactionResponse wipeTokenAccount(global::Hedera.Hashgraph.Proto.Transaction request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return wipeTokenAccount(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      /// Wipe one or more tokens from an identified Account.
      /// &lt;p>
      /// This MAY specify a quantity of fungible/common tokens or
      /// a list of specific non-fungible/unique tokes, but
      /// MUST NOT specify both.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Hedera.Hashgraph.Proto.TransactionResponse wipeTokenAccount(global::Hedera.Hashgraph.Proto.Transaction request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_wipeTokenAccount, null, options, request);
      }
      /// <summary>
      ///*
      /// Wipe one or more tokens from an identified Account.
      /// &lt;p>
      /// This MAY specify a quantity of fungible/common tokens or
      /// a list of specific non-fungible/unique tokes, but
      /// MUST NOT specify both.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Hedera.Hashgraph.Proto.TransactionResponse> wipeTokenAccountAsync(global::Hedera.Hashgraph.Proto.Transaction request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return wipeTokenAccountAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      /// Wipe one or more tokens from an identified Account.
      /// &lt;p>
      /// This MAY specify a quantity of fungible/common tokens or
      /// a list of specific non-fungible/unique tokes, but
      /// MUST NOT specify both.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Hedera.Hashgraph.Proto.TransactionResponse> wipeTokenAccountAsync(global::Hedera.Hashgraph.Proto.Transaction request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_wipeTokenAccount, null, options, request);
      }
      /// <summary>
      ///*
      /// Freeze the transfer of tokens to or from an identified Account.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Hedera.Hashgraph.Proto.TransactionResponse freezeTokenAccount(global::Hedera.Hashgraph.Proto.Transaction request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return freezeTokenAccount(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      /// Freeze the transfer of tokens to or from an identified Account.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Hedera.Hashgraph.Proto.TransactionResponse freezeTokenAccount(global::Hedera.Hashgraph.Proto.Transaction request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_freezeTokenAccount, null, options, request);
      }
      /// <summary>
      ///*
      /// Freeze the transfer of tokens to or from an identified Account.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Hedera.Hashgraph.Proto.TransactionResponse> freezeTokenAccountAsync(global::Hedera.Hashgraph.Proto.Transaction request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return freezeTokenAccountAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      /// Freeze the transfer of tokens to or from an identified Account.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Hedera.Hashgraph.Proto.TransactionResponse> freezeTokenAccountAsync(global::Hedera.Hashgraph.Proto.Transaction request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_freezeTokenAccount, null, options, request);
      }
      /// <summary>
      ///*
      /// Unfreeze the transfer of tokens to or from an identified Account.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Hedera.Hashgraph.Proto.TransactionResponse unfreezeTokenAccount(global::Hedera.Hashgraph.Proto.Transaction request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return unfreezeTokenAccount(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      /// Unfreeze the transfer of tokens to or from an identified Account.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Hedera.Hashgraph.Proto.TransactionResponse unfreezeTokenAccount(global::Hedera.Hashgraph.Proto.Transaction request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_unfreezeTokenAccount, null, options, request);
      }
      /// <summary>
      ///*
      /// Unfreeze the transfer of tokens to or from an identified Account.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Hedera.Hashgraph.Proto.TransactionResponse> unfreezeTokenAccountAsync(global::Hedera.Hashgraph.Proto.Transaction request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return unfreezeTokenAccountAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      /// Unfreeze the transfer of tokens to or from an identified Account.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Hedera.Hashgraph.Proto.TransactionResponse> unfreezeTokenAccountAsync(global::Hedera.Hashgraph.Proto.Transaction request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_unfreezeTokenAccount, null, options, request);
      }
      /// <summary>
      ///*
      /// Assert that KYC requirements are met for a specific account with
      /// respect to a specific token.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Hedera.Hashgraph.Proto.TransactionResponse grantKycToTokenAccount(global::Hedera.Hashgraph.Proto.Transaction request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return grantKycToTokenAccount(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      /// Assert that KYC requirements are met for a specific account with
      /// respect to a specific token.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Hedera.Hashgraph.Proto.TransactionResponse grantKycToTokenAccount(global::Hedera.Hashgraph.Proto.Transaction request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_grantKycToTokenAccount, null, options, request);
      }
      /// <summary>
      ///*
      /// Assert that KYC requirements are met for a specific account with
      /// respect to a specific token.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Hedera.Hashgraph.Proto.TransactionResponse> grantKycToTokenAccountAsync(global::Hedera.Hashgraph.Proto.Transaction request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return grantKycToTokenAccountAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      /// Assert that KYC requirements are met for a specific account with
      /// respect to a specific token.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Hedera.Hashgraph.Proto.TransactionResponse> grantKycToTokenAccountAsync(global::Hedera.Hashgraph.Proto.Transaction request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_grantKycToTokenAccount, null, options, request);
      }
      /// <summary>
      ///*
      /// Assert that KYC requirements are _not_ met for a specific account with
      /// respect to a specific token.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Hedera.Hashgraph.Proto.TransactionResponse revokeKycFromTokenAccount(global::Hedera.Hashgraph.Proto.Transaction request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return revokeKycFromTokenAccount(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      /// Assert that KYC requirements are _not_ met for a specific account with
      /// respect to a specific token.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Hedera.Hashgraph.Proto.TransactionResponse revokeKycFromTokenAccount(global::Hedera.Hashgraph.Proto.Transaction request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_revokeKycFromTokenAccount, null, options, request);
      }
      /// <summary>
      ///*
      /// Assert that KYC requirements are _not_ met for a specific account with
      /// respect to a specific token.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Hedera.Hashgraph.Proto.TransactionResponse> revokeKycFromTokenAccountAsync(global::Hedera.Hashgraph.Proto.Transaction request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return revokeKycFromTokenAccountAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      /// Assert that KYC requirements are _not_ met for a specific account with
      /// respect to a specific token.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Hedera.Hashgraph.Proto.TransactionResponse> revokeKycFromTokenAccountAsync(global::Hedera.Hashgraph.Proto.Transaction request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_revokeKycFromTokenAccount, null, options, request);
      }
      /// <summary>
      ///*
      /// Associate one or more tokens to an account.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Hedera.Hashgraph.Proto.TransactionResponse associateTokens(global::Hedera.Hashgraph.Proto.Transaction request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return associateTokens(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      /// Associate one or more tokens to an account.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Hedera.Hashgraph.Proto.TransactionResponse associateTokens(global::Hedera.Hashgraph.Proto.Transaction request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_associateTokens, null, options, request);
      }
      /// <summary>
      ///*
      /// Associate one or more tokens to an account.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Hedera.Hashgraph.Proto.TransactionResponse> associateTokensAsync(global::Hedera.Hashgraph.Proto.Transaction request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return associateTokensAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      /// Associate one or more tokens to an account.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Hedera.Hashgraph.Proto.TransactionResponse> associateTokensAsync(global::Hedera.Hashgraph.Proto.Transaction request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_associateTokens, null, options, request);
      }
      /// <summary>
      ///*
      /// Dissociate one or more tokens from an account.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Hedera.Hashgraph.Proto.TransactionResponse dissociateTokens(global::Hedera.Hashgraph.Proto.Transaction request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return dissociateTokens(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      /// Dissociate one or more tokens from an account.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Hedera.Hashgraph.Proto.TransactionResponse dissociateTokens(global::Hedera.Hashgraph.Proto.Transaction request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_dissociateTokens, null, options, request);
      }
      /// <summary>
      ///*
      /// Dissociate one or more tokens from an account.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Hedera.Hashgraph.Proto.TransactionResponse> dissociateTokensAsync(global::Hedera.Hashgraph.Proto.Transaction request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return dissociateTokensAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      /// Dissociate one or more tokens from an account.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Hedera.Hashgraph.Proto.TransactionResponse> dissociateTokensAsync(global::Hedera.Hashgraph.Proto.Transaction request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_dissociateTokens, null, options, request);
      }
      /// <summary>
      ///*
      /// Update the custom fee schedule for a token.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Hedera.Hashgraph.Proto.TransactionResponse updateTokenFeeSchedule(global::Hedera.Hashgraph.Proto.Transaction request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return updateTokenFeeSchedule(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      /// Update the custom fee schedule for a token.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Hedera.Hashgraph.Proto.TransactionResponse updateTokenFeeSchedule(global::Hedera.Hashgraph.Proto.Transaction request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_updateTokenFeeSchedule, null, options, request);
      }
      /// <summary>
      ///*
      /// Update the custom fee schedule for a token.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Hedera.Hashgraph.Proto.TransactionResponse> updateTokenFeeScheduleAsync(global::Hedera.Hashgraph.Proto.Transaction request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return updateTokenFeeScheduleAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      /// Update the custom fee schedule for a token.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Hedera.Hashgraph.Proto.TransactionResponse> updateTokenFeeScheduleAsync(global::Hedera.Hashgraph.Proto.Transaction request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_updateTokenFeeSchedule, null, options, request);
      }
      /// <summary>
      ///*
      /// Retrieve the detail characteristics for a token.
      /// &lt;p>
      /// This query SHALL return information for the token type as a whole.&lt;br/>
      /// This query SHALL NOT return information for individual tokens.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Hedera.Hashgraph.Proto.Response getTokenInfo(global::Hedera.Hashgraph.Proto.Query request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return getTokenInfo(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      /// Retrieve the detail characteristics for a token.
      /// &lt;p>
      /// This query SHALL return information for the token type as a whole.&lt;br/>
      /// This query SHALL NOT return information for individual tokens.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Hedera.Hashgraph.Proto.Response getTokenInfo(global::Hedera.Hashgraph.Proto.Query request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_getTokenInfo, null, options, request);
      }
      /// <summary>
      ///*
      /// Retrieve the detail characteristics for a token.
      /// &lt;p>
      /// This query SHALL return information for the token type as a whole.&lt;br/>
      /// This query SHALL NOT return information for individual tokens.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Hedera.Hashgraph.Proto.Response> getTokenInfoAsync(global::Hedera.Hashgraph.Proto.Query request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return getTokenInfoAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      /// Retrieve the detail characteristics for a token.
      /// &lt;p>
      /// This query SHALL return information for the token type as a whole.&lt;br/>
      /// This query SHALL NOT return information for individual tokens.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Hedera.Hashgraph.Proto.Response> getTokenInfoAsync(global::Hedera.Hashgraph.Proto.Query request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_getTokenInfo, null, options, request);
      }
      /// <summary>
      ///*
      /// Retrieve the metadata for a specific non-fungible/unique token.&lt;br/>
      /// The NFT to query is identified by token identifier and serial number.
      /// &lt;p>
      /// This query SHALL return token metadata and, if an allowance is defined,
      /// the designated "spender" account for the queried NFT.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Hedera.Hashgraph.Proto.Response getTokenNftInfo(global::Hedera.Hashgraph.Proto.Query request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return getTokenNftInfo(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      /// Retrieve the metadata for a specific non-fungible/unique token.&lt;br/>
      /// The NFT to query is identified by token identifier and serial number.
      /// &lt;p>
      /// This query SHALL return token metadata and, if an allowance is defined,
      /// the designated "spender" account for the queried NFT.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Hedera.Hashgraph.Proto.Response getTokenNftInfo(global::Hedera.Hashgraph.Proto.Query request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_getTokenNftInfo, null, options, request);
      }
      /// <summary>
      ///*
      /// Retrieve the metadata for a specific non-fungible/unique token.&lt;br/>
      /// The NFT to query is identified by token identifier and serial number.
      /// &lt;p>
      /// This query SHALL return token metadata and, if an allowance is defined,
      /// the designated "spender" account for the queried NFT.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Hedera.Hashgraph.Proto.Response> getTokenNftInfoAsync(global::Hedera.Hashgraph.Proto.Query request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return getTokenNftInfoAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      /// Retrieve the metadata for a specific non-fungible/unique token.&lt;br/>
      /// The NFT to query is identified by token identifier and serial number.
      /// &lt;p>
      /// This query SHALL return token metadata and, if an allowance is defined,
      /// the designated "spender" account for the queried NFT.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Hedera.Hashgraph.Proto.Response> getTokenNftInfoAsync(global::Hedera.Hashgraph.Proto.Query request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_getTokenNftInfo, null, options, request);
      }
      /// <summary>
      ///*
      /// Pause a token.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Hedera.Hashgraph.Proto.TransactionResponse pauseToken(global::Hedera.Hashgraph.Proto.Transaction request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return pauseToken(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      /// Pause a token.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Hedera.Hashgraph.Proto.TransactionResponse pauseToken(global::Hedera.Hashgraph.Proto.Transaction request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_pauseToken, null, options, request);
      }
      /// <summary>
      ///*
      /// Pause a token.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Hedera.Hashgraph.Proto.TransactionResponse> pauseTokenAsync(global::Hedera.Hashgraph.Proto.Transaction request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return pauseTokenAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      /// Pause a token.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Hedera.Hashgraph.Proto.TransactionResponse> pauseTokenAsync(global::Hedera.Hashgraph.Proto.Transaction request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_pauseToken, null, options, request);
      }
      /// <summary>
      ///*
      /// Unpause (resume) a token.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Hedera.Hashgraph.Proto.TransactionResponse unpauseToken(global::Hedera.Hashgraph.Proto.Transaction request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return unpauseToken(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      /// Unpause (resume) a token.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Hedera.Hashgraph.Proto.TransactionResponse unpauseToken(global::Hedera.Hashgraph.Proto.Transaction request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_unpauseToken, null, options, request);
      }
      /// <summary>
      ///*
      /// Unpause (resume) a token.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Hedera.Hashgraph.Proto.TransactionResponse> unpauseTokenAsync(global::Hedera.Hashgraph.Proto.Transaction request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return unpauseTokenAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      /// Unpause (resume) a token.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Hedera.Hashgraph.Proto.TransactionResponse> unpauseTokenAsync(global::Hedera.Hashgraph.Proto.Transaction request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_unpauseToken, null, options, request);
      }
      /// <summary>
      ///*
      /// Update multiple non-fungible/unique tokens (NFTs) in a collection.&lt;br/>
      /// The NFTs are identified by token identifier and one or more
      /// serial numbers.
      /// &lt;p>
      /// This transaction SHALL update NFT metadata only.&lt;br/>
      /// This transaction MUST be signed by the token `metadata_key`.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Hedera.Hashgraph.Proto.TransactionResponse updateNfts(global::Hedera.Hashgraph.Proto.Transaction request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return updateNfts(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      /// Update multiple non-fungible/unique tokens (NFTs) in a collection.&lt;br/>
      /// The NFTs are identified by token identifier and one or more
      /// serial numbers.
      /// &lt;p>
      /// This transaction SHALL update NFT metadata only.&lt;br/>
      /// This transaction MUST be signed by the token `metadata_key`.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Hedera.Hashgraph.Proto.TransactionResponse updateNfts(global::Hedera.Hashgraph.Proto.Transaction request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_updateNfts, null, options, request);
      }
      /// <summary>
      ///*
      /// Update multiple non-fungible/unique tokens (NFTs) in a collection.&lt;br/>
      /// The NFTs are identified by token identifier and one or more
      /// serial numbers.
      /// &lt;p>
      /// This transaction SHALL update NFT metadata only.&lt;br/>
      /// This transaction MUST be signed by the token `metadata_key`.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Hedera.Hashgraph.Proto.TransactionResponse> updateNftsAsync(global::Hedera.Hashgraph.Proto.Transaction request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return updateNftsAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      /// Update multiple non-fungible/unique tokens (NFTs) in a collection.&lt;br/>
      /// The NFTs are identified by token identifier and one or more
      /// serial numbers.
      /// &lt;p>
      /// This transaction SHALL update NFT metadata only.&lt;br/>
      /// This transaction MUST be signed by the token `metadata_key`.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Hedera.Hashgraph.Proto.TransactionResponse> updateNftsAsync(global::Hedera.Hashgraph.Proto.Transaction request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_updateNfts, null, options, request);
      }
      /// <summary>
      ///*
      /// Reject one or more tokens.
      /// &lt;p>
      /// This transaction SHALL transfer the full balance of one or more tokens
      /// from the requesting account to the treasury for each token.&lt;br/>
      /// This transfer SHALL NOT charge any custom fee or royalty defined for
      /// the token(s) to be rejected.&lt;br/>
      /// ### Effects on success
      /// &lt;ul>
      ///   &lt;li>If the rejected token is fungible/common, the requesting account
      ///       SHALL have a balance of 0 for the rejected token.&lt;br/>
      ///       The treasury balance SHALL increase by the amount that the
      ///       requesting account decreased.&lt;/li>
      ///   &lt;li>If the rejected token is non-fungible/unique the requesting
      ///       account SHALL NOT hold the specific serialized token that
      ///       is rejected.&lt;br/>
      ///       The treasury account SHALL hold each specific serialized token
      ///       that was rejected.&lt;/li>
      /// &lt;/li>
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Hedera.Hashgraph.Proto.TransactionResponse rejectToken(global::Hedera.Hashgraph.Proto.Transaction request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return rejectToken(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      /// Reject one or more tokens.
      /// &lt;p>
      /// This transaction SHALL transfer the full balance of one or more tokens
      /// from the requesting account to the treasury for each token.&lt;br/>
      /// This transfer SHALL NOT charge any custom fee or royalty defined for
      /// the token(s) to be rejected.&lt;br/>
      /// ### Effects on success
      /// &lt;ul>
      ///   &lt;li>If the rejected token is fungible/common, the requesting account
      ///       SHALL have a balance of 0 for the rejected token.&lt;br/>
      ///       The treasury balance SHALL increase by the amount that the
      ///       requesting account decreased.&lt;/li>
      ///   &lt;li>If the rejected token is non-fungible/unique the requesting
      ///       account SHALL NOT hold the specific serialized token that
      ///       is rejected.&lt;br/>
      ///       The treasury account SHALL hold each specific serialized token
      ///       that was rejected.&lt;/li>
      /// &lt;/li>
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Hedera.Hashgraph.Proto.TransactionResponse rejectToken(global::Hedera.Hashgraph.Proto.Transaction request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_rejectToken, null, options, request);
      }
      /// <summary>
      ///*
      /// Reject one or more tokens.
      /// &lt;p>
      /// This transaction SHALL transfer the full balance of one or more tokens
      /// from the requesting account to the treasury for each token.&lt;br/>
      /// This transfer SHALL NOT charge any custom fee or royalty defined for
      /// the token(s) to be rejected.&lt;br/>
      /// ### Effects on success
      /// &lt;ul>
      ///   &lt;li>If the rejected token is fungible/common, the requesting account
      ///       SHALL have a balance of 0 for the rejected token.&lt;br/>
      ///       The treasury balance SHALL increase by the amount that the
      ///       requesting account decreased.&lt;/li>
      ///   &lt;li>If the rejected token is non-fungible/unique the requesting
      ///       account SHALL NOT hold the specific serialized token that
      ///       is rejected.&lt;br/>
      ///       The treasury account SHALL hold each specific serialized token
      ///       that was rejected.&lt;/li>
      /// &lt;/li>
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Hedera.Hashgraph.Proto.TransactionResponse> rejectTokenAsync(global::Hedera.Hashgraph.Proto.Transaction request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return rejectTokenAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      /// Reject one or more tokens.
      /// &lt;p>
      /// This transaction SHALL transfer the full balance of one or more tokens
      /// from the requesting account to the treasury for each token.&lt;br/>
      /// This transfer SHALL NOT charge any custom fee or royalty defined for
      /// the token(s) to be rejected.&lt;br/>
      /// ### Effects on success
      /// &lt;ul>
      ///   &lt;li>If the rejected token is fungible/common, the requesting account
      ///       SHALL have a balance of 0 for the rejected token.&lt;br/>
      ///       The treasury balance SHALL increase by the amount that the
      ///       requesting account decreased.&lt;/li>
      ///   &lt;li>If the rejected token is non-fungible/unique the requesting
      ///       account SHALL NOT hold the specific serialized token that
      ///       is rejected.&lt;br/>
      ///       The treasury account SHALL hold each specific serialized token
      ///       that was rejected.&lt;/li>
      /// &lt;/li>
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Hedera.Hashgraph.Proto.TransactionResponse> rejectTokenAsync(global::Hedera.Hashgraph.Proto.Transaction request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_rejectToken, null, options, request);
      }
      /// <summary>
      ///*
      /// Airdrop one or more tokens to one or more accounts.
      /// &lt;p>
      /// This transaction SHALL distribute tokens from the balance of one or
      /// more sending account(s) to the balance of one or more
      /// recipient accounts.&lt;br/>
      /// Accounts SHALL receive the tokens in one of four ways.
      /// &lt;ul>
      ///   &lt;li>An account already associated to the token to be distributed
      ///       SHALL receive the airdropped tokens immediately to the
      ///       recipient account balance.&lt;/li>
      ///   &lt;li>An account with available automatic association slots SHALL
      ///       be automatically associated to the token, and SHALL
      ///       immediately receive the airdropped tokens to the recipient
      ///       account balance.&lt;/li>
      ///   &lt;li>An account with "receiver signature required" set SHALL have
      ///       a "Pending Airdrop" created and MUST claim that airdrop with
      ///       a `claimAirdrop` transaction.&lt;/li>
      ///   &lt;li>An account with no available automatic association slots SHALL
      ///       have a "Pending Airdrop" created and MUST claim that airdrop
      ///       with a `claimAirdrop` transaction. &lt;/li>
      /// &lt;/ul>
      /// Any airdrop that completes immediately SHALL be irreversible.&lt;br/>
      /// Any airdrop that results in a "Pending Airdrop" MAY be canceled via
      /// a `cancelAirdrop` transaction.&lt;br/>
      /// All transfer fees (including custom fees and royalties), as well as
      /// the rent cost for the first auto-renewal period for any
      /// automatic-association slot occupied by the airdropped tokens,
      /// SHALL be charged to the account submitting this transaction.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Hedera.Hashgraph.Proto.TransactionResponse airdropTokens(global::Hedera.Hashgraph.Proto.Transaction request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return airdropTokens(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      /// Airdrop one or more tokens to one or more accounts.
      /// &lt;p>
      /// This transaction SHALL distribute tokens from the balance of one or
      /// more sending account(s) to the balance of one or more
      /// recipient accounts.&lt;br/>
      /// Accounts SHALL receive the tokens in one of four ways.
      /// &lt;ul>
      ///   &lt;li>An account already associated to the token to be distributed
      ///       SHALL receive the airdropped tokens immediately to the
      ///       recipient account balance.&lt;/li>
      ///   &lt;li>An account with available automatic association slots SHALL
      ///       be automatically associated to the token, and SHALL
      ///       immediately receive the airdropped tokens to the recipient
      ///       account balance.&lt;/li>
      ///   &lt;li>An account with "receiver signature required" set SHALL have
      ///       a "Pending Airdrop" created and MUST claim that airdrop with
      ///       a `claimAirdrop` transaction.&lt;/li>
      ///   &lt;li>An account with no available automatic association slots SHALL
      ///       have a "Pending Airdrop" created and MUST claim that airdrop
      ///       with a `claimAirdrop` transaction. &lt;/li>
      /// &lt;/ul>
      /// Any airdrop that completes immediately SHALL be irreversible.&lt;br/>
      /// Any airdrop that results in a "Pending Airdrop" MAY be canceled via
      /// a `cancelAirdrop` transaction.&lt;br/>
      /// All transfer fees (including custom fees and royalties), as well as
      /// the rent cost for the first auto-renewal period for any
      /// automatic-association slot occupied by the airdropped tokens,
      /// SHALL be charged to the account submitting this transaction.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Hedera.Hashgraph.Proto.TransactionResponse airdropTokens(global::Hedera.Hashgraph.Proto.Transaction request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_airdropTokens, null, options, request);
      }
      /// <summary>
      ///*
      /// Airdrop one or more tokens to one or more accounts.
      /// &lt;p>
      /// This transaction SHALL distribute tokens from the balance of one or
      /// more sending account(s) to the balance of one or more
      /// recipient accounts.&lt;br/>
      /// Accounts SHALL receive the tokens in one of four ways.
      /// &lt;ul>
      ///   &lt;li>An account already associated to the token to be distributed
      ///       SHALL receive the airdropped tokens immediately to the
      ///       recipient account balance.&lt;/li>
      ///   &lt;li>An account with available automatic association slots SHALL
      ///       be automatically associated to the token, and SHALL
      ///       immediately receive the airdropped tokens to the recipient
      ///       account balance.&lt;/li>
      ///   &lt;li>An account with "receiver signature required" set SHALL have
      ///       a "Pending Airdrop" created and MUST claim that airdrop with
      ///       a `claimAirdrop` transaction.&lt;/li>
      ///   &lt;li>An account with no available automatic association slots SHALL
      ///       have a "Pending Airdrop" created and MUST claim that airdrop
      ///       with a `claimAirdrop` transaction. &lt;/li>
      /// &lt;/ul>
      /// Any airdrop that completes immediately SHALL be irreversible.&lt;br/>
      /// Any airdrop that results in a "Pending Airdrop" MAY be canceled via
      /// a `cancelAirdrop` transaction.&lt;br/>
      /// All transfer fees (including custom fees and royalties), as well as
      /// the rent cost for the first auto-renewal period for any
      /// automatic-association slot occupied by the airdropped tokens,
      /// SHALL be charged to the account submitting this transaction.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Hedera.Hashgraph.Proto.TransactionResponse> airdropTokensAsync(global::Hedera.Hashgraph.Proto.Transaction request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return airdropTokensAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      /// Airdrop one or more tokens to one or more accounts.
      /// &lt;p>
      /// This transaction SHALL distribute tokens from the balance of one or
      /// more sending account(s) to the balance of one or more
      /// recipient accounts.&lt;br/>
      /// Accounts SHALL receive the tokens in one of four ways.
      /// &lt;ul>
      ///   &lt;li>An account already associated to the token to be distributed
      ///       SHALL receive the airdropped tokens immediately to the
      ///       recipient account balance.&lt;/li>
      ///   &lt;li>An account with available automatic association slots SHALL
      ///       be automatically associated to the token, and SHALL
      ///       immediately receive the airdropped tokens to the recipient
      ///       account balance.&lt;/li>
      ///   &lt;li>An account with "receiver signature required" set SHALL have
      ///       a "Pending Airdrop" created and MUST claim that airdrop with
      ///       a `claimAirdrop` transaction.&lt;/li>
      ///   &lt;li>An account with no available automatic association slots SHALL
      ///       have a "Pending Airdrop" created and MUST claim that airdrop
      ///       with a `claimAirdrop` transaction. &lt;/li>
      /// &lt;/ul>
      /// Any airdrop that completes immediately SHALL be irreversible.&lt;br/>
      /// Any airdrop that results in a "Pending Airdrop" MAY be canceled via
      /// a `cancelAirdrop` transaction.&lt;br/>
      /// All transfer fees (including custom fees and royalties), as well as
      /// the rent cost for the first auto-renewal period for any
      /// automatic-association slot occupied by the airdropped tokens,
      /// SHALL be charged to the account submitting this transaction.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Hedera.Hashgraph.Proto.TransactionResponse> airdropTokensAsync(global::Hedera.Hashgraph.Proto.Transaction request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_airdropTokens, null, options, request);
      }
      /// <summary>
      ///*
      /// Cancel one or more pending airdrops.
      /// &lt;p>
      /// This transaction MUST be signed by _each_ account *sending* an
      /// airdrop to be canceled.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Hedera.Hashgraph.Proto.TransactionResponse cancelAirdrop(global::Hedera.Hashgraph.Proto.Transaction request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return cancelAirdrop(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      /// Cancel one or more pending airdrops.
      /// &lt;p>
      /// This transaction MUST be signed by _each_ account *sending* an
      /// airdrop to be canceled.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Hedera.Hashgraph.Proto.TransactionResponse cancelAirdrop(global::Hedera.Hashgraph.Proto.Transaction request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_cancelAirdrop, null, options, request);
      }
      /// <summary>
      ///*
      /// Cancel one or more pending airdrops.
      /// &lt;p>
      /// This transaction MUST be signed by _each_ account *sending* an
      /// airdrop to be canceled.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Hedera.Hashgraph.Proto.TransactionResponse> cancelAirdropAsync(global::Hedera.Hashgraph.Proto.Transaction request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return cancelAirdropAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      /// Cancel one or more pending airdrops.
      /// &lt;p>
      /// This transaction MUST be signed by _each_ account *sending* an
      /// airdrop to be canceled.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Hedera.Hashgraph.Proto.TransactionResponse> cancelAirdropAsync(global::Hedera.Hashgraph.Proto.Transaction request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_cancelAirdrop, null, options, request);
      }
      /// <summary>
      ///*
      /// Claim one or more pending airdrops.
      /// &lt;p>
      /// This transaction MUST be signed by _each_ account **receiving**
      /// an airdrop to be claimed.&lt;br>
      /// If a "Sender" lacks sufficient balance to fulfill the airdrop at
      /// the time the claim is made, that claim SHALL fail.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Hedera.Hashgraph.Proto.TransactionResponse claimAirdrop(global::Hedera.Hashgraph.Proto.Transaction request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return claimAirdrop(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      /// Claim one or more pending airdrops.
      /// &lt;p>
      /// This transaction MUST be signed by _each_ account **receiving**
      /// an airdrop to be claimed.&lt;br>
      /// If a "Sender" lacks sufficient balance to fulfill the airdrop at
      /// the time the claim is made, that claim SHALL fail.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Hedera.Hashgraph.Proto.TransactionResponse claimAirdrop(global::Hedera.Hashgraph.Proto.Transaction request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_claimAirdrop, null, options, request);
      }
      /// <summary>
      ///*
      /// Claim one or more pending airdrops.
      /// &lt;p>
      /// This transaction MUST be signed by _each_ account **receiving**
      /// an airdrop to be claimed.&lt;br>
      /// If a "Sender" lacks sufficient balance to fulfill the airdrop at
      /// the time the claim is made, that claim SHALL fail.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Hedera.Hashgraph.Proto.TransactionResponse> claimAirdropAsync(global::Hedera.Hashgraph.Proto.Transaction request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return claimAirdropAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      /// Claim one or more pending airdrops.
      /// &lt;p>
      /// This transaction MUST be signed by _each_ account **receiving**
      /// an airdrop to be claimed.&lt;br>
      /// If a "Sender" lacks sufficient balance to fulfill the airdrop at
      /// the time the claim is made, that claim SHALL fail.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Hedera.Hashgraph.Proto.TransactionResponse> claimAirdropAsync(global::Hedera.Hashgraph.Proto.Transaction request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_claimAirdrop, null, options, request);
      }
      /// <summary>Creates a new instance of client from given <c>ClientBaseConfiguration</c>.</summary>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      protected override TokenServiceClient NewInstance(ClientBaseConfiguration configuration)
      {
        return new TokenServiceClient(configuration);
      }
    }

    /// <summary>Creates service definition that can be registered with a server</summary>
    /// <param name="serviceImpl">An object implementing the server-side handling logic.</param>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public static grpc::ServerServiceDefinition BindService(TokenServiceBase serviceImpl)
    {
      return grpc::ServerServiceDefinition.CreateBuilder()
          .AddMethod(__Method_createToken, serviceImpl.createToken)
          .AddMethod(__Method_updateToken, serviceImpl.updateToken)
          .AddMethod(__Method_mintToken, serviceImpl.mintToken)
          .AddMethod(__Method_burnToken, serviceImpl.burnToken)
          .AddMethod(__Method_deleteToken, serviceImpl.deleteToken)
          .AddMethod(__Method_wipeTokenAccount, serviceImpl.wipeTokenAccount)
          .AddMethod(__Method_freezeTokenAccount, serviceImpl.freezeTokenAccount)
          .AddMethod(__Method_unfreezeTokenAccount, serviceImpl.unfreezeTokenAccount)
          .AddMethod(__Method_grantKycToTokenAccount, serviceImpl.grantKycToTokenAccount)
          .AddMethod(__Method_revokeKycFromTokenAccount, serviceImpl.revokeKycFromTokenAccount)
          .AddMethod(__Method_associateTokens, serviceImpl.associateTokens)
          .AddMethod(__Method_dissociateTokens, serviceImpl.dissociateTokens)
          .AddMethod(__Method_updateTokenFeeSchedule, serviceImpl.updateTokenFeeSchedule)
          .AddMethod(__Method_getTokenInfo, serviceImpl.getTokenInfo)
          .AddMethod(__Method_getTokenNftInfo, serviceImpl.getTokenNftInfo)
          .AddMethod(__Method_pauseToken, serviceImpl.pauseToken)
          .AddMethod(__Method_unpauseToken, serviceImpl.unpauseToken)
          .AddMethod(__Method_updateNfts, serviceImpl.updateNfts)
          .AddMethod(__Method_rejectToken, serviceImpl.rejectToken)
          .AddMethod(__Method_airdropTokens, serviceImpl.airdropTokens)
          .AddMethod(__Method_cancelAirdrop, serviceImpl.cancelAirdrop)
          .AddMethod(__Method_claimAirdrop, serviceImpl.claimAirdrop).Build();
    }

    /// <summary>Register service method with a service binder with or without implementation. Useful when customizing the service binding logic.
    /// Note: this method is part of an experimental API that can change or be removed without any prior notice.</summary>
    /// <param name="serviceBinder">Service methods will be bound by calling <c>AddMethod</c> on this object.</param>
    /// <param name="serviceImpl">An object implementing the server-side handling logic.</param>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public static void BindService(grpc::ServiceBinderBase serviceBinder, TokenServiceBase serviceImpl)
    {
      serviceBinder.AddMethod(__Method_createToken, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse>(serviceImpl.createToken));
      serviceBinder.AddMethod(__Method_updateToken, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse>(serviceImpl.updateToken));
      serviceBinder.AddMethod(__Method_mintToken, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse>(serviceImpl.mintToken));
      serviceBinder.AddMethod(__Method_burnToken, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse>(serviceImpl.burnToken));
      serviceBinder.AddMethod(__Method_deleteToken, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse>(serviceImpl.deleteToken));
      serviceBinder.AddMethod(__Method_wipeTokenAccount, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse>(serviceImpl.wipeTokenAccount));
      serviceBinder.AddMethod(__Method_freezeTokenAccount, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse>(serviceImpl.freezeTokenAccount));
      serviceBinder.AddMethod(__Method_unfreezeTokenAccount, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse>(serviceImpl.unfreezeTokenAccount));
      serviceBinder.AddMethod(__Method_grantKycToTokenAccount, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse>(serviceImpl.grantKycToTokenAccount));
      serviceBinder.AddMethod(__Method_revokeKycFromTokenAccount, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse>(serviceImpl.revokeKycFromTokenAccount));
      serviceBinder.AddMethod(__Method_associateTokens, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse>(serviceImpl.associateTokens));
      serviceBinder.AddMethod(__Method_dissociateTokens, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse>(serviceImpl.dissociateTokens));
      serviceBinder.AddMethod(__Method_updateTokenFeeSchedule, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse>(serviceImpl.updateTokenFeeSchedule));
      serviceBinder.AddMethod(__Method_getTokenInfo, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::Hedera.Hashgraph.Proto.Query, global::Hedera.Hashgraph.Proto.Response>(serviceImpl.getTokenInfo));
      serviceBinder.AddMethod(__Method_getTokenNftInfo, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::Hedera.Hashgraph.Proto.Query, global::Hedera.Hashgraph.Proto.Response>(serviceImpl.getTokenNftInfo));
      serviceBinder.AddMethod(__Method_pauseToken, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse>(serviceImpl.pauseToken));
      serviceBinder.AddMethod(__Method_unpauseToken, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse>(serviceImpl.unpauseToken));
      serviceBinder.AddMethod(__Method_updateNfts, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse>(serviceImpl.updateNfts));
      serviceBinder.AddMethod(__Method_rejectToken, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse>(serviceImpl.rejectToken));
      serviceBinder.AddMethod(__Method_airdropTokens, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse>(serviceImpl.airdropTokens));
      serviceBinder.AddMethod(__Method_cancelAirdrop, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse>(serviceImpl.cancelAirdrop));
      serviceBinder.AddMethod(__Method_claimAirdrop, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse>(serviceImpl.claimAirdrop));
    }

  }
}
#endregion
