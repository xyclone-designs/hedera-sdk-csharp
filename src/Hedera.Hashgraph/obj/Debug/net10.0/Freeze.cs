// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: freeze.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021, 8981
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Proto {

  /// <summary>Holder for reflection information generated from freeze.proto</summary>
  public static partial class FreezeReflection {

    #region Descriptor
    /// <summary>File descriptor for freeze.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static FreezeReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CgxmcmVlemUucHJvdG8SBXByb3RvGg90aW1lc3RhbXAucHJvdG8aEWJhc2lj",
            "X3R5cGVzLnByb3RvGhFmcmVlemVfdHlwZS5wcm90byLyAQoVRnJlZXplVHJh",
            "bnNhY3Rpb25Cb2R5EhUKCXN0YXJ0SG91chgBIAEoBUICGAESFAoIc3RhcnRN",
            "aW4YAiABKAVCAhgBEhMKB2VuZEhvdXIYAyABKAVCAhgBEhIKBmVuZE1pbhgE",
            "IAEoBUICGAESIgoLdXBkYXRlX2ZpbGUYBSABKAsyDS5wcm90by5GaWxlSUQS",
            "EQoJZmlsZV9oYXNoGAYgASgMEiQKCnN0YXJ0X3RpbWUYByABKAsyEC5wcm90",
            "by5UaW1lc3RhbXASJgoLZnJlZXplX3R5cGUYCCABKA4yES5wcm90by5GcmVl",
            "emVUeXBlQiIKHmNvbS5oZWRlcmEuaGFzaGdyYXBoLnNkay5wcm90b1ABYgZw",
            "cm90bzM="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Proto.TimestampReflection.Descriptor, global::Proto.BasicTypesReflection.Descriptor, global::Proto.FreezeTypeReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Proto.FreezeTransactionBody), global::Proto.FreezeTransactionBody.Parser, new[]{ "StartHour", "StartMin", "EndHour", "EndMin", "UpdateFile", "FileHash", "StartTime", "FreezeType" }, null, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  ///*
  /// A transaction body for all five freeze transactions.
  ///
  /// Combining five different transactions into a single message, this
  /// transaction body MUST support options to schedule a freeze, abort a
  /// scheduled freeze, prepare a software upgrade, prepare a telemetry
  /// upgrade, or initiate a software upgrade.
  ///
  /// For a scheduled freeze, at the scheduled time, according to
  /// network consensus time
  ///   - A freeze (`FREEZE_ONLY`) causes the network nodes to stop creating
  ///     events or accepting transactions, and enter a persistent
  ///     maintenance state.
  ///   - A freeze upgrade (`FREEZE_UPGRADE`) causes the network nodes to stop
  ///     creating events or accepting transactions, and upgrade the node software
  ///     from a previously prepared upgrade package. The network nodes then
  ///     restart and rejoin the network after upgrading.
  ///
  /// For other freeze types, immediately upon processing the freeze transaction
  ///   - A Freeze Abort (`FREEZE_ABORT`) cancels any pending scheduled freeze.
  ///   - A prepare upgrade (`PREPARE_UPGRADE`) begins to extract the contents of
  ///     the specified upgrade file to the local filesystem.
  ///   - A telemetry upgrade (`TELEMETRY_UPGRADE`) causes the network nodes to
  ///     extract a telemetry upgrade package to the local filesystem and signal
  ///     other software on the machine to upgrade, without impacting the node or
  ///     network processing.
  ///
  /// ### Block Stream Effects
  /// Unknown
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class FreezeTransactionBody : pb::IMessage<FreezeTransactionBody>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<FreezeTransactionBody> _parser = new pb::MessageParser<FreezeTransactionBody>(() => new FreezeTransactionBody());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<FreezeTransactionBody> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Proto.FreezeReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public FreezeTransactionBody() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public FreezeTransactionBody(FreezeTransactionBody other) : this() {
      startHour_ = other.startHour_;
      startMin_ = other.startMin_;
      endHour_ = other.endHour_;
      endMin_ = other.endMin_;
      updateFile_ = other.updateFile_ != null ? other.updateFile_.Clone() : null;
      fileHash_ = other.fileHash_;
      startTime_ = other.startTime_ != null ? other.startTime_.Clone() : null;
      freezeType_ = other.freezeType_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public FreezeTransactionBody Clone() {
      return new FreezeTransactionBody(this);
    }

    /// <summary>Field number for the "startHour" field.</summary>
    public const int StartHourFieldNumber = 1;
    private int startHour_;
    /// <summary>
    ///*
    /// Rejected if set; replace with `start_time`.&lt;br/>
    /// The start hour (in UTC time), a value between 0 and 23
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int StartHour {
      get { return startHour_; }
      set {
        startHour_ = value;
      }
    }

    /// <summary>Field number for the "startMin" field.</summary>
    public const int StartMinFieldNumber = 2;
    private int startMin_;
    /// <summary>
    ///*
    /// Rejected if set; replace with `start_time`.&lt;br/>
    /// The start minute (in UTC time), a value between 0 and 59
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int StartMin {
      get { return startMin_; }
      set {
        startMin_ = value;
      }
    }

    /// <summary>Field number for the "endHour" field.</summary>
    public const int EndHourFieldNumber = 3;
    private int endHour_;
    /// <summary>
    ///*
    /// Rejected if set; end time is neither assigned nor guaranteed and depends
    /// on many uncontrolled factors.&lt;br/>
    /// The end hour (in UTC time), a value between 0 and 23
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int EndHour {
      get { return endHour_; }
      set {
        endHour_ = value;
      }
    }

    /// <summary>Field number for the "endMin" field.</summary>
    public const int EndMinFieldNumber = 4;
    private int endMin_;
    /// <summary>
    ///*
    /// Rejected if set; end time is neither assigned nor guaranteed and depends
    /// on many uncontrolled factors.&lt;br/>
    /// The end minute (in UTC time), a value between 0 and 59
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int EndMin {
      get { return endMin_; }
      set {
        endMin_ = value;
      }
    }

    /// <summary>Field number for the "update_file" field.</summary>
    public const int UpdateFileFieldNumber = 5;
    private global::Proto.FileID updateFile_;
    /// <summary>
    ///*
    /// An upgrade file.
    /// &lt;p>
    /// If set, the identifier of a file in network state.&lt;br/>
    /// The contents of this file MUST be a `zip` file and this data
    /// SHALL be extracted to the node filesystem during a
    /// `PREPARE_UPGRADE` or `TELEMETRY_UPGRADE` freeze type.&lt;br/>
    /// The `file_hash` field MUST match the SHA384 hash of the content
    /// of this file.&lt;br/>
    /// The extracted data SHALL be used to perform a network software update
    /// if a `FREEZE_UPGRADE` freeze type is subsequently processed.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.FileID UpdateFile {
      get { return updateFile_; }
      set {
        updateFile_ = value;
      }
    }

    /// <summary>Field number for the "file_hash" field.</summary>
    public const int FileHashFieldNumber = 6;
    private pb::ByteString fileHash_ = pb::ByteString.Empty;
    /// <summary>
    ///*
    /// A SHA384 hash of file content.&lt;br/>
    /// This is a hash of the file identified by `update_file`.
    /// &lt;p>
    /// This MUST be set if `update_file` is set, and MUST match the
    /// SHA384 hash of the contents of that file.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString FileHash {
      get { return fileHash_; }
      set {
        fileHash_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "start_time" field.</summary>
    public const int StartTimeFieldNumber = 7;
    private global::Proto.Timestamp startTime_;
    /// <summary>
    ///*
    /// A start time for the freeze.
    /// &lt;p>
    /// If this field is REQUIRED for the specified `freeze_type`, then
    /// when the network consensus time reaches this instant&lt;ol>
    ///   &lt;li>The network SHALL stop accepting transactions.&lt;/li>
    ///   &lt;li>The network SHALL gossip a freeze state.&lt;/li>
    ///   &lt;li>The nodes SHALL, in coordinated order, disconnect and
    ///       shut down.&lt;/li>
    ///   &lt;li>The nodes SHALL halt or perform a software upgrade, depending
    ///       on `freeze_type`.&lt;/li>
    ///   &lt;li>If the `freeze_type` is `FREEZE_UPGRADE`, the nodes SHALL
    ///       restart and rejoin the network upon completion of the
    ///       software upgrade.&lt;/li>
    /// &lt;/ol>
    /// &lt;blockquote>
    /// If the `freeze_type` is `TELEMETRY_UPGRADE`, the start time is required,
    /// but the network SHALL NOT stop, halt, or interrupt transaction
    /// processing. The required field is an historical anomaly and SHOULD
    /// change in a future release.&lt;/blockquote>
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.Timestamp StartTime {
      get { return startTime_; }
      set {
        startTime_ = value;
      }
    }

    /// <summary>Field number for the "freeze_type" field.</summary>
    public const int FreezeTypeFieldNumber = 8;
    private global::Proto.FreezeType freezeType_ = global::Proto.FreezeType.UnknownFreezeType;
    /// <summary>
    ///*
    /// The type of freeze.
    /// &lt;p>
    /// This REQUIRED field effectively selects between five quite different
    /// transactions in the same transaction body. Depending on this value
    /// the service may schedule a freeze, prepare upgrades, perform upgrades,
    /// or even abort a previously scheduled freeze.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.FreezeType FreezeType {
      get { return freezeType_; }
      set {
        freezeType_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as FreezeTransactionBody);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(FreezeTransactionBody other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (StartHour != other.StartHour) return false;
      if (StartMin != other.StartMin) return false;
      if (EndHour != other.EndHour) return false;
      if (EndMin != other.EndMin) return false;
      if (!object.Equals(UpdateFile, other.UpdateFile)) return false;
      if (FileHash != other.FileHash) return false;
      if (!object.Equals(StartTime, other.StartTime)) return false;
      if (FreezeType != other.FreezeType) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (StartHour != 0) hash ^= StartHour.GetHashCode();
      if (StartMin != 0) hash ^= StartMin.GetHashCode();
      if (EndHour != 0) hash ^= EndHour.GetHashCode();
      if (EndMin != 0) hash ^= EndMin.GetHashCode();
      if (updateFile_ != null) hash ^= UpdateFile.GetHashCode();
      if (FileHash.Length != 0) hash ^= FileHash.GetHashCode();
      if (startTime_ != null) hash ^= StartTime.GetHashCode();
      if (FreezeType != global::Proto.FreezeType.UnknownFreezeType) hash ^= FreezeType.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (StartHour != 0) {
        output.WriteRawTag(8);
        output.WriteInt32(StartHour);
      }
      if (StartMin != 0) {
        output.WriteRawTag(16);
        output.WriteInt32(StartMin);
      }
      if (EndHour != 0) {
        output.WriteRawTag(24);
        output.WriteInt32(EndHour);
      }
      if (EndMin != 0) {
        output.WriteRawTag(32);
        output.WriteInt32(EndMin);
      }
      if (updateFile_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(UpdateFile);
      }
      if (FileHash.Length != 0) {
        output.WriteRawTag(50);
        output.WriteBytes(FileHash);
      }
      if (startTime_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(StartTime);
      }
      if (FreezeType != global::Proto.FreezeType.UnknownFreezeType) {
        output.WriteRawTag(64);
        output.WriteEnum((int) FreezeType);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (StartHour != 0) {
        output.WriteRawTag(8);
        output.WriteInt32(StartHour);
      }
      if (StartMin != 0) {
        output.WriteRawTag(16);
        output.WriteInt32(StartMin);
      }
      if (EndHour != 0) {
        output.WriteRawTag(24);
        output.WriteInt32(EndHour);
      }
      if (EndMin != 0) {
        output.WriteRawTag(32);
        output.WriteInt32(EndMin);
      }
      if (updateFile_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(UpdateFile);
      }
      if (FileHash.Length != 0) {
        output.WriteRawTag(50);
        output.WriteBytes(FileHash);
      }
      if (startTime_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(StartTime);
      }
      if (FreezeType != global::Proto.FreezeType.UnknownFreezeType) {
        output.WriteRawTag(64);
        output.WriteEnum((int) FreezeType);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (StartHour != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(StartHour);
      }
      if (StartMin != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(StartMin);
      }
      if (EndHour != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(EndHour);
      }
      if (EndMin != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(EndMin);
      }
      if (updateFile_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(UpdateFile);
      }
      if (FileHash.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(FileHash);
      }
      if (startTime_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(StartTime);
      }
      if (FreezeType != global::Proto.FreezeType.UnknownFreezeType) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) FreezeType);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(FreezeTransactionBody other) {
      if (other == null) {
        return;
      }
      if (other.StartHour != 0) {
        StartHour = other.StartHour;
      }
      if (other.StartMin != 0) {
        StartMin = other.StartMin;
      }
      if (other.EndHour != 0) {
        EndHour = other.EndHour;
      }
      if (other.EndMin != 0) {
        EndMin = other.EndMin;
      }
      if (other.updateFile_ != null) {
        if (updateFile_ == null) {
          UpdateFile = new global::Proto.FileID();
        }
        UpdateFile.MergeFrom(other.UpdateFile);
      }
      if (other.FileHash.Length != 0) {
        FileHash = other.FileHash;
      }
      if (other.startTime_ != null) {
        if (startTime_ == null) {
          StartTime = new global::Proto.Timestamp();
        }
        StartTime.MergeFrom(other.StartTime);
      }
      if (other.FreezeType != global::Proto.FreezeType.UnknownFreezeType) {
        FreezeType = other.FreezeType;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            StartHour = input.ReadInt32();
            break;
          }
          case 16: {
            StartMin = input.ReadInt32();
            break;
          }
          case 24: {
            EndHour = input.ReadInt32();
            break;
          }
          case 32: {
            EndMin = input.ReadInt32();
            break;
          }
          case 42: {
            if (updateFile_ == null) {
              UpdateFile = new global::Proto.FileID();
            }
            input.ReadMessage(UpdateFile);
            break;
          }
          case 50: {
            FileHash = input.ReadBytes();
            break;
          }
          case 58: {
            if (startTime_ == null) {
              StartTime = new global::Proto.Timestamp();
            }
            input.ReadMessage(StartTime);
            break;
          }
          case 64: {
            FreezeType = (global::Proto.FreezeType) input.ReadEnum();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            StartHour = input.ReadInt32();
            break;
          }
          case 16: {
            StartMin = input.ReadInt32();
            break;
          }
          case 24: {
            EndHour = input.ReadInt32();
            break;
          }
          case 32: {
            EndMin = input.ReadInt32();
            break;
          }
          case 42: {
            if (updateFile_ == null) {
              UpdateFile = new global::Proto.FileID();
            }
            input.ReadMessage(UpdateFile);
            break;
          }
          case 50: {
            FileHash = input.ReadBytes();
            break;
          }
          case 58: {
            if (startTime_ == null) {
              StartTime = new global::Proto.Timestamp();
            }
            input.ReadMessage(StartTime);
            break;
          }
          case 64: {
            FreezeType = (global::Proto.FreezeType) input.ReadEnum();
            break;
          }
        }
      }
    }
    #endif

  }

  #endregion

}

#endregion Designer generated code
