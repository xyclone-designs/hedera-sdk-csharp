// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: schedule.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021, 8981
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Hedera.Hashgraph.Proto {

  /// <summary>Holder for reflection information generated from schedule.proto</summary>
  public static partial class ScheduleReflection {

    #region Descriptor
    /// <summary>File descriptor for schedule.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static ScheduleReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "Cg5zY2hlZHVsZS5wcm90bxIFcHJvdG8aEWJhc2ljX3R5cGVzLnByb3RvGg90",
            "aW1lc3RhbXAucHJvdG8aInNjaGVkdWxhYmxlX3RyYW5zYWN0aW9uX2JvZHku",
            "cHJvdG8aEXRyYW5zYWN0aW9uLnByb3RvIrwECghTY2hlZHVsZRImCgtzY2hl",
            "ZHVsZV9pZBgBIAEoCzIRLnByb3RvLlNjaGVkdWxlSUQSDwoHZGVsZXRlZBgC",
            "IAEoCBIQCghleGVjdXRlZBgDIAEoCBIXCg93YWl0X2Zvcl9leHBpcnkYBCAB",
            "KAgSDAoEbWVtbxgFIAEoCRIuChRzY2hlZHVsZXJfYWNjb3VudF9pZBgGIAEo",
            "CzIQLnByb3RvLkFjY291bnRJRBIqChBwYXllcl9hY2NvdW50X2lkGAcgASgL",
            "MhAucHJvdG8uQWNjb3VudElEEh0KCWFkbWluX2tleRgIIAEoCzIKLnByb3Rv",
            "LktleRIuChRzY2hlZHVsZV92YWxpZF9zdGFydBgJIAEoCzIQLnByb3RvLlRp",
            "bWVzdGFtcBIiChpwcm92aWRlZF9leHBpcmF0aW9uX3NlY29uZBgKIAEoAxIk",
            "ChxjYWxjdWxhdGVkX2V4cGlyYXRpb25fc2Vjb25kGAsgASgDEikKD3Jlc29s",
            "dXRpb25fdGltZRgMIAEoCzIQLnByb3RvLlRpbWVzdGFtcBJAChVzY2hlZHVs",
            "ZWRfdHJhbnNhY3Rpb24YDSABKAsyIS5wcm90by5TY2hlZHVsYWJsZVRyYW5z",
            "YWN0aW9uQm9keRI7ChtvcmlnaW5hbF9jcmVhdGVfdHJhbnNhY3Rpb24YDiAB",
            "KAsyFi5wcm90by5UcmFuc2FjdGlvbkJvZHkSHwoLc2lnbmF0b3JpZXMYDyAD",
            "KAsyCi5wcm90by5LZXkiMgoMU2NoZWR1bGVMaXN0EiIKCXNjaGVkdWxlcxgB",
            "IAMoCzIPLnByb3RvLlNjaGVkdWxlIjkKDlNjaGVkdWxlSWRMaXN0EicKDHNj",
            "aGVkdWxlX2lkcxgBIAMoCzIRLnByb3RvLlNjaGVkdWxlSUQiRQoPU2NoZWR1",
            "bGVkQ291bnRzEhgKEG51bWJlcl9zY2hlZHVsZWQYASABKA0SGAoQbnVtYmVy",
            "X3Byb2Nlc3NlZBgCIAEoDSI9Cg5TY2hlZHVsZWRPcmRlchIVCg1leHBpcnlf",
            "c2Vjb25kGAEgASgEEhQKDG9yZGVyX251bWJlchgCIAEoDUI5Ch5jb20uaGVk",
            "ZXJhLmhhc2hncmFwaC5zZGsucHJvdG+qAhZIZWRlcmEuSGFzaGdyYXBoLlBy",
            "b3RvYgZwcm90bzM="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Hedera.Hashgraph.Proto.BasicTypesReflection.Descriptor, global::Hedera.Hashgraph.Proto.TimestampReflection.Descriptor, global::Hedera.Hashgraph.Proto.SchedulableTransactionBodyReflection.Descriptor, global::Hedera.Hashgraph.Proto.TransactionReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Hedera.Hashgraph.Proto.Schedule), global::Hedera.Hashgraph.Proto.Schedule.Parser, new[]{ "ScheduleId", "Deleted", "Executed", "WaitForExpiry", "Memo", "SchedulerAccountId", "PayerAccountId", "AdminKey", "ScheduleValidStart", "ProvidedExpirationSecond", "CalculatedExpirationSecond", "ResolutionTime", "ScheduledTransaction", "OriginalCreateTransaction", "Signatories" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Hedera.Hashgraph.Proto.ScheduleList), global::Hedera.Hashgraph.Proto.ScheduleList.Parser, new[]{ "Schedules" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Hedera.Hashgraph.Proto.ScheduleIdList), global::Hedera.Hashgraph.Proto.ScheduleIdList.Parser, new[]{ "ScheduleIds" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Hedera.Hashgraph.Proto.ScheduledCounts), global::Hedera.Hashgraph.Proto.ScheduledCounts.Parser, new[]{ "NumberScheduled", "NumberProcessed" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Hedera.Hashgraph.Proto.ScheduledOrder), global::Hedera.Hashgraph.Proto.ScheduledOrder.Parser, new[]{ "ExpirySecond", "OrderNumber" }, null, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  ///*
  /// Representation of a Hedera Schedule entry in the network Merkle tree.&lt;br/>
  /// A Schedule represents a request to run a transaction _at some future time_
  /// either when the `Schedule` expires (if long term schedules are enabled and
  /// `wait_for_expiry` is true) or as soon as the `Schedule` has gathered
  /// enough signatures via any combination of the `scheduleCreate` and 0 or more
  /// subsequent `scheduleSign` transactions.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class Schedule : pb::IMessage<Schedule>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Schedule> _parser = new pb::MessageParser<Schedule>(() => new Schedule());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Schedule> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Hedera.Hashgraph.Proto.ScheduleReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Schedule() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Schedule(Schedule other) : this() {
      scheduleId_ = other.scheduleId_ != null ? other.scheduleId_.Clone() : null;
      deleted_ = other.deleted_;
      executed_ = other.executed_;
      waitForExpiry_ = other.waitForExpiry_;
      memo_ = other.memo_;
      schedulerAccountId_ = other.schedulerAccountId_ != null ? other.schedulerAccountId_.Clone() : null;
      payerAccountId_ = other.payerAccountId_ != null ? other.payerAccountId_.Clone() : null;
      adminKey_ = other.adminKey_ != null ? other.adminKey_.Clone() : null;
      scheduleValidStart_ = other.scheduleValidStart_ != null ? other.scheduleValidStart_.Clone() : null;
      providedExpirationSecond_ = other.providedExpirationSecond_;
      calculatedExpirationSecond_ = other.calculatedExpirationSecond_;
      resolutionTime_ = other.resolutionTime_ != null ? other.resolutionTime_.Clone() : null;
      scheduledTransaction_ = other.scheduledTransaction_ != null ? other.scheduledTransaction_.Clone() : null;
      originalCreateTransaction_ = other.originalCreateTransaction_ != null ? other.originalCreateTransaction_.Clone() : null;
      signatories_ = other.signatories_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Schedule Clone() {
      return new Schedule(this);
    }

    /// <summary>Field number for the "schedule_id" field.</summary>
    public const int ScheduleIdFieldNumber = 1;
    private global::Hedera.Hashgraph.Proto.ScheduleID scheduleId_;
    /// <summary>
    ///*
    /// This schedule's ID within the global network state.
    /// &lt;p>
    /// This value SHALL be unique within the network.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Hedera.Hashgraph.Proto.ScheduleID ScheduleId {
      get { return scheduleId_; }
      set {
        scheduleId_ = value;
      }
    }

    /// <summary>Field number for the "deleted" field.</summary>
    public const int DeletedFieldNumber = 2;
    private bool deleted_;
    /// <summary>
    ///*
    /// A flag indicating this schedule is deleted.
    /// &lt;p>
    /// A schedule SHALL either be executed or deleted, but never both.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Deleted {
      get { return deleted_; }
      set {
        deleted_ = value;
      }
    }

    /// <summary>Field number for the "executed" field.</summary>
    public const int ExecutedFieldNumber = 3;
    private bool executed_;
    /// <summary>
    ///*
    /// A flag indicating this schedule has executed.
    /// &lt;p>
    /// A schedule SHALL either be executed or deleted, but never both.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Executed {
      get { return executed_; }
      set {
        executed_ = value;
      }
    }

    /// <summary>Field number for the "wait_for_expiry" field.</summary>
    public const int WaitForExpiryFieldNumber = 4;
    private bool waitForExpiry_;
    /// <summary>
    ///*
    /// A schedule flag to wait for expiration before executing.
    /// &lt;p>
    /// A schedule SHALL be executed immediately when all necessary signatures
    /// are gathered, unless this flag is set.&lt;br/>
    /// If this flag is set, the schedule SHALL wait until the consensus time
    /// reaches `expiration_time_provided`, when signatures MUST again be
    /// verified. If all required signatures are present at that time, the
    /// schedule SHALL be executed. Otherwise the schedule SHALL expire without
    /// execution.
    /// &lt;p>
    /// Note that a schedule is always removed from state after it expires,
    /// regardless of whether it was executed or not.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool WaitForExpiry {
      get { return waitForExpiry_; }
      set {
        waitForExpiry_ = value;
      }
    }

    /// <summary>Field number for the "memo" field.</summary>
    public const int MemoFieldNumber = 5;
    private string memo_ = "";
    /// <summary>
    ///*
    /// A short description for this schedule.
    /// &lt;p>
    /// This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
    /// (default 100) bytes when encoded as UTF-8.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Memo {
      get { return memo_; }
      set {
        memo_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "scheduler_account_id" field.</summary>
    public const int SchedulerAccountIdFieldNumber = 6;
    private global::Hedera.Hashgraph.Proto.AccountID schedulerAccountId_;
    /// <summary>
    ///*
    /// The scheduler account for this schedule.
    /// &lt;p>
    /// This SHALL be the account that submitted the original
    /// ScheduleCreate transaction.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Hedera.Hashgraph.Proto.AccountID SchedulerAccountId {
      get { return schedulerAccountId_; }
      set {
        schedulerAccountId_ = value;
      }
    }

    /// <summary>Field number for the "payer_account_id" field.</summary>
    public const int PayerAccountIdFieldNumber = 7;
    private global::Hedera.Hashgraph.Proto.AccountID payerAccountId_;
    /// <summary>
    ///*
    /// The explicit payer account for the scheduled transaction.
    /// &lt;p>
    /// If set, this account SHALL be added to the accounts that MUST sign the
    /// schedule before it may execute.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Hedera.Hashgraph.Proto.AccountID PayerAccountId {
      get { return payerAccountId_; }
      set {
        payerAccountId_ = value;
      }
    }

    /// <summary>Field number for the "admin_key" field.</summary>
    public const int AdminKeyFieldNumber = 8;
    private global::Hedera.Hashgraph.Proto.Key adminKey_;
    /// <summary>
    ///*
    /// The admin key for this schedule.
    /// &lt;p>
    /// This key, if set, MUST sign any `schedule_delete` transaction.&lt;br/>
    /// If not set, then this schedule SHALL NOT be deleted, and any
    /// `schedule_delete` transaction for this schedule SHALL fail.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Hedera.Hashgraph.Proto.Key AdminKey {
      get { return adminKey_; }
      set {
        adminKey_ = value;
      }
    }

    /// <summary>Field number for the "schedule_valid_start" field.</summary>
    public const int ScheduleValidStartFieldNumber = 9;
    private global::Hedera.Hashgraph.Proto.Timestamp scheduleValidStart_;
    /// <summary>
    ///*
    /// The transaction valid start value for this schedule.
    /// &lt;p>
    /// This MUST be set, and SHALL be copied from the `TransactionID` of
    /// the original `schedule_create` transaction.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Hedera.Hashgraph.Proto.Timestamp ScheduleValidStart {
      get { return scheduleValidStart_; }
      set {
        scheduleValidStart_ = value;
      }
    }

    /// <summary>Field number for the "provided_expiration_second" field.</summary>
    public const int ProvidedExpirationSecondFieldNumber = 10;
    private long providedExpirationSecond_;
    /// <summary>
    ///*
    /// The requested expiration time of the schedule if provided by the user.
    /// &lt;p>
    /// If not provided in the `schedule_create` transaction, this SHALL be set
    /// to a default value equal to the current consensus time, forward offset by
    /// the maximum schedule expiration time in the current dynamic network
    /// configuration (typically 62 days).&lt;br/>
    /// The actual `calculated_expiration_second` MAY be "earlier" than this,
    /// but MUST NOT be later.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long ProvidedExpirationSecond {
      get { return providedExpirationSecond_; }
      set {
        providedExpirationSecond_ = value;
      }
    }

    /// <summary>Field number for the "calculated_expiration_second" field.</summary>
    public const int CalculatedExpirationSecondFieldNumber = 11;
    private long calculatedExpirationSecond_;
    /// <summary>
    ///*
    /// The calculated expiration time of the schedule.
    /// &lt;p>
    /// This SHALL be calculated from the requested expiration time in the
    /// `schedule_create` transaction, and limited by the maximum expiration time
    /// in the current dynamic network configuration (typically 62 days).
    /// &lt;p>
    /// The schedule SHALL be removed from global network state after the network
    /// reaches a consensus time greater than or equal to this value.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long CalculatedExpirationSecond {
      get { return calculatedExpirationSecond_; }
      set {
        calculatedExpirationSecond_ = value;
      }
    }

    /// <summary>Field number for the "resolution_time" field.</summary>
    public const int ResolutionTimeFieldNumber = 12;
    private global::Hedera.Hashgraph.Proto.Timestamp resolutionTime_;
    /// <summary>
    ///*
    /// The consensus timestamp of the transaction that executed or deleted this schedule.
    /// &lt;p>
    /// This value SHALL be set to the `current_consensus_time` when a
    /// `schedule_delete` transaction is completed.&lt;br/>
    /// This value SHALL be set to the `current_consensus_time` when the
    /// scheduled transaction is executed, either as a result of gathering the
    /// final required signature, or, if long-term schedule execution is enabled,
    /// at the requested execution time.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Hedera.Hashgraph.Proto.Timestamp ResolutionTime {
      get { return resolutionTime_; }
      set {
        resolutionTime_ = value;
      }
    }

    /// <summary>Field number for the "scheduled_transaction" field.</summary>
    public const int ScheduledTransactionFieldNumber = 13;
    private global::Hedera.Hashgraph.Proto.SchedulableTransactionBody scheduledTransaction_;
    /// <summary>
    ///*
    /// The scheduled transaction to execute.
    /// &lt;p>
    /// This MUST be one of the transaction types permitted in the current value
    /// of the `schedule.whitelist` in the dynamic network configuration.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Hedera.Hashgraph.Proto.SchedulableTransactionBody ScheduledTransaction {
      get { return scheduledTransaction_; }
      set {
        scheduledTransaction_ = value;
      }
    }

    /// <summary>Field number for the "original_create_transaction" field.</summary>
    public const int OriginalCreateTransactionFieldNumber = 14;
    private global::Hedera.Hashgraph.Proto.TransactionBody originalCreateTransaction_;
    /// <summary>
    ///*
    /// The full transaction that created this schedule.
    /// &lt;p>
    /// This is primarily used for duplicate schedule create detection. This is
    /// also the source of the parent transaction ID, from which the child
    /// transaction ID is derived when the `scheduled_transaction` is executed.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Hedera.Hashgraph.Proto.TransactionBody OriginalCreateTransaction {
      get { return originalCreateTransaction_; }
      set {
        originalCreateTransaction_ = value;
      }
    }

    /// <summary>Field number for the "signatories" field.</summary>
    public const int SignatoriesFieldNumber = 15;
    private static readonly pb::FieldCodec<global::Hedera.Hashgraph.Proto.Key> _repeated_signatories_codec
        = pb::FieldCodec.ForMessage(122, global::Hedera.Hashgraph.Proto.Key.Parser);
    private readonly pbc::RepeatedField<global::Hedera.Hashgraph.Proto.Key> signatories_ = new pbc::RepeatedField<global::Hedera.Hashgraph.Proto.Key>();
    /// <summary>
    ///*
    /// All of the "primitive" keys that have already signed this schedule.
    /// &lt;p>
    /// The scheduled transaction SHALL NOT be executed before this list is
    /// sufficient to "activate" the required keys for the scheduled transaction.&lt;br/>
    /// A Key SHALL NOT be stored in this list unless the corresponding private
    /// key has signed either the original `schedule_create` transaction or a
    /// subsequent `schedule_sign` transaction intended for, and referencing to,
    /// this specific schedule.
    /// &lt;p>
    /// The only keys stored are "primitive" keys (ED25519 or ECDSA_SECP256K1) in
    /// order to ensure that any key list or threshold keys are correctly handled,
    /// regardless of signing order, intervening changes, or other situations.
    /// The `scheduled_transaction` SHALL execute only if, at the time of
    /// execution, this list contains sufficient public keys to satisfy the
    /// full requirements for signature on that transaction.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Hedera.Hashgraph.Proto.Key> Signatories {
      get { return signatories_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Schedule);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Schedule other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(ScheduleId, other.ScheduleId)) return false;
      if (Deleted != other.Deleted) return false;
      if (Executed != other.Executed) return false;
      if (WaitForExpiry != other.WaitForExpiry) return false;
      if (Memo != other.Memo) return false;
      if (!object.Equals(SchedulerAccountId, other.SchedulerAccountId)) return false;
      if (!object.Equals(PayerAccountId, other.PayerAccountId)) return false;
      if (!object.Equals(AdminKey, other.AdminKey)) return false;
      if (!object.Equals(ScheduleValidStart, other.ScheduleValidStart)) return false;
      if (ProvidedExpirationSecond != other.ProvidedExpirationSecond) return false;
      if (CalculatedExpirationSecond != other.CalculatedExpirationSecond) return false;
      if (!object.Equals(ResolutionTime, other.ResolutionTime)) return false;
      if (!object.Equals(ScheduledTransaction, other.ScheduledTransaction)) return false;
      if (!object.Equals(OriginalCreateTransaction, other.OriginalCreateTransaction)) return false;
      if(!signatories_.Equals(other.signatories_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (scheduleId_ != null) hash ^= ScheduleId.GetHashCode();
      if (Deleted != false) hash ^= Deleted.GetHashCode();
      if (Executed != false) hash ^= Executed.GetHashCode();
      if (WaitForExpiry != false) hash ^= WaitForExpiry.GetHashCode();
      if (Memo.Length != 0) hash ^= Memo.GetHashCode();
      if (schedulerAccountId_ != null) hash ^= SchedulerAccountId.GetHashCode();
      if (payerAccountId_ != null) hash ^= PayerAccountId.GetHashCode();
      if (adminKey_ != null) hash ^= AdminKey.GetHashCode();
      if (scheduleValidStart_ != null) hash ^= ScheduleValidStart.GetHashCode();
      if (ProvidedExpirationSecond != 0L) hash ^= ProvidedExpirationSecond.GetHashCode();
      if (CalculatedExpirationSecond != 0L) hash ^= CalculatedExpirationSecond.GetHashCode();
      if (resolutionTime_ != null) hash ^= ResolutionTime.GetHashCode();
      if (scheduledTransaction_ != null) hash ^= ScheduledTransaction.GetHashCode();
      if (originalCreateTransaction_ != null) hash ^= OriginalCreateTransaction.GetHashCode();
      hash ^= signatories_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (scheduleId_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(ScheduleId);
      }
      if (Deleted != false) {
        output.WriteRawTag(16);
        output.WriteBool(Deleted);
      }
      if (Executed != false) {
        output.WriteRawTag(24);
        output.WriteBool(Executed);
      }
      if (WaitForExpiry != false) {
        output.WriteRawTag(32);
        output.WriteBool(WaitForExpiry);
      }
      if (Memo.Length != 0) {
        output.WriteRawTag(42);
        output.WriteString(Memo);
      }
      if (schedulerAccountId_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(SchedulerAccountId);
      }
      if (payerAccountId_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(PayerAccountId);
      }
      if (adminKey_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(AdminKey);
      }
      if (scheduleValidStart_ != null) {
        output.WriteRawTag(74);
        output.WriteMessage(ScheduleValidStart);
      }
      if (ProvidedExpirationSecond != 0L) {
        output.WriteRawTag(80);
        output.WriteInt64(ProvidedExpirationSecond);
      }
      if (CalculatedExpirationSecond != 0L) {
        output.WriteRawTag(88);
        output.WriteInt64(CalculatedExpirationSecond);
      }
      if (resolutionTime_ != null) {
        output.WriteRawTag(98);
        output.WriteMessage(ResolutionTime);
      }
      if (scheduledTransaction_ != null) {
        output.WriteRawTag(106);
        output.WriteMessage(ScheduledTransaction);
      }
      if (originalCreateTransaction_ != null) {
        output.WriteRawTag(114);
        output.WriteMessage(OriginalCreateTransaction);
      }
      signatories_.WriteTo(output, _repeated_signatories_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (scheduleId_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(ScheduleId);
      }
      if (Deleted != false) {
        output.WriteRawTag(16);
        output.WriteBool(Deleted);
      }
      if (Executed != false) {
        output.WriteRawTag(24);
        output.WriteBool(Executed);
      }
      if (WaitForExpiry != false) {
        output.WriteRawTag(32);
        output.WriteBool(WaitForExpiry);
      }
      if (Memo.Length != 0) {
        output.WriteRawTag(42);
        output.WriteString(Memo);
      }
      if (schedulerAccountId_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(SchedulerAccountId);
      }
      if (payerAccountId_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(PayerAccountId);
      }
      if (adminKey_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(AdminKey);
      }
      if (scheduleValidStart_ != null) {
        output.WriteRawTag(74);
        output.WriteMessage(ScheduleValidStart);
      }
      if (ProvidedExpirationSecond != 0L) {
        output.WriteRawTag(80);
        output.WriteInt64(ProvidedExpirationSecond);
      }
      if (CalculatedExpirationSecond != 0L) {
        output.WriteRawTag(88);
        output.WriteInt64(CalculatedExpirationSecond);
      }
      if (resolutionTime_ != null) {
        output.WriteRawTag(98);
        output.WriteMessage(ResolutionTime);
      }
      if (scheduledTransaction_ != null) {
        output.WriteRawTag(106);
        output.WriteMessage(ScheduledTransaction);
      }
      if (originalCreateTransaction_ != null) {
        output.WriteRawTag(114);
        output.WriteMessage(OriginalCreateTransaction);
      }
      signatories_.WriteTo(ref output, _repeated_signatories_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (scheduleId_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ScheduleId);
      }
      if (Deleted != false) {
        size += 1 + 1;
      }
      if (Executed != false) {
        size += 1 + 1;
      }
      if (WaitForExpiry != false) {
        size += 1 + 1;
      }
      if (Memo.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Memo);
      }
      if (schedulerAccountId_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SchedulerAccountId);
      }
      if (payerAccountId_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(PayerAccountId);
      }
      if (adminKey_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(AdminKey);
      }
      if (scheduleValidStart_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ScheduleValidStart);
      }
      if (ProvidedExpirationSecond != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(ProvidedExpirationSecond);
      }
      if (CalculatedExpirationSecond != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(CalculatedExpirationSecond);
      }
      if (resolutionTime_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ResolutionTime);
      }
      if (scheduledTransaction_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ScheduledTransaction);
      }
      if (originalCreateTransaction_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(OriginalCreateTransaction);
      }
      size += signatories_.CalculateSize(_repeated_signatories_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Schedule other) {
      if (other == null) {
        return;
      }
      if (other.scheduleId_ != null) {
        if (scheduleId_ == null) {
          ScheduleId = new global::Hedera.Hashgraph.Proto.ScheduleID();
        }
        ScheduleId.MergeFrom(other.ScheduleId);
      }
      if (other.Deleted != false) {
        Deleted = other.Deleted;
      }
      if (other.Executed != false) {
        Executed = other.Executed;
      }
      if (other.WaitForExpiry != false) {
        WaitForExpiry = other.WaitForExpiry;
      }
      if (other.Memo.Length != 0) {
        Memo = other.Memo;
      }
      if (other.schedulerAccountId_ != null) {
        if (schedulerAccountId_ == null) {
          SchedulerAccountId = new global::Hedera.Hashgraph.Proto.AccountID();
        }
        SchedulerAccountId.MergeFrom(other.SchedulerAccountId);
      }
      if (other.payerAccountId_ != null) {
        if (payerAccountId_ == null) {
          PayerAccountId = new global::Hedera.Hashgraph.Proto.AccountID();
        }
        PayerAccountId.MergeFrom(other.PayerAccountId);
      }
      if (other.adminKey_ != null) {
        if (adminKey_ == null) {
          AdminKey = new global::Hedera.Hashgraph.Proto.Key();
        }
        AdminKey.MergeFrom(other.AdminKey);
      }
      if (other.scheduleValidStart_ != null) {
        if (scheduleValidStart_ == null) {
          ScheduleValidStart = new global::Hedera.Hashgraph.Proto.Timestamp();
        }
        ScheduleValidStart.MergeFrom(other.ScheduleValidStart);
      }
      if (other.ProvidedExpirationSecond != 0L) {
        ProvidedExpirationSecond = other.ProvidedExpirationSecond;
      }
      if (other.CalculatedExpirationSecond != 0L) {
        CalculatedExpirationSecond = other.CalculatedExpirationSecond;
      }
      if (other.resolutionTime_ != null) {
        if (resolutionTime_ == null) {
          ResolutionTime = new global::Hedera.Hashgraph.Proto.Timestamp();
        }
        ResolutionTime.MergeFrom(other.ResolutionTime);
      }
      if (other.scheduledTransaction_ != null) {
        if (scheduledTransaction_ == null) {
          ScheduledTransaction = new global::Hedera.Hashgraph.Proto.SchedulableTransactionBody();
        }
        ScheduledTransaction.MergeFrom(other.ScheduledTransaction);
      }
      if (other.originalCreateTransaction_ != null) {
        if (originalCreateTransaction_ == null) {
          OriginalCreateTransaction = new global::Hedera.Hashgraph.Proto.TransactionBody();
        }
        OriginalCreateTransaction.MergeFrom(other.OriginalCreateTransaction);
      }
      signatories_.Add(other.signatories_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (scheduleId_ == null) {
              ScheduleId = new global::Hedera.Hashgraph.Proto.ScheduleID();
            }
            input.ReadMessage(ScheduleId);
            break;
          }
          case 16: {
            Deleted = input.ReadBool();
            break;
          }
          case 24: {
            Executed = input.ReadBool();
            break;
          }
          case 32: {
            WaitForExpiry = input.ReadBool();
            break;
          }
          case 42: {
            Memo = input.ReadString();
            break;
          }
          case 50: {
            if (schedulerAccountId_ == null) {
              SchedulerAccountId = new global::Hedera.Hashgraph.Proto.AccountID();
            }
            input.ReadMessage(SchedulerAccountId);
            break;
          }
          case 58: {
            if (payerAccountId_ == null) {
              PayerAccountId = new global::Hedera.Hashgraph.Proto.AccountID();
            }
            input.ReadMessage(PayerAccountId);
            break;
          }
          case 66: {
            if (adminKey_ == null) {
              AdminKey = new global::Hedera.Hashgraph.Proto.Key();
            }
            input.ReadMessage(AdminKey);
            break;
          }
          case 74: {
            if (scheduleValidStart_ == null) {
              ScheduleValidStart = new global::Hedera.Hashgraph.Proto.Timestamp();
            }
            input.ReadMessage(ScheduleValidStart);
            break;
          }
          case 80: {
            ProvidedExpirationSecond = input.ReadInt64();
            break;
          }
          case 88: {
            CalculatedExpirationSecond = input.ReadInt64();
            break;
          }
          case 98: {
            if (resolutionTime_ == null) {
              ResolutionTime = new global::Hedera.Hashgraph.Proto.Timestamp();
            }
            input.ReadMessage(ResolutionTime);
            break;
          }
          case 106: {
            if (scheduledTransaction_ == null) {
              ScheduledTransaction = new global::Hedera.Hashgraph.Proto.SchedulableTransactionBody();
            }
            input.ReadMessage(ScheduledTransaction);
            break;
          }
          case 114: {
            if (originalCreateTransaction_ == null) {
              OriginalCreateTransaction = new global::Hedera.Hashgraph.Proto.TransactionBody();
            }
            input.ReadMessage(OriginalCreateTransaction);
            break;
          }
          case 122: {
            signatories_.AddEntriesFrom(input, _repeated_signatories_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (scheduleId_ == null) {
              ScheduleId = new global::Hedera.Hashgraph.Proto.ScheduleID();
            }
            input.ReadMessage(ScheduleId);
            break;
          }
          case 16: {
            Deleted = input.ReadBool();
            break;
          }
          case 24: {
            Executed = input.ReadBool();
            break;
          }
          case 32: {
            WaitForExpiry = input.ReadBool();
            break;
          }
          case 42: {
            Memo = input.ReadString();
            break;
          }
          case 50: {
            if (schedulerAccountId_ == null) {
              SchedulerAccountId = new global::Hedera.Hashgraph.Proto.AccountID();
            }
            input.ReadMessage(SchedulerAccountId);
            break;
          }
          case 58: {
            if (payerAccountId_ == null) {
              PayerAccountId = new global::Hedera.Hashgraph.Proto.AccountID();
            }
            input.ReadMessage(PayerAccountId);
            break;
          }
          case 66: {
            if (adminKey_ == null) {
              AdminKey = new global::Hedera.Hashgraph.Proto.Key();
            }
            input.ReadMessage(AdminKey);
            break;
          }
          case 74: {
            if (scheduleValidStart_ == null) {
              ScheduleValidStart = new global::Hedera.Hashgraph.Proto.Timestamp();
            }
            input.ReadMessage(ScheduleValidStart);
            break;
          }
          case 80: {
            ProvidedExpirationSecond = input.ReadInt64();
            break;
          }
          case 88: {
            CalculatedExpirationSecond = input.ReadInt64();
            break;
          }
          case 98: {
            if (resolutionTime_ == null) {
              ResolutionTime = new global::Hedera.Hashgraph.Proto.Timestamp();
            }
            input.ReadMessage(ResolutionTime);
            break;
          }
          case 106: {
            if (scheduledTransaction_ == null) {
              ScheduledTransaction = new global::Hedera.Hashgraph.Proto.SchedulableTransactionBody();
            }
            input.ReadMessage(ScheduledTransaction);
            break;
          }
          case 114: {
            if (originalCreateTransaction_ == null) {
              OriginalCreateTransaction = new global::Hedera.Hashgraph.Proto.TransactionBody();
            }
            input.ReadMessage(OriginalCreateTransaction);
            break;
          }
          case 122: {
            signatories_.AddEntriesFrom(ref input, _repeated_signatories_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// A message for storing a list of schedules in state.&lt;br/>
  /// This is used to store lists of `Schedule` values.
  /// One example is all schedules that expire at a particular time.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class ScheduleList : pb::IMessage<ScheduleList>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ScheduleList> _parser = new pb::MessageParser<ScheduleList>(() => new ScheduleList());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ScheduleList> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Hedera.Hashgraph.Proto.ScheduleReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ScheduleList() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ScheduleList(ScheduleList other) : this() {
      schedules_ = other.schedules_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ScheduleList Clone() {
      return new ScheduleList(this);
    }

    /// <summary>Field number for the "schedules" field.</summary>
    public const int SchedulesFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Hedera.Hashgraph.Proto.Schedule> _repeated_schedules_codec
        = pb::FieldCodec.ForMessage(10, global::Hedera.Hashgraph.Proto.Schedule.Parser);
    private readonly pbc::RepeatedField<global::Hedera.Hashgraph.Proto.Schedule> schedules_ = new pbc::RepeatedField<global::Hedera.Hashgraph.Proto.Schedule>();
    /// <summary>
    ///*
    /// a list of schedules, in no particular order.
    /// &lt;p>
    /// While the order is not _specified_, it MUST be deterministic.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Hedera.Hashgraph.Proto.Schedule> Schedules {
      get { return schedules_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ScheduleList);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ScheduleList other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!schedules_.Equals(other.schedules_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= schedules_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      schedules_.WriteTo(output, _repeated_schedules_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      schedules_.WriteTo(ref output, _repeated_schedules_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += schedules_.CalculateSize(_repeated_schedules_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ScheduleList other) {
      if (other == null) {
        return;
      }
      schedules_.Add(other.schedules_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            schedules_.AddEntriesFrom(input, _repeated_schedules_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            schedules_.AddEntriesFrom(ref input, _repeated_schedules_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// A message for storing a list of schedule identifiers in state.&lt;br/>
  /// This is used to store lists of `ScheduleID` values.
  /// One example is all schedules that expire at a particular time.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class ScheduleIdList : pb::IMessage<ScheduleIdList>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ScheduleIdList> _parser = new pb::MessageParser<ScheduleIdList>(() => new ScheduleIdList());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ScheduleIdList> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Hedera.Hashgraph.Proto.ScheduleReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ScheduleIdList() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ScheduleIdList(ScheduleIdList other) : this() {
      scheduleIds_ = other.scheduleIds_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ScheduleIdList Clone() {
      return new ScheduleIdList(this);
    }

    /// <summary>Field number for the "schedule_ids" field.</summary>
    public const int ScheduleIdsFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Hedera.Hashgraph.Proto.ScheduleID> _repeated_scheduleIds_codec
        = pb::FieldCodec.ForMessage(10, global::Hedera.Hashgraph.Proto.ScheduleID.Parser);
    private readonly pbc::RepeatedField<global::Hedera.Hashgraph.Proto.ScheduleID> scheduleIds_ = new pbc::RepeatedField<global::Hedera.Hashgraph.Proto.ScheduleID>();
    /// <summary>
    ///*
    /// A list of schedule identifiers, in no particular order.
    /// &lt;p>
    /// While the order is not _specified_, it MUST be deterministic.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Hedera.Hashgraph.Proto.ScheduleID> ScheduleIds {
      get { return scheduleIds_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ScheduleIdList);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ScheduleIdList other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!scheduleIds_.Equals(other.scheduleIds_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= scheduleIds_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      scheduleIds_.WriteTo(output, _repeated_scheduleIds_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      scheduleIds_.WriteTo(ref output, _repeated_scheduleIds_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += scheduleIds_.CalculateSize(_repeated_scheduleIds_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ScheduleIdList other) {
      if (other == null) {
        return;
      }
      scheduleIds_.Add(other.scheduleIds_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            scheduleIds_.AddEntriesFrom(input, _repeated_scheduleIds_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            scheduleIds_.AddEntriesFrom(ref input, _repeated_scheduleIds_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// A count of schedules scheduled and processed.
  /// This value summarizes the counts of scheduled and processed transactions
  /// within a particular consensus second.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class ScheduledCounts : pb::IMessage<ScheduledCounts>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ScheduledCounts> _parser = new pb::MessageParser<ScheduledCounts>(() => new ScheduledCounts());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ScheduledCounts> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Hedera.Hashgraph.Proto.ScheduleReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ScheduledCounts() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ScheduledCounts(ScheduledCounts other) : this() {
      numberScheduled_ = other.numberScheduled_;
      numberProcessed_ = other.numberProcessed_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ScheduledCounts Clone() {
      return new ScheduledCounts(this);
    }

    /// <summary>Field number for the "number_scheduled" field.</summary>
    public const int NumberScheduledFieldNumber = 1;
    private uint numberScheduled_;
    /// <summary>
    ///*
    /// A number of transactions scheduled to expire at a consensus second.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint NumberScheduled {
      get { return numberScheduled_; }
      set {
        numberScheduled_ = value;
      }
    }

    /// <summary>Field number for the "number_processed" field.</summary>
    public const int NumberProcessedFieldNumber = 2;
    private uint numberProcessed_;
    /// <summary>
    ///*
    /// A number of scheduled transactions that have been processed at
    /// a consensus second.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint NumberProcessed {
      get { return numberProcessed_; }
      set {
        numberProcessed_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ScheduledCounts);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ScheduledCounts other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (NumberScheduled != other.NumberScheduled) return false;
      if (NumberProcessed != other.NumberProcessed) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (NumberScheduled != 0) hash ^= NumberScheduled.GetHashCode();
      if (NumberProcessed != 0) hash ^= NumberProcessed.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (NumberScheduled != 0) {
        output.WriteRawTag(8);
        output.WriteUInt32(NumberScheduled);
      }
      if (NumberProcessed != 0) {
        output.WriteRawTag(16);
        output.WriteUInt32(NumberProcessed);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (NumberScheduled != 0) {
        output.WriteRawTag(8);
        output.WriteUInt32(NumberScheduled);
      }
      if (NumberProcessed != 0) {
        output.WriteRawTag(16);
        output.WriteUInt32(NumberProcessed);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (NumberScheduled != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(NumberScheduled);
      }
      if (NumberProcessed != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(NumberProcessed);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ScheduledCounts other) {
      if (other == null) {
        return;
      }
      if (other.NumberScheduled != 0) {
        NumberScheduled = other.NumberScheduled;
      }
      if (other.NumberProcessed != 0) {
        NumberProcessed = other.NumberProcessed;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            NumberScheduled = input.ReadUInt32();
            break;
          }
          case 16: {
            NumberProcessed = input.ReadUInt32();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            NumberScheduled = input.ReadUInt32();
            break;
          }
          case 16: {
            NumberProcessed = input.ReadUInt32();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// An ordering for a scheduled transaction.&lt;br/>
  /// This establishes the order in which scheduled transactions intended to
  /// execute at a particular consensus second will be executed.
  ///
  /// Scheduled transactions that have the same `expiry_second` SHALL execute
  /// in ascending order of `order_number`.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class ScheduledOrder : pb::IMessage<ScheduledOrder>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ScheduledOrder> _parser = new pb::MessageParser<ScheduledOrder>(() => new ScheduledOrder());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ScheduledOrder> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Hedera.Hashgraph.Proto.ScheduleReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ScheduledOrder() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ScheduledOrder(ScheduledOrder other) : this() {
      expirySecond_ = other.expirySecond_;
      orderNumber_ = other.orderNumber_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ScheduledOrder Clone() {
      return new ScheduledOrder(this);
    }

    /// <summary>Field number for the "expiry_second" field.</summary>
    public const int ExpirySecondFieldNumber = 1;
    private ulong expirySecond_;
    /// <summary>
    ///*
    /// A consensus second in which the transaction is to be executed.
    /// This is _also_ the consensus time when the transaction will expire
    /// if it has not gathered enough signatures in time.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ulong ExpirySecond {
      get { return expirySecond_; }
      set {
        expirySecond_ = value;
      }
    }

    /// <summary>Field number for the "order_number" field.</summary>
    public const int OrderNumberFieldNumber = 2;
    private uint orderNumber_;
    /// <summary>
    ///
    /// An ordered position within a conceptual list.&lt;br/>
    /// This is the ordered position within the consensus second when
    /// the associated transaction will be executed.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint OrderNumber {
      get { return orderNumber_; }
      set {
        orderNumber_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ScheduledOrder);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ScheduledOrder other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (ExpirySecond != other.ExpirySecond) return false;
      if (OrderNumber != other.OrderNumber) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (ExpirySecond != 0UL) hash ^= ExpirySecond.GetHashCode();
      if (OrderNumber != 0) hash ^= OrderNumber.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (ExpirySecond != 0UL) {
        output.WriteRawTag(8);
        output.WriteUInt64(ExpirySecond);
      }
      if (OrderNumber != 0) {
        output.WriteRawTag(16);
        output.WriteUInt32(OrderNumber);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (ExpirySecond != 0UL) {
        output.WriteRawTag(8);
        output.WriteUInt64(ExpirySecond);
      }
      if (OrderNumber != 0) {
        output.WriteRawTag(16);
        output.WriteUInt32(OrderNumber);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (ExpirySecond != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(ExpirySecond);
      }
      if (OrderNumber != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(OrderNumber);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ScheduledOrder other) {
      if (other == null) {
        return;
      }
      if (other.ExpirySecond != 0UL) {
        ExpirySecond = other.ExpirySecond;
      }
      if (other.OrderNumber != 0) {
        OrderNumber = other.OrderNumber;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            ExpirySecond = input.ReadUInt64();
            break;
          }
          case 16: {
            OrderNumber = input.ReadUInt32();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            ExpirySecond = input.ReadUInt64();
            break;
          }
          case 16: {
            OrderNumber = input.ReadUInt32();
            break;
          }
        }
      }
    }
    #endif

  }

  #endregion

}

#endregion Designer generated code
