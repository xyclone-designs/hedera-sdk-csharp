// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: contract_create.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021, 8981
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Hedera.Hashgraph.Proto {

  /// <summary>Holder for reflection information generated from contract_create.proto</summary>
  public static partial class ContractCreateReflection {

    #region Descriptor
    /// <summary>File descriptor for contract_create.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static ContractCreateReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "ChVjb250cmFjdF9jcmVhdGUucHJvdG8SBXByb3RvGhFiYXNpY190eXBlcy5w",
            "cm90bxoOZHVyYXRpb24ucHJvdG8aEGhvb2tfdHlwZXMucHJvdG8irwUKHUNv",
            "bnRyYWN0Q3JlYXRlVHJhbnNhY3Rpb25Cb2R5Eh8KBmZpbGVJRBgBIAEoCzIN",
            "LnByb3RvLkZpbGVJREgAEhIKCGluaXRjb2RlGBAgASgMSAASHAoIYWRtaW5L",
            "ZXkYAyABKAsyCi5wcm90by5LZXkSCwoDZ2FzGAQgASgDEhYKDmluaXRpYWxC",
            "YWxhbmNlGAUgASgDEiwKDnByb3h5QWNjb3VudElEGAYgASgLMhAucHJvdG8u",
            "QWNjb3VudElEQgIYARIoCg9hdXRvUmVuZXdQZXJpb2QYCCABKAsyDy5wcm90",
            "by5EdXJhdGlvbhIdChVjb25zdHJ1Y3RvclBhcmFtZXRlcnMYCSABKAwSHwoH",
            "c2hhcmRJRBgKIAEoCzIOLnByb3RvLlNoYXJkSUQSHwoHcmVhbG1JRBgLIAEo",
            "CzIOLnByb3RvLlJlYWxtSUQSJAoQbmV3UmVhbG1BZG1pbktleRgMIAEoCzIK",
            "LnByb3RvLktleRIMCgRtZW1vGA0gASgJEigKIG1heF9hdXRvbWF0aWNfdG9r",
            "ZW5fYXNzb2NpYXRpb25zGA4gASgFEi8KFWF1dG9fcmVuZXdfYWNjb3VudF9p",
            "ZBgPIAEoCzIQLnByb3RvLkFjY291bnRJRBItChFzdGFrZWRfYWNjb3VudF9p",
            "ZBgRIAEoCzIQLnByb3RvLkFjY291bnRJREgBEhgKDnN0YWtlZF9ub2RlX2lk",
            "GBIgASgDSAESFgoOZGVjbGluZV9yZXdhcmQYEyABKAgSTgoVaG9va19jcmVh",
            "dGlvbl9kZXRhaWxzGBQgAygLMi8uY29tLmhlZGVyYS5oYXBpLm5vZGUuaG9v",
            "a3MuSG9va0NyZWF0aW9uRGV0YWlsc0IQCg5pbml0Y29kZVNvdXJjZUILCglz",
            "dGFrZWRfaWRCOQoeY29tLmhlZGVyYS5oYXNoZ3JhcGguc2RrLnByb3RvqgIW",
            "SGVkZXJhLkhhc2hncmFwaC5Qcm90b2IGcHJvdG8z"));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Hedera.Hashgraph.Proto.BasicTypesReflection.Descriptor, global::Hedera.Hashgraph.Proto.DurationReflection.Descriptor, global::Hedera.Hashgraph.Proto.HookTypesReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Hedera.Hashgraph.Proto.ContractCreateTransactionBody), global::Hedera.Hashgraph.Proto.ContractCreateTransactionBody.Parser, new[]{ "FileID", "Initcode", "AdminKey", "Gas", "InitialBalance", "ProxyAccountID", "AutoRenewPeriod", "ConstructorParameters", "ShardID", "RealmID", "NewRealmAdminKey", "Memo", "MaxAutomaticTokenAssociations", "AutoRenewAccountId", "StakedAccountId", "StakedNodeId", "DeclineReward", "HookCreationDetails" }, new[]{ "InitcodeSource", "StakedId" }, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  ///*
  /// Create a new smart contract.
  ///
  /// If this transaction succeeds, the `ContractID` for the new smart contract
  /// SHALL be set in the transaction receipt.&lt;br/>
  /// The contract is defined by the initial bytecode (or `initcode`). The
  /// `initcode` SHALL be stored either in a previously created file, or in the
  /// transaction body itself for very small contracts.
  ///
  /// As part of contract creation, the constructor defined for the new smart
  /// contract SHALL run with the parameters provided in the
  /// `constructorParameters` field.&lt;br/>
  /// The gas to "power" that constructor MUST be provided via the `gas` field,
  /// and SHALL be charged to the payer for this transaction.&lt;br/>
  /// If the contract _constructor_ stores information, it is charged gas for that
  /// storage. There is a separate fee in HBAR to maintain that storage until the
  /// expiration, and that fee SHALL be added to this transaction as part of the
  /// _transaction fee_, rather than gas.
  ///
  /// ### Block Stream Effects
  /// A `CreateContractOutput` message SHALL be emitted for each transaction.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class ContractCreateTransactionBody : pb::IMessage<ContractCreateTransactionBody>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ContractCreateTransactionBody> _parser = new pb::MessageParser<ContractCreateTransactionBody>(() => new ContractCreateTransactionBody());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ContractCreateTransactionBody> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Hedera.Hashgraph.Proto.ContractCreateReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ContractCreateTransactionBody() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ContractCreateTransactionBody(ContractCreateTransactionBody other) : this() {
      adminKey_ = other.adminKey_ != null ? other.adminKey_.Clone() : null;
      gas_ = other.gas_;
      initialBalance_ = other.initialBalance_;
      proxyAccountID_ = other.proxyAccountID_ != null ? other.proxyAccountID_.Clone() : null;
      autoRenewPeriod_ = other.autoRenewPeriod_ != null ? other.autoRenewPeriod_.Clone() : null;
      constructorParameters_ = other.constructorParameters_;
      shardID_ = other.shardID_ != null ? other.shardID_.Clone() : null;
      realmID_ = other.realmID_ != null ? other.realmID_.Clone() : null;
      newRealmAdminKey_ = other.newRealmAdminKey_ != null ? other.newRealmAdminKey_.Clone() : null;
      memo_ = other.memo_;
      maxAutomaticTokenAssociations_ = other.maxAutomaticTokenAssociations_;
      autoRenewAccountId_ = other.autoRenewAccountId_ != null ? other.autoRenewAccountId_.Clone() : null;
      declineReward_ = other.declineReward_;
      hookCreationDetails_ = other.hookCreationDetails_.Clone();
      switch (other.InitcodeSourceCase) {
        case InitcodeSourceOneofCase.FileID:
          FileID = other.FileID.Clone();
          break;
        case InitcodeSourceOneofCase.Initcode:
          Initcode = other.Initcode;
          break;
      }

      switch (other.StakedIdCase) {
        case StakedIdOneofCase.StakedAccountId:
          StakedAccountId = other.StakedAccountId.Clone();
          break;
        case StakedIdOneofCase.StakedNodeId:
          StakedNodeId = other.StakedNodeId;
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ContractCreateTransactionBody Clone() {
      return new ContractCreateTransactionBody(this);
    }

    /// <summary>Field number for the "fileID" field.</summary>
    public const int FileIDFieldNumber = 1;
    /// <summary>
    ///*
    /// The source for the smart contract EVM bytecode.
    /// &lt;p>
    /// The file containing the smart contract initcode.
    /// A copy of the contents SHALL be made and held as `bytes`
    /// in smart contract state.&lt;br/>
    /// The contract bytecode is limited in size only by the
    /// network file size limit.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Hedera.Hashgraph.Proto.FileID FileID {
      get { return initcodeSourceCase_ == InitcodeSourceOneofCase.FileID ? (global::Hedera.Hashgraph.Proto.FileID) initcodeSource_ : null; }
      set {
        initcodeSource_ = value;
        initcodeSourceCase_ = value == null ? InitcodeSourceOneofCase.None : InitcodeSourceOneofCase.FileID;
      }
    }

    /// <summary>Field number for the "initcode" field.</summary>
    public const int InitcodeFieldNumber = 16;
    /// <summary>
    ///*
    /// The source for the smart contract EVM bytecode.
    /// &lt;p>
    /// The bytes of the smart contract initcode. A copy of the contents
    /// SHALL be made and held as `bytes` in smart contract state.&lt;br/>
    /// This value is limited in length by the network transaction size
    /// limit. This entire transaction, including all fields and signatures,
    /// MUST be less than the network transaction size limit.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString Initcode {
      get { return HasInitcode ? (pb::ByteString) initcodeSource_ : pb::ByteString.Empty; }
      set {
        initcodeSource_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        initcodeSourceCase_ = InitcodeSourceOneofCase.Initcode;
      }
    }
    /// <summary>Gets whether the "initcode" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasInitcode {
      get { return initcodeSourceCase_ == InitcodeSourceOneofCase.Initcode; }
    }
    /// <summary> Clears the value of the oneof if it's currently set to "initcode" </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearInitcode() {
      if (HasInitcode) {
        ClearInitcodeSource();
      }
    }

    /// <summary>Field number for the "adminKey" field.</summary>
    public const int AdminKeyFieldNumber = 3;
    private global::Hedera.Hashgraph.Proto.Key adminKey_;
    /// <summary>
    ///*
    /// Access control for modification of the smart contract after
    /// it is created.
    /// &lt;p>
    /// If this field is set, that key MUST sign this transaction.&lt;br/>
    /// If this field is set, that key MUST sign each future transaction to
    /// update or delete the contract.&lt;br/>
    /// An updateContract transaction that _only_ extends the topic
    /// expirationTime (a "manual renewal" transaction) SHALL NOT require
    /// admin key signature.
    /// &lt;p>
    /// A contract without an admin key SHALL be immutable, except for
    /// expiration and renewal.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Hedera.Hashgraph.Proto.Key AdminKey {
      get { return adminKey_; }
      set {
        adminKey_ = value;
      }
    }

    /// <summary>Field number for the "gas" field.</summary>
    public const int GasFieldNumber = 4;
    private long gas_;
    /// <summary>
    ///*
    /// A maximum limit to the amount of gas to use for the constructor call.
    /// &lt;p>
    /// The network SHALL charge the greater of the following, but SHALL NOT
    /// charge more than the value of this field.
    /// &lt;ol>
    ///   &lt;li>The actual gas consumed by the smart contract
    ///       constructor call.&lt;/li>
    ///   &lt;li>`80%` of this value.&lt;/li>
    /// &lt;/ol>
    /// The `80%` factor encourages reasonable estimation, while allowing for
    /// some overage to ensure successful execution.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long Gas {
      get { return gas_; }
      set {
        gas_ = value;
      }
    }

    /// <summary>Field number for the "initialBalance" field.</summary>
    public const int InitialBalanceFieldNumber = 5;
    private long initialBalance_;
    /// <summary>
    ///*
    /// The amount of HBAR to use as an initial balance for the account
    /// representing the new smart contract.
    /// &lt;p>
    /// This value is presented in tinybar
    /// (10&lt;sup>&lt;strong>-&lt;/strong>8&lt;/sup> HBAR).&lt;br/>
    /// The HBAR provided here will be withdrawn from the payer account that
    /// signed this transaction.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long InitialBalance {
      get { return initialBalance_; }
      set {
        initialBalance_ = value;
      }
    }

    /// <summary>Field number for the "proxyAccountID" field.</summary>
    public const int ProxyAccountIDFieldNumber = 6;
    private global::Hedera.Hashgraph.Proto.AccountID proxyAccountID_;
    /// <summary>
    ///*
    /// Proxy account staking is handled via `staked_id`.
    /// &lt;p>
    /// Former field to designate a proxy account for HBAR staking.
    /// This field MUST NOT be set.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Hedera.Hashgraph.Proto.AccountID ProxyAccountID {
      get { return proxyAccountID_; }
      set {
        proxyAccountID_ = value;
      }
    }

    /// <summary>Field number for the "autoRenewPeriod" field.</summary>
    public const int AutoRenewPeriodFieldNumber = 8;
    private global::Hedera.Hashgraph.Proto.Duration autoRenewPeriod_;
    /// <summary>
    ///*
    /// The initial lifetime, in seconds, for the smart contract, and the number
    /// of seconds for which the smart contract will be automatically renewed
    /// upon expiration.
    /// &lt;p>
    /// This value MUST be set.&lt;br/>
    /// This value MUST be greater than the configured MIN_AUTORENEW_PERIOD.&lt;br/>
    /// This value MUST be less than the configured MAX_AUTORENEW_PERIOD.&lt;br/>
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Hedera.Hashgraph.Proto.Duration AutoRenewPeriod {
      get { return autoRenewPeriod_; }
      set {
        autoRenewPeriod_ = value;
      }
    }

    /// <summary>Field number for the "constructorParameters" field.</summary>
    public const int ConstructorParametersFieldNumber = 9;
    private pb::ByteString constructorParameters_ = pb::ByteString.Empty;
    /// <summary>
    ///*
    /// An array of bytes containing the EVM-encoded parameters to pass to
    /// the smart contract constructor defined in the smart contract init
    /// code provided.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString ConstructorParameters {
      get { return constructorParameters_; }
      set {
        constructorParameters_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "shardID" field.</summary>
    public const int ShardIDFieldNumber = 10;
    private global::Hedera.Hashgraph.Proto.ShardID shardID_;
    /// <summary>
    ///*
    /// &lt;blockquote>Review Question&lt;br/>
    /// &lt;blockquote>Should this be deprecated?&lt;br/>
    /// It's never been used and probably never should be used...&lt;br/>
    /// Shard should be determined by the node the transaction is submitted to.
    /// &lt;/blockquote>&lt;/blockquote>
    /// &lt;p>
    /// The shard in which to create the new smart contract.&lt;br/>
    /// This value is currently ignored.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Hedera.Hashgraph.Proto.ShardID ShardID {
      get { return shardID_; }
      set {
        shardID_ = value;
      }
    }

    /// <summary>Field number for the "realmID" field.</summary>
    public const int RealmIDFieldNumber = 11;
    private global::Hedera.Hashgraph.Proto.RealmID realmID_;
    /// <summary>
    ///*
    /// &lt;blockquote>Review Question&lt;br/>
    /// &lt;blockquote>Should this be deprecated?&lt;br/>
    /// It's never been used and probably never should be used...&lt;br/>
    /// Realm should be determined by node and network parameters.
    /// &lt;/blockquote>&lt;/blockquote>
    /// &lt;p>
    /// The shard/realm in which to create the new smart contract.&lt;br/>
    /// This value is currently ignored.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Hedera.Hashgraph.Proto.RealmID RealmID {
      get { return realmID_; }
      set {
        realmID_ = value;
      }
    }

    /// <summary>Field number for the "newRealmAdminKey" field.</summary>
    public const int NewRealmAdminKeyFieldNumber = 12;
    private global::Hedera.Hashgraph.Proto.Key newRealmAdminKey_;
    /// <summary>
    ///*
    /// &lt;blockquote>Review Question&lt;br/>
    /// &lt;blockquote>Should this be deprecated?&lt;br/>
    /// It's never been used and probably never should be used...&lt;br/>
    /// If a realm is used, it must already exist; we shouldn't be creating it
    /// without a separate transaction.&lt;/blockquote>&lt;/blockquote>
    /// &lt;p>
    /// This was intended to provide an admin key for any new realm created
    /// during the creation of the smart contract.&lt;br/>
    /// This value is currently ignored. a new realm SHALL NOT be created,
    /// regardless of the value of `realmID`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Hedera.Hashgraph.Proto.Key NewRealmAdminKey {
      get { return newRealmAdminKey_; }
      set {
        newRealmAdminKey_ = value;
      }
    }

    /// <summary>Field number for the "memo" field.</summary>
    public const int MemoFieldNumber = 13;
    private string memo_ = "";
    /// <summary>
    ///*
    /// A short memo for this smart contract.
    /// &lt;p>
    /// This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
    /// (default 100) bytes when encoded as UTF-8.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Memo {
      get { return memo_; }
      set {
        memo_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "max_automatic_token_associations" field.</summary>
    public const int MaxAutomaticTokenAssociationsFieldNumber = 14;
    private int maxAutomaticTokenAssociations_;
    /// <summary>
    ///*
    /// The maximum number of tokens that can be auto-associated with this
    /// smart contract.
    /// &lt;p>
    /// If this is less than or equal to `used_auto_associations` (or 0), then
    /// this contract MUST manually associate with a token before transacting
    /// in that token.&lt;br/>
    /// Following HIP-904 This value may also be `-1` to indicate no limit.&lt;br/>
    /// This value MUST NOT be less than `-1`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int MaxAutomaticTokenAssociations {
      get { return maxAutomaticTokenAssociations_; }
      set {
        maxAutomaticTokenAssociations_ = value;
      }
    }

    /// <summary>Field number for the "auto_renew_account_id" field.</summary>
    public const int AutoRenewAccountIdFieldNumber = 15;
    private global::Hedera.Hashgraph.Proto.AccountID autoRenewAccountId_;
    /// <summary>
    ///*
    /// The id of an account, in the same shard and realm as this smart
    /// contract, that has signed this transaction, allowing the network to use
    /// its balance, when needed, to automatically extend this contract's
    /// expiration time.
    /// &lt;p>
    /// If this field is set, that key MUST sign this transaction.&lt;br/>
    /// If this field is set, then the network SHALL deduct the necessary fees
    /// from the designated auto renew account, if that account has sufficient
    /// balance. If the auto renew account does not have sufficient balance,
    /// then the fees for contract renewal SHALL be deducted from the HBAR
    /// balance held by the smart contract.&lt;br/>
    /// If this field is not set, then all renewal fees SHALL be deducted from
    /// the HBAR balance held by this contract.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Hedera.Hashgraph.Proto.AccountID AutoRenewAccountId {
      get { return autoRenewAccountId_; }
      set {
        autoRenewAccountId_ = value;
      }
    }

    /// <summary>Field number for the "staked_account_id" field.</summary>
    public const int StakedAccountIdFieldNumber = 17;
    /// <summary>
    ///*
    /// An account ID.
    /// &lt;p>
    /// This smart contract SHALL stake its HBAR via this account as proxy.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Hedera.Hashgraph.Proto.AccountID StakedAccountId {
      get { return stakedIdCase_ == StakedIdOneofCase.StakedAccountId ? (global::Hedera.Hashgraph.Proto.AccountID) stakedId_ : null; }
      set {
        stakedId_ = value;
        stakedIdCase_ = value == null ? StakedIdOneofCase.None : StakedIdOneofCase.StakedAccountId;
      }
    }

    /// <summary>Field number for the "staked_node_id" field.</summary>
    public const int StakedNodeIdFieldNumber = 18;
    /// <summary>
    ///*
    /// The ID of a network node.
    /// &lt;p>
    /// This smart contract SHALL stake its HBAR to this node.
    /// &lt;p>
    /// &lt;blockquote>Note: node IDs do fluctuate as node operators change.
    /// Most contracts are immutable, and a contract staking to an invalid
    /// node ID SHALL NOT participate in staking. Immutable contracts MAY
    /// find it more reliable to use a proxy account for staking
    /// (via `staked_account_id`) to enable updating the _effective_ staking
    /// node ID when necessary through updating the proxy
    /// account.&lt;/blockquote>
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long StakedNodeId {
      get { return HasStakedNodeId ? (long) stakedId_ : 0L; }
      set {
        stakedId_ = value;
        stakedIdCase_ = StakedIdOneofCase.StakedNodeId;
      }
    }
    /// <summary>Gets whether the "staked_node_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasStakedNodeId {
      get { return stakedIdCase_ == StakedIdOneofCase.StakedNodeId; }
    }
    /// <summary> Clears the value of the oneof if it's currently set to "staked_node_id" </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearStakedNodeId() {
      if (HasStakedNodeId) {
        ClearStakedId();
      }
    }

    /// <summary>Field number for the "decline_reward" field.</summary>
    public const int DeclineRewardFieldNumber = 19;
    private bool declineReward_;
    /// <summary>
    ///*
    /// A flag indicating that this smart contract declines to receive any
    /// reward for staking its HBAR balance to help secure the network.
    /// &lt;p>
    /// If set to true, this smart contract SHALL NOT receive any reward for
    /// staking its HBAR balance to help secure the network, regardless of
    /// staking configuration, but MAY stake HBAR to support the network
    /// without reward.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool DeclineReward {
      get { return declineReward_; }
      set {
        declineReward_ = value;
      }
    }

    /// <summary>Field number for the "hook_creation_details" field.</summary>
    public const int HookCreationDetailsFieldNumber = 20;
    private static readonly pb::FieldCodec<global::Hedera.Hashgraph.Proto.HookCreationDetails> _repeated_hookCreationDetails_codec
        = pb::FieldCodec.ForMessage(162, global::Hedera.Hashgraph.Proto.HookCreationDetails.Parser);
    private readonly pbc::RepeatedField<global::Hedera.Hashgraph.Proto.HookCreationDetails> hookCreationDetails_ = new pbc::RepeatedField<global::Hedera.Hashgraph.Proto.HookCreationDetails>();
    /// <summary>
    ///*
    /// Details of hooks to add immediately after creating this contract.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Hedera.Hashgraph.Proto.HookCreationDetails> HookCreationDetails {
      get { return hookCreationDetails_; }
    }

    private object initcodeSource_;
    /// <summary>Enum of possible cases for the "initcodeSource" oneof.</summary>
    public enum InitcodeSourceOneofCase {
      None = 0,
      FileID = 1,
      Initcode = 16,
    }
    private InitcodeSourceOneofCase initcodeSourceCase_ = InitcodeSourceOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public InitcodeSourceOneofCase InitcodeSourceCase {
      get { return initcodeSourceCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearInitcodeSource() {
      initcodeSourceCase_ = InitcodeSourceOneofCase.None;
      initcodeSource_ = null;
    }

    private object stakedId_;
    /// <summary>Enum of possible cases for the "staked_id" oneof.</summary>
    public enum StakedIdOneofCase {
      None = 0,
      StakedAccountId = 17,
      StakedNodeId = 18,
    }
    private StakedIdOneofCase stakedIdCase_ = StakedIdOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public StakedIdOneofCase StakedIdCase {
      get { return stakedIdCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearStakedId() {
      stakedIdCase_ = StakedIdOneofCase.None;
      stakedId_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ContractCreateTransactionBody);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ContractCreateTransactionBody other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(FileID, other.FileID)) return false;
      if (Initcode != other.Initcode) return false;
      if (!object.Equals(AdminKey, other.AdminKey)) return false;
      if (Gas != other.Gas) return false;
      if (InitialBalance != other.InitialBalance) return false;
      if (!object.Equals(ProxyAccountID, other.ProxyAccountID)) return false;
      if (!object.Equals(AutoRenewPeriod, other.AutoRenewPeriod)) return false;
      if (ConstructorParameters != other.ConstructorParameters) return false;
      if (!object.Equals(ShardID, other.ShardID)) return false;
      if (!object.Equals(RealmID, other.RealmID)) return false;
      if (!object.Equals(NewRealmAdminKey, other.NewRealmAdminKey)) return false;
      if (Memo != other.Memo) return false;
      if (MaxAutomaticTokenAssociations != other.MaxAutomaticTokenAssociations) return false;
      if (!object.Equals(AutoRenewAccountId, other.AutoRenewAccountId)) return false;
      if (!object.Equals(StakedAccountId, other.StakedAccountId)) return false;
      if (StakedNodeId != other.StakedNodeId) return false;
      if (DeclineReward != other.DeclineReward) return false;
      if(!hookCreationDetails_.Equals(other.hookCreationDetails_)) return false;
      if (InitcodeSourceCase != other.InitcodeSourceCase) return false;
      if (StakedIdCase != other.StakedIdCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (initcodeSourceCase_ == InitcodeSourceOneofCase.FileID) hash ^= FileID.GetHashCode();
      if (HasInitcode) hash ^= Initcode.GetHashCode();
      if (adminKey_ != null) hash ^= AdminKey.GetHashCode();
      if (Gas != 0L) hash ^= Gas.GetHashCode();
      if (InitialBalance != 0L) hash ^= InitialBalance.GetHashCode();
      if (proxyAccountID_ != null) hash ^= ProxyAccountID.GetHashCode();
      if (autoRenewPeriod_ != null) hash ^= AutoRenewPeriod.GetHashCode();
      if (ConstructorParameters.Length != 0) hash ^= ConstructorParameters.GetHashCode();
      if (shardID_ != null) hash ^= ShardID.GetHashCode();
      if (realmID_ != null) hash ^= RealmID.GetHashCode();
      if (newRealmAdminKey_ != null) hash ^= NewRealmAdminKey.GetHashCode();
      if (Memo.Length != 0) hash ^= Memo.GetHashCode();
      if (MaxAutomaticTokenAssociations != 0) hash ^= MaxAutomaticTokenAssociations.GetHashCode();
      if (autoRenewAccountId_ != null) hash ^= AutoRenewAccountId.GetHashCode();
      if (stakedIdCase_ == StakedIdOneofCase.StakedAccountId) hash ^= StakedAccountId.GetHashCode();
      if (HasStakedNodeId) hash ^= StakedNodeId.GetHashCode();
      if (DeclineReward != false) hash ^= DeclineReward.GetHashCode();
      hash ^= hookCreationDetails_.GetHashCode();
      hash ^= (int) initcodeSourceCase_;
      hash ^= (int) stakedIdCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (initcodeSourceCase_ == InitcodeSourceOneofCase.FileID) {
        output.WriteRawTag(10);
        output.WriteMessage(FileID);
      }
      if (adminKey_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(AdminKey);
      }
      if (Gas != 0L) {
        output.WriteRawTag(32);
        output.WriteInt64(Gas);
      }
      if (InitialBalance != 0L) {
        output.WriteRawTag(40);
        output.WriteInt64(InitialBalance);
      }
      if (proxyAccountID_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(ProxyAccountID);
      }
      if (autoRenewPeriod_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(AutoRenewPeriod);
      }
      if (ConstructorParameters.Length != 0) {
        output.WriteRawTag(74);
        output.WriteBytes(ConstructorParameters);
      }
      if (shardID_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(ShardID);
      }
      if (realmID_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(RealmID);
      }
      if (newRealmAdminKey_ != null) {
        output.WriteRawTag(98);
        output.WriteMessage(NewRealmAdminKey);
      }
      if (Memo.Length != 0) {
        output.WriteRawTag(106);
        output.WriteString(Memo);
      }
      if (MaxAutomaticTokenAssociations != 0) {
        output.WriteRawTag(112);
        output.WriteInt32(MaxAutomaticTokenAssociations);
      }
      if (autoRenewAccountId_ != null) {
        output.WriteRawTag(122);
        output.WriteMessage(AutoRenewAccountId);
      }
      if (HasInitcode) {
        output.WriteRawTag(130, 1);
        output.WriteBytes(Initcode);
      }
      if (stakedIdCase_ == StakedIdOneofCase.StakedAccountId) {
        output.WriteRawTag(138, 1);
        output.WriteMessage(StakedAccountId);
      }
      if (HasStakedNodeId) {
        output.WriteRawTag(144, 1);
        output.WriteInt64(StakedNodeId);
      }
      if (DeclineReward != false) {
        output.WriteRawTag(152, 1);
        output.WriteBool(DeclineReward);
      }
      hookCreationDetails_.WriteTo(output, _repeated_hookCreationDetails_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (initcodeSourceCase_ == InitcodeSourceOneofCase.FileID) {
        output.WriteRawTag(10);
        output.WriteMessage(FileID);
      }
      if (adminKey_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(AdminKey);
      }
      if (Gas != 0L) {
        output.WriteRawTag(32);
        output.WriteInt64(Gas);
      }
      if (InitialBalance != 0L) {
        output.WriteRawTag(40);
        output.WriteInt64(InitialBalance);
      }
      if (proxyAccountID_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(ProxyAccountID);
      }
      if (autoRenewPeriod_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(AutoRenewPeriod);
      }
      if (ConstructorParameters.Length != 0) {
        output.WriteRawTag(74);
        output.WriteBytes(ConstructorParameters);
      }
      if (shardID_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(ShardID);
      }
      if (realmID_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(RealmID);
      }
      if (newRealmAdminKey_ != null) {
        output.WriteRawTag(98);
        output.WriteMessage(NewRealmAdminKey);
      }
      if (Memo.Length != 0) {
        output.WriteRawTag(106);
        output.WriteString(Memo);
      }
      if (MaxAutomaticTokenAssociations != 0) {
        output.WriteRawTag(112);
        output.WriteInt32(MaxAutomaticTokenAssociations);
      }
      if (autoRenewAccountId_ != null) {
        output.WriteRawTag(122);
        output.WriteMessage(AutoRenewAccountId);
      }
      if (HasInitcode) {
        output.WriteRawTag(130, 1);
        output.WriteBytes(Initcode);
      }
      if (stakedIdCase_ == StakedIdOneofCase.StakedAccountId) {
        output.WriteRawTag(138, 1);
        output.WriteMessage(StakedAccountId);
      }
      if (HasStakedNodeId) {
        output.WriteRawTag(144, 1);
        output.WriteInt64(StakedNodeId);
      }
      if (DeclineReward != false) {
        output.WriteRawTag(152, 1);
        output.WriteBool(DeclineReward);
      }
      hookCreationDetails_.WriteTo(ref output, _repeated_hookCreationDetails_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (initcodeSourceCase_ == InitcodeSourceOneofCase.FileID) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(FileID);
      }
      if (HasInitcode) {
        size += 2 + pb::CodedOutputStream.ComputeBytesSize(Initcode);
      }
      if (adminKey_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(AdminKey);
      }
      if (Gas != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(Gas);
      }
      if (InitialBalance != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(InitialBalance);
      }
      if (proxyAccountID_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ProxyAccountID);
      }
      if (autoRenewPeriod_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(AutoRenewPeriod);
      }
      if (ConstructorParameters.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(ConstructorParameters);
      }
      if (shardID_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ShardID);
      }
      if (realmID_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RealmID);
      }
      if (newRealmAdminKey_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(NewRealmAdminKey);
      }
      if (Memo.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Memo);
      }
      if (MaxAutomaticTokenAssociations != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(MaxAutomaticTokenAssociations);
      }
      if (autoRenewAccountId_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(AutoRenewAccountId);
      }
      if (stakedIdCase_ == StakedIdOneofCase.StakedAccountId) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(StakedAccountId);
      }
      if (HasStakedNodeId) {
        size += 2 + pb::CodedOutputStream.ComputeInt64Size(StakedNodeId);
      }
      if (DeclineReward != false) {
        size += 2 + 1;
      }
      size += hookCreationDetails_.CalculateSize(_repeated_hookCreationDetails_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ContractCreateTransactionBody other) {
      if (other == null) {
        return;
      }
      if (other.adminKey_ != null) {
        if (adminKey_ == null) {
          AdminKey = new global::Hedera.Hashgraph.Proto.Key();
        }
        AdminKey.MergeFrom(other.AdminKey);
      }
      if (other.Gas != 0L) {
        Gas = other.Gas;
      }
      if (other.InitialBalance != 0L) {
        InitialBalance = other.InitialBalance;
      }
      if (other.proxyAccountID_ != null) {
        if (proxyAccountID_ == null) {
          ProxyAccountID = new global::Hedera.Hashgraph.Proto.AccountID();
        }
        ProxyAccountID.MergeFrom(other.ProxyAccountID);
      }
      if (other.autoRenewPeriod_ != null) {
        if (autoRenewPeriod_ == null) {
          AutoRenewPeriod = new global::Hedera.Hashgraph.Proto.Duration();
        }
        AutoRenewPeriod.MergeFrom(other.AutoRenewPeriod);
      }
      if (other.ConstructorParameters.Length != 0) {
        ConstructorParameters = other.ConstructorParameters;
      }
      if (other.shardID_ != null) {
        if (shardID_ == null) {
          ShardID = new global::Hedera.Hashgraph.Proto.ShardID();
        }
        ShardID.MergeFrom(other.ShardID);
      }
      if (other.realmID_ != null) {
        if (realmID_ == null) {
          RealmID = new global::Hedera.Hashgraph.Proto.RealmID();
        }
        RealmID.MergeFrom(other.RealmID);
      }
      if (other.newRealmAdminKey_ != null) {
        if (newRealmAdminKey_ == null) {
          NewRealmAdminKey = new global::Hedera.Hashgraph.Proto.Key();
        }
        NewRealmAdminKey.MergeFrom(other.NewRealmAdminKey);
      }
      if (other.Memo.Length != 0) {
        Memo = other.Memo;
      }
      if (other.MaxAutomaticTokenAssociations != 0) {
        MaxAutomaticTokenAssociations = other.MaxAutomaticTokenAssociations;
      }
      if (other.autoRenewAccountId_ != null) {
        if (autoRenewAccountId_ == null) {
          AutoRenewAccountId = new global::Hedera.Hashgraph.Proto.AccountID();
        }
        AutoRenewAccountId.MergeFrom(other.AutoRenewAccountId);
      }
      if (other.DeclineReward != false) {
        DeclineReward = other.DeclineReward;
      }
      hookCreationDetails_.Add(other.hookCreationDetails_);
      switch (other.InitcodeSourceCase) {
        case InitcodeSourceOneofCase.FileID:
          if (FileID == null) {
            FileID = new global::Hedera.Hashgraph.Proto.FileID();
          }
          FileID.MergeFrom(other.FileID);
          break;
        case InitcodeSourceOneofCase.Initcode:
          Initcode = other.Initcode;
          break;
      }

      switch (other.StakedIdCase) {
        case StakedIdOneofCase.StakedAccountId:
          if (StakedAccountId == null) {
            StakedAccountId = new global::Hedera.Hashgraph.Proto.AccountID();
          }
          StakedAccountId.MergeFrom(other.StakedAccountId);
          break;
        case StakedIdOneofCase.StakedNodeId:
          StakedNodeId = other.StakedNodeId;
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            global::Hedera.Hashgraph.Proto.FileID subBuilder = new global::Hedera.Hashgraph.Proto.FileID();
            if (initcodeSourceCase_ == InitcodeSourceOneofCase.FileID) {
              subBuilder.MergeFrom(FileID);
            }
            input.ReadMessage(subBuilder);
            FileID = subBuilder;
            break;
          }
          case 26: {
            if (adminKey_ == null) {
              AdminKey = new global::Hedera.Hashgraph.Proto.Key();
            }
            input.ReadMessage(AdminKey);
            break;
          }
          case 32: {
            Gas = input.ReadInt64();
            break;
          }
          case 40: {
            InitialBalance = input.ReadInt64();
            break;
          }
          case 50: {
            if (proxyAccountID_ == null) {
              ProxyAccountID = new global::Hedera.Hashgraph.Proto.AccountID();
            }
            input.ReadMessage(ProxyAccountID);
            break;
          }
          case 66: {
            if (autoRenewPeriod_ == null) {
              AutoRenewPeriod = new global::Hedera.Hashgraph.Proto.Duration();
            }
            input.ReadMessage(AutoRenewPeriod);
            break;
          }
          case 74: {
            ConstructorParameters = input.ReadBytes();
            break;
          }
          case 82: {
            if (shardID_ == null) {
              ShardID = new global::Hedera.Hashgraph.Proto.ShardID();
            }
            input.ReadMessage(ShardID);
            break;
          }
          case 90: {
            if (realmID_ == null) {
              RealmID = new global::Hedera.Hashgraph.Proto.RealmID();
            }
            input.ReadMessage(RealmID);
            break;
          }
          case 98: {
            if (newRealmAdminKey_ == null) {
              NewRealmAdminKey = new global::Hedera.Hashgraph.Proto.Key();
            }
            input.ReadMessage(NewRealmAdminKey);
            break;
          }
          case 106: {
            Memo = input.ReadString();
            break;
          }
          case 112: {
            MaxAutomaticTokenAssociations = input.ReadInt32();
            break;
          }
          case 122: {
            if (autoRenewAccountId_ == null) {
              AutoRenewAccountId = new global::Hedera.Hashgraph.Proto.AccountID();
            }
            input.ReadMessage(AutoRenewAccountId);
            break;
          }
          case 130: {
            Initcode = input.ReadBytes();
            break;
          }
          case 138: {
            global::Hedera.Hashgraph.Proto.AccountID subBuilder = new global::Hedera.Hashgraph.Proto.AccountID();
            if (stakedIdCase_ == StakedIdOneofCase.StakedAccountId) {
              subBuilder.MergeFrom(StakedAccountId);
            }
            input.ReadMessage(subBuilder);
            StakedAccountId = subBuilder;
            break;
          }
          case 144: {
            StakedNodeId = input.ReadInt64();
            break;
          }
          case 152: {
            DeclineReward = input.ReadBool();
            break;
          }
          case 162: {
            hookCreationDetails_.AddEntriesFrom(input, _repeated_hookCreationDetails_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            global::Hedera.Hashgraph.Proto.FileID subBuilder = new global::Hedera.Hashgraph.Proto.FileID();
            if (initcodeSourceCase_ == InitcodeSourceOneofCase.FileID) {
              subBuilder.MergeFrom(FileID);
            }
            input.ReadMessage(subBuilder);
            FileID = subBuilder;
            break;
          }
          case 26: {
            if (adminKey_ == null) {
              AdminKey = new global::Hedera.Hashgraph.Proto.Key();
            }
            input.ReadMessage(AdminKey);
            break;
          }
          case 32: {
            Gas = input.ReadInt64();
            break;
          }
          case 40: {
            InitialBalance = input.ReadInt64();
            break;
          }
          case 50: {
            if (proxyAccountID_ == null) {
              ProxyAccountID = new global::Hedera.Hashgraph.Proto.AccountID();
            }
            input.ReadMessage(ProxyAccountID);
            break;
          }
          case 66: {
            if (autoRenewPeriod_ == null) {
              AutoRenewPeriod = new global::Hedera.Hashgraph.Proto.Duration();
            }
            input.ReadMessage(AutoRenewPeriod);
            break;
          }
          case 74: {
            ConstructorParameters = input.ReadBytes();
            break;
          }
          case 82: {
            if (shardID_ == null) {
              ShardID = new global::Hedera.Hashgraph.Proto.ShardID();
            }
            input.ReadMessage(ShardID);
            break;
          }
          case 90: {
            if (realmID_ == null) {
              RealmID = new global::Hedera.Hashgraph.Proto.RealmID();
            }
            input.ReadMessage(RealmID);
            break;
          }
          case 98: {
            if (newRealmAdminKey_ == null) {
              NewRealmAdminKey = new global::Hedera.Hashgraph.Proto.Key();
            }
            input.ReadMessage(NewRealmAdminKey);
            break;
          }
          case 106: {
            Memo = input.ReadString();
            break;
          }
          case 112: {
            MaxAutomaticTokenAssociations = input.ReadInt32();
            break;
          }
          case 122: {
            if (autoRenewAccountId_ == null) {
              AutoRenewAccountId = new global::Hedera.Hashgraph.Proto.AccountID();
            }
            input.ReadMessage(AutoRenewAccountId);
            break;
          }
          case 130: {
            Initcode = input.ReadBytes();
            break;
          }
          case 138: {
            global::Hedera.Hashgraph.Proto.AccountID subBuilder = new global::Hedera.Hashgraph.Proto.AccountID();
            if (stakedIdCase_ == StakedIdOneofCase.StakedAccountId) {
              subBuilder.MergeFrom(StakedAccountId);
            }
            input.ReadMessage(subBuilder);
            StakedAccountId = subBuilder;
            break;
          }
          case 144: {
            StakedNodeId = input.ReadInt64();
            break;
          }
          case 152: {
            DeclineReward = input.ReadBool();
            break;
          }
          case 162: {
            hookCreationDetails_.AddEntriesFrom(ref input, _repeated_hookCreationDetails_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  #endregion

}

#endregion Designer generated code
