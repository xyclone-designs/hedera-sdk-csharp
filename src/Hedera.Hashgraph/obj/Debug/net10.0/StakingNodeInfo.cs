// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: staking_node_info.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021, 8981
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Proto {

  /// <summary>Holder for reflection information generated from staking_node_info.proto</summary>
  public static partial class StakingNodeInfoReflection {

    #region Descriptor
    /// <summary>File descriptor for staking_node_info.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static StakingNodeInfoReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "ChdzdGFraW5nX25vZGVfaW5mby5wcm90bxIFcHJvdG8irQIKD1N0YWtpbmdO",
            "b2RlSW5mbxITCgtub2RlX251bWJlchgBIAEoAxIRCgltaW5fc3Rha2UYAiAB",
            "KAMSEQoJbWF4X3N0YWtlGAMgASgDEhcKD3N0YWtlX3RvX3Jld2FyZBgEIAEo",
            "AxIbChNzdGFrZV90b19ub3RfcmV3YXJkGAUgASgDEhoKEnN0YWtlX3Jld2Fy",
            "ZF9zdGFydBgGIAEoAxIkChx1bmNsYWltZWRfc3Rha2VfcmV3YXJkX3N0YXJ0",
            "GAcgASgDEg0KBXN0YWtlGAggASgDEhoKEnJld2FyZF9zdW1faGlzdG9yeRgJ",
            "IAMoAxISCgZ3ZWlnaHQYCiABKAVCAhgBEhcKD3BlbmRpbmdfcmV3YXJkcxgL",
            "IAEoAxIPCgdkZWxldGVkGAwgASgIQiIKHmNvbS5oZWRlcmEuaGFzaGdyYXBo",
            "LnNkay5wcm90b1ABYgZwcm90bzM="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Proto.StakingNodeInfo), global::Proto.StakingNodeInfo.Parser, new[]{ "NodeNumber", "MinStake", "MaxStake", "StakeToReward", "StakeToNotReward", "StakeRewardStart", "UnclaimedStakeRewardStart", "Stake", "RewardSumHistory", "Weight", "PendingRewards", "Deleted" }, null, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  ///*
  /// An Hedera Token Service staking info entity.
  ///
  /// Staking info is per node. Shard and Realm are implied based on the network
  /// address book entry for this node.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class StakingNodeInfo : pb::IMessage<StakingNodeInfo>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<StakingNodeInfo> _parser = new pb::MessageParser<StakingNodeInfo>(() => new StakingNodeInfo());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<StakingNodeInfo> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Proto.StakingNodeInfoReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public StakingNodeInfo() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public StakingNodeInfo(StakingNodeInfo other) : this() {
      nodeNumber_ = other.nodeNumber_;
      minStake_ = other.minStake_;
      maxStake_ = other.maxStake_;
      stakeToReward_ = other.stakeToReward_;
      stakeToNotReward_ = other.stakeToNotReward_;
      stakeRewardStart_ = other.stakeRewardStart_;
      unclaimedStakeRewardStart_ = other.unclaimedStakeRewardStart_;
      stake_ = other.stake_;
      rewardSumHistory_ = other.rewardSumHistory_.Clone();
      weight_ = other.weight_;
      pendingRewards_ = other.pendingRewards_;
      deleted_ = other.deleted_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public StakingNodeInfo Clone() {
      return new StakingNodeInfo(this);
    }

    /// <summary>Field number for the "node_number" field.</summary>
    public const int NodeNumberFieldNumber = 1;
    private long nodeNumber_;
    /// <summary>
    ///*
    /// The entity number of this node.&lt;br/>
    /// The shard and realm numbers are implied, based on the network address
    /// book entry for this node.
    /// &lt;p>
    /// This value SHALL be unique within a given shard and realm.&lt;br/>
    /// This value MAY be repeated across shards and/or realms.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long NodeNumber {
      get { return nodeNumber_; }
      set {
        nodeNumber_ = value;
      }
    }

    /// <summary>Field number for the "min_stake" field.</summary>
    public const int MinStakeFieldNumber = 2;
    private long minStake_;
    /// <summary>
    ///*
    /// The minimum stake, in tinybar, that is required for this node to have a
    /// non-zero weight in the network consensus.
    /// &lt;p>
    /// If the current value of `stake` is below this value, this node SHALL have
    /// a zero weight in network consensus.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long MinStake {
      get { return minStake_; }
      set {
        minStake_ = value;
      }
    }

    /// <summary>Field number for the "max_stake" field.</summary>
    public const int MaxStakeFieldNumber = 3;
    private long maxStake_;
    /// <summary>
    ///*
    /// The maximum stake to this node that is considered to calculate its weight
    /// in the network consensus.
    /// &lt;p>
    /// If the current `stake` value is above this limit, the excess staked HBAR
    /// SHALL NOT be considered when determining consensus weight.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long MaxStake {
      get { return maxStake_; }
      set {
        maxStake_ = value;
      }
    }

    /// <summary>Field number for the "stake_to_reward" field.</summary>
    public const int StakeToRewardFieldNumber = 4;
    private long stakeToReward_;
    /// <summary>
    ///*
    /// The sum of balances of all accounts staked to this node, considering only
    /// accounts that choose to receive rewards.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long StakeToReward {
      get { return stakeToReward_; }
      set {
        stakeToReward_ = value;
      }
    }

    /// <summary>Field number for the "stake_to_not_reward" field.</summary>
    public const int StakeToNotRewardFieldNumber = 5;
    private long stakeToNotReward_;
    /// <summary>
    ///*
    /// The sum of balances of all accounts staked to this node, considering only
    /// accounts that decline to receive rewards.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long StakeToNotReward {
      get { return stakeToNotReward_; }
      set {
        stakeToNotReward_ = value;
      }
    }

    /// <summary>Field number for the "stake_reward_start" field.</summary>
    public const int StakeRewardStartFieldNumber = 6;
    private long stakeRewardStart_;
    /// <summary>
    ///*
    /// The snapshot of stake_to_reward value at the beginning of the current
    /// staking period.
    /// &lt;p>
    /// This is necessary when calculating rewards for the current staking period
    /// without considering changes to `stake_to_reward` _within_ the current
    /// staking period.&lt;br/>
    /// This value SHALL be reset at the beginning of every staking period.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long StakeRewardStart {
      get { return stakeRewardStart_; }
      set {
        stakeRewardStart_ = value;
      }
    }

    /// <summary>Field number for the "unclaimed_stake_reward_start" field.</summary>
    public const int UnclaimedStakeRewardStartFieldNumber = 7;
    private long unclaimedStakeRewardStart_;
    /// <summary>
    ///*
    /// The amount of staked HBAR from `stake_reward_start` that will have
    /// unclaimed rewards due to accounts changing their staking metadata in a
    /// way that disqualifies them for the current staking period.
    /// &lt;p>
    /// This value SHALL be reset at the beginning of every staking period.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long UnclaimedStakeRewardStart {
      get { return unclaimedStakeRewardStart_; }
      set {
        unclaimedStakeRewardStart_ = value;
      }
    }

    /// <summary>Field number for the "stake" field.</summary>
    public const int StakeFieldNumber = 8;
    private long stake_;
    /// <summary>
    ///*
    /// The total amount of HBAR staked to this node.
    /// &lt;p>
    /// This is sum of stake_to_reward and stake_to_not_reward.&lt;br/>
    /// If the sum is greater than `max_stake`, then the _effective_ stake
    /// SHALL be `max_stake`.&lt;br/>
    /// If the sum is less than `min_stake`, then the _effective_ stake
    /// SHALL be `0`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long Stake {
      get { return stake_; }
      set {
        stake_ = value;
      }
    }

    /// <summary>Field number for the "reward_sum_history" field.</summary>
    public const int RewardSumHistoryFieldNumber = 9;
    private static readonly pb::FieldCodec<long> _repeated_rewardSumHistory_codec
        = pb::FieldCodec.ForInt64(74);
    private readonly pbc::RepeatedField<long> rewardSumHistory_ = new pbc::RepeatedField<long>();
    /// <summary>
    ///*
    /// A running list of reward amounts for the last 365+1 staking periods
    /// (typically a year and a day).
    /// &lt;p>
    /// The first element SHALL be the reward up to and including the last full
    /// period prior to the present reward period.&lt;br/>
    /// The second element SHALL be the reward up to and including the period
    /// before the last full period prior to the present period.&lt;br/>
    /// The list SHALL continue in reverse chronological order until the reward
    /// history limit is reached.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<long> RewardSumHistory {
      get { return rewardSumHistory_; }
    }

    /// <summary>Field number for the "weight" field.</summary>
    public const int WeightFieldNumber = 10;
    private int weight_;
    /// <summary>
    ///*
    /// The consensus weight of this node in the network.
    /// &lt;p>
    /// This is recomputed based on the `stake` of this node at midnight UTC of
    /// each day. If the `stake` of this node at that time is less than
    /// `min_stake`, then the weight SHALL be 0.&lt;br/>
    /// &lt;p>
    /// Given the following:
    /// &lt;ul>
    ///   &lt;li>The `effective stake` of a single node SHALL be `0` if the node
    ///       `stake` is less than `min_stake`.&lt;/li>
    ///   &lt;li>The `effective stake` SHALL be `max_stake` if the node `stake` is
    ///       greater than `max_stake`.&lt;/li>
    ///   &lt;li>The `effective stake` SHALL be the actual value of `stake` if
    ///       `min_stake` &lt; `stake` &lt; `max_stake`.&lt;/li>
    ///   &lt;li>The `effective network stake` SHALL be calculated as âˆ‘(`effective
    ///       stake` of each node) for all nodes in the network address book.&lt;/li>
    /// &lt;/ul>
    /// &lt;p>
    /// This field is deprecated and SHALL NOT be used when RosterLifecycle
    /// is enabled. The weight SHALL be same as the `effective_stake` described above.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int Weight {
      get { return weight_; }
      set {
        weight_ = value;
      }
    }

    /// <summary>Field number for the "pending_rewards" field.</summary>
    public const int PendingRewardsFieldNumber = 11;
    private long pendingRewards_;
    /// <summary>
    ///*
    /// The total staking rewards in tinybars that MAY be collected by all
    /// accounts staking to the current node after the end of this staking
    /// period.
    /// &lt;p>
    /// This SHALL be calculated assuming that no account "renounces" its
    /// rewards by setting `decline_reward` to true, or is ineligible for
    /// some other reason.&lt;br/>
    /// When the current node is deleted, this amount SHALL be subtracted from
    /// the total pending rewards of all accounts staking to all nodes in the
    /// network in NetworkStakingRewards.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long PendingRewards {
      get { return pendingRewards_; }
      set {
        pendingRewards_ = value;
      }
    }

    /// <summary>Field number for the "deleted" field.</summary>
    public const int DeletedFieldNumber = 12;
    private bool deleted_;
    /// <summary>
    ///*
    /// A flag indicating that this node has been removed from this network.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Deleted {
      get { return deleted_; }
      set {
        deleted_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as StakingNodeInfo);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(StakingNodeInfo other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (NodeNumber != other.NodeNumber) return false;
      if (MinStake != other.MinStake) return false;
      if (MaxStake != other.MaxStake) return false;
      if (StakeToReward != other.StakeToReward) return false;
      if (StakeToNotReward != other.StakeToNotReward) return false;
      if (StakeRewardStart != other.StakeRewardStart) return false;
      if (UnclaimedStakeRewardStart != other.UnclaimedStakeRewardStart) return false;
      if (Stake != other.Stake) return false;
      if(!rewardSumHistory_.Equals(other.rewardSumHistory_)) return false;
      if (Weight != other.Weight) return false;
      if (PendingRewards != other.PendingRewards) return false;
      if (Deleted != other.Deleted) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (NodeNumber != 0L) hash ^= NodeNumber.GetHashCode();
      if (MinStake != 0L) hash ^= MinStake.GetHashCode();
      if (MaxStake != 0L) hash ^= MaxStake.GetHashCode();
      if (StakeToReward != 0L) hash ^= StakeToReward.GetHashCode();
      if (StakeToNotReward != 0L) hash ^= StakeToNotReward.GetHashCode();
      if (StakeRewardStart != 0L) hash ^= StakeRewardStart.GetHashCode();
      if (UnclaimedStakeRewardStart != 0L) hash ^= UnclaimedStakeRewardStart.GetHashCode();
      if (Stake != 0L) hash ^= Stake.GetHashCode();
      hash ^= rewardSumHistory_.GetHashCode();
      if (Weight != 0) hash ^= Weight.GetHashCode();
      if (PendingRewards != 0L) hash ^= PendingRewards.GetHashCode();
      if (Deleted != false) hash ^= Deleted.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (NodeNumber != 0L) {
        output.WriteRawTag(8);
        output.WriteInt64(NodeNumber);
      }
      if (MinStake != 0L) {
        output.WriteRawTag(16);
        output.WriteInt64(MinStake);
      }
      if (MaxStake != 0L) {
        output.WriteRawTag(24);
        output.WriteInt64(MaxStake);
      }
      if (StakeToReward != 0L) {
        output.WriteRawTag(32);
        output.WriteInt64(StakeToReward);
      }
      if (StakeToNotReward != 0L) {
        output.WriteRawTag(40);
        output.WriteInt64(StakeToNotReward);
      }
      if (StakeRewardStart != 0L) {
        output.WriteRawTag(48);
        output.WriteInt64(StakeRewardStart);
      }
      if (UnclaimedStakeRewardStart != 0L) {
        output.WriteRawTag(56);
        output.WriteInt64(UnclaimedStakeRewardStart);
      }
      if (Stake != 0L) {
        output.WriteRawTag(64);
        output.WriteInt64(Stake);
      }
      rewardSumHistory_.WriteTo(output, _repeated_rewardSumHistory_codec);
      if (Weight != 0) {
        output.WriteRawTag(80);
        output.WriteInt32(Weight);
      }
      if (PendingRewards != 0L) {
        output.WriteRawTag(88);
        output.WriteInt64(PendingRewards);
      }
      if (Deleted != false) {
        output.WriteRawTag(96);
        output.WriteBool(Deleted);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (NodeNumber != 0L) {
        output.WriteRawTag(8);
        output.WriteInt64(NodeNumber);
      }
      if (MinStake != 0L) {
        output.WriteRawTag(16);
        output.WriteInt64(MinStake);
      }
      if (MaxStake != 0L) {
        output.WriteRawTag(24);
        output.WriteInt64(MaxStake);
      }
      if (StakeToReward != 0L) {
        output.WriteRawTag(32);
        output.WriteInt64(StakeToReward);
      }
      if (StakeToNotReward != 0L) {
        output.WriteRawTag(40);
        output.WriteInt64(StakeToNotReward);
      }
      if (StakeRewardStart != 0L) {
        output.WriteRawTag(48);
        output.WriteInt64(StakeRewardStart);
      }
      if (UnclaimedStakeRewardStart != 0L) {
        output.WriteRawTag(56);
        output.WriteInt64(UnclaimedStakeRewardStart);
      }
      if (Stake != 0L) {
        output.WriteRawTag(64);
        output.WriteInt64(Stake);
      }
      rewardSumHistory_.WriteTo(ref output, _repeated_rewardSumHistory_codec);
      if (Weight != 0) {
        output.WriteRawTag(80);
        output.WriteInt32(Weight);
      }
      if (PendingRewards != 0L) {
        output.WriteRawTag(88);
        output.WriteInt64(PendingRewards);
      }
      if (Deleted != false) {
        output.WriteRawTag(96);
        output.WriteBool(Deleted);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (NodeNumber != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(NodeNumber);
      }
      if (MinStake != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(MinStake);
      }
      if (MaxStake != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(MaxStake);
      }
      if (StakeToReward != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(StakeToReward);
      }
      if (StakeToNotReward != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(StakeToNotReward);
      }
      if (StakeRewardStart != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(StakeRewardStart);
      }
      if (UnclaimedStakeRewardStart != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(UnclaimedStakeRewardStart);
      }
      if (Stake != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(Stake);
      }
      size += rewardSumHistory_.CalculateSize(_repeated_rewardSumHistory_codec);
      if (Weight != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(Weight);
      }
      if (PendingRewards != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(PendingRewards);
      }
      if (Deleted != false) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(StakingNodeInfo other) {
      if (other == null) {
        return;
      }
      if (other.NodeNumber != 0L) {
        NodeNumber = other.NodeNumber;
      }
      if (other.MinStake != 0L) {
        MinStake = other.MinStake;
      }
      if (other.MaxStake != 0L) {
        MaxStake = other.MaxStake;
      }
      if (other.StakeToReward != 0L) {
        StakeToReward = other.StakeToReward;
      }
      if (other.StakeToNotReward != 0L) {
        StakeToNotReward = other.StakeToNotReward;
      }
      if (other.StakeRewardStart != 0L) {
        StakeRewardStart = other.StakeRewardStart;
      }
      if (other.UnclaimedStakeRewardStart != 0L) {
        UnclaimedStakeRewardStart = other.UnclaimedStakeRewardStart;
      }
      if (other.Stake != 0L) {
        Stake = other.Stake;
      }
      rewardSumHistory_.Add(other.rewardSumHistory_);
      if (other.Weight != 0) {
        Weight = other.Weight;
      }
      if (other.PendingRewards != 0L) {
        PendingRewards = other.PendingRewards;
      }
      if (other.Deleted != false) {
        Deleted = other.Deleted;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            NodeNumber = input.ReadInt64();
            break;
          }
          case 16: {
            MinStake = input.ReadInt64();
            break;
          }
          case 24: {
            MaxStake = input.ReadInt64();
            break;
          }
          case 32: {
            StakeToReward = input.ReadInt64();
            break;
          }
          case 40: {
            StakeToNotReward = input.ReadInt64();
            break;
          }
          case 48: {
            StakeRewardStart = input.ReadInt64();
            break;
          }
          case 56: {
            UnclaimedStakeRewardStart = input.ReadInt64();
            break;
          }
          case 64: {
            Stake = input.ReadInt64();
            break;
          }
          case 74:
          case 72: {
            rewardSumHistory_.AddEntriesFrom(input, _repeated_rewardSumHistory_codec);
            break;
          }
          case 80: {
            Weight = input.ReadInt32();
            break;
          }
          case 88: {
            PendingRewards = input.ReadInt64();
            break;
          }
          case 96: {
            Deleted = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            NodeNumber = input.ReadInt64();
            break;
          }
          case 16: {
            MinStake = input.ReadInt64();
            break;
          }
          case 24: {
            MaxStake = input.ReadInt64();
            break;
          }
          case 32: {
            StakeToReward = input.ReadInt64();
            break;
          }
          case 40: {
            StakeToNotReward = input.ReadInt64();
            break;
          }
          case 48: {
            StakeRewardStart = input.ReadInt64();
            break;
          }
          case 56: {
            UnclaimedStakeRewardStart = input.ReadInt64();
            break;
          }
          case 64: {
            Stake = input.ReadInt64();
            break;
          }
          case 74:
          case 72: {
            rewardSumHistory_.AddEntriesFrom(ref input, _repeated_rewardSumHistory_codec);
            break;
          }
          case 80: {
            Weight = input.ReadInt32();
            break;
          }
          case 88: {
            PendingRewards = input.ReadInt64();
            break;
          }
          case 96: {
            Deleted = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

  }

  #endregion

}

#endregion Designer generated code
