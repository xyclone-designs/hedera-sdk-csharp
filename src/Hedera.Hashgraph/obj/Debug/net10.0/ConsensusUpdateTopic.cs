// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: consensus_update_topic.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021, 8981
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Proto {

  /// <summary>Holder for reflection information generated from consensus_update_topic.proto</summary>
  public static partial class ConsensusUpdateTopicReflection {

    #region Descriptor
    /// <summary>File descriptor for consensus_update_topic.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static ConsensusUpdateTopicReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "Chxjb25zZW5zdXNfdXBkYXRlX3RvcGljLnByb3RvEgVwcm90bxoeZ29vZ2xl",
            "L3Byb3RvYnVmL3dyYXBwZXJzLnByb3RvGhFiYXNpY190eXBlcy5wcm90bxoR",
            "Y3VzdG9tX2ZlZXMucHJvdG8aDmR1cmF0aW9uLnByb3RvGg90aW1lc3RhbXAu",
            "cHJvdG8iuwMKI0NvbnNlbnN1c1VwZGF0ZVRvcGljVHJhbnNhY3Rpb25Cb2R5",
            "Eh8KB3RvcGljSUQYASABKAsyDi5wcm90by5Ub3BpY0lEEioKBG1lbW8YAiAB",
            "KAsyHC5nb29nbGUucHJvdG9idWYuU3RyaW5nVmFsdWUSKAoOZXhwaXJhdGlv",
            "blRpbWUYBCABKAsyEC5wcm90by5UaW1lc3RhbXASHAoIYWRtaW5LZXkYBiAB",
            "KAsyCi5wcm90by5LZXkSHQoJc3VibWl0S2V5GAcgASgLMgoucHJvdG8uS2V5",
            "EigKD2F1dG9SZW5ld1BlcmlvZBgIIAEoCzIPLnByb3RvLkR1cmF0aW9uEioK",
            "EGF1dG9SZW5ld0FjY291bnQYCSABKAsyEC5wcm90by5BY2NvdW50SUQSJAoQ",
            "ZmVlX3NjaGVkdWxlX2tleRgKIAEoCzIKLnByb3RvLktleRI0ChNmZWVfZXhl",
            "bXB0X2tleV9saXN0GAsgASgLMhcucHJvdG8uRmVlRXhlbXB0S2V5TGlzdBIu",
            "CgtjdXN0b21fZmVlcxgMIAEoCzIZLnByb3RvLkZpeGVkQ3VzdG9tRmVlTGlz",
            "dEIiCh5jb20uaGVkZXJhLmhhc2hncmFwaC5zZGsucHJvdG9QAWIGcHJvdG8z"));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Google.Protobuf.WellKnownTypes.WrappersReflection.Descriptor, global::Proto.BasicTypesReflection.Descriptor, global::Proto.CustomFeesReflection.Descriptor, global::Proto.DurationReflection.Descriptor, global::Proto.TimestampReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Proto.ConsensusUpdateTopicTransactionBody), global::Proto.ConsensusUpdateTopicTransactionBody.Parser, new[]{ "TopicID", "Memo", "ExpirationTime", "AdminKey", "SubmitKey", "AutoRenewPeriod", "AutoRenewAccount", "FeeScheduleKey", "FeeExemptKeyList", "CustomFees" }, null, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  ///*
  /// Update the fields of an existing HCS topic.
  ///
  /// The topicID field is REQUIRED. All other fields are OPTIONAL.&lt;br/>
  /// Fields set on this transaction SHALL be updated.&lt;br/>
  /// Fields _not_ set on this transaction SHALL NOT be updated.
  ///
  /// ### Block Stream Effects
  /// None
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class ConsensusUpdateTopicTransactionBody : pb::IMessage<ConsensusUpdateTopicTransactionBody>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ConsensusUpdateTopicTransactionBody> _parser = new pb::MessageParser<ConsensusUpdateTopicTransactionBody>(() => new ConsensusUpdateTopicTransactionBody());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ConsensusUpdateTopicTransactionBody> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Proto.ConsensusUpdateTopicReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ConsensusUpdateTopicTransactionBody() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ConsensusUpdateTopicTransactionBody(ConsensusUpdateTopicTransactionBody other) : this() {
      topicID_ = other.topicID_ != null ? other.topicID_.Clone() : null;
      Memo = other.Memo;
      expirationTime_ = other.expirationTime_ != null ? other.expirationTime_.Clone() : null;
      adminKey_ = other.adminKey_ != null ? other.adminKey_.Clone() : null;
      submitKey_ = other.submitKey_ != null ? other.submitKey_.Clone() : null;
      autoRenewPeriod_ = other.autoRenewPeriod_ != null ? other.autoRenewPeriod_.Clone() : null;
      autoRenewAccount_ = other.autoRenewAccount_ != null ? other.autoRenewAccount_.Clone() : null;
      feeScheduleKey_ = other.feeScheduleKey_ != null ? other.feeScheduleKey_.Clone() : null;
      feeExemptKeyList_ = other.feeExemptKeyList_ != null ? other.feeExemptKeyList_.Clone() : null;
      customFees_ = other.customFees_ != null ? other.customFees_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ConsensusUpdateTopicTransactionBody Clone() {
      return new ConsensusUpdateTopicTransactionBody(this);
    }

    /// <summary>Field number for the "topicID" field.</summary>
    public const int TopicIDFieldNumber = 1;
    private global::Proto.TopicID topicID_;
    /// <summary>
    ///*
    /// The topic ID specifying the topic to update.
    /// &lt;p>
    /// A topic with this ID MUST exist and MUST NOT be deleted.&lt;br/>
    /// This value is REQUIRED.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.TopicID TopicID {
      get { return topicID_; }
      set {
        topicID_ = value;
      }
    }

    /// <summary>Field number for the "memo" field.</summary>
    public const int MemoFieldNumber = 2;
    private static readonly pb::FieldCodec<string> _single_memo_codec = pb::FieldCodec.ForClassWrapper<string>(18);
    private string memo_;
    /// <summary>
    ///*
    /// An updated memo to be associated with this topic.
    /// &lt;p>
    /// If this value is set, the current `adminKey` for the topic MUST sign
    /// this transaction.&lt;br/>
    /// This value, if set, SHALL be encoded UTF-8 and SHALL NOT exceed
    /// 100 bytes when so encoded.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Memo {
      get { return memo_; }
      set {
        memo_ = value;
      }
    }


    /// <summary>Field number for the "expirationTime" field.</summary>
    public const int ExpirationTimeFieldNumber = 4;
    private global::Proto.Timestamp expirationTime_;
    /// <summary>
    ///*
    /// An updated expiration time for this topic, in seconds since the epoch.
    /// &lt;p>
    /// For this purpose, `epoch` SHALL be the UNIX epoch
    /// with 0 at `1970-01-01T00:00:00.000Z`.&lt;br/>
    /// The expirationTime MUST NOT be greater than the sum of
    /// `MAX_AUTORENEW_PERIOD` and the actual consensus timestamp of
    /// this transaction.&lt;br/>
    /// If `adminKey` is &lt;b>unset&lt;/b> for the _topic_, this transaction MUST NOT
    /// modify any other field.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.Timestamp ExpirationTime {
      get { return expirationTime_; }
      set {
        expirationTime_ = value;
      }
    }

    /// <summary>Field number for the "adminKey" field.</summary>
    public const int AdminKeyFieldNumber = 6;
    private global::Proto.Key adminKey_;
    /// <summary>
    ///*
    /// Updated access control for modification of the topic.
    /// &lt;p>
    /// If this field is set, that key and the previously set key MUST both
    /// sign this transaction.&lt;br/>
    /// If this value is an empty `KeyList`, the prior key MUST sign this
    /// transaction, and the topic SHALL be immutable after this transaction
    /// completes, except for expiration and renewal.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.Key AdminKey {
      get { return adminKey_; }
      set {
        adminKey_ = value;
      }
    }

    /// <summary>Field number for the "submitKey" field.</summary>
    public const int SubmitKeyFieldNumber = 7;
    private global::Proto.Key submitKey_;
    /// <summary>
    ///*
    /// Updated access control for message submission to the topic.
    /// &lt;p>
    /// If this value is set, the current `adminKey` for the topic MUST sign
    /// this transaction.&lt;br/>
    /// If this value is set to an empty `KeyList`, the `submitKey` for the
    /// topic will be unset after this transaction completes. When the
    /// `submitKey` is unset, any account may submit a message on the topic,
    /// without restriction.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.Key SubmitKey {
      get { return submitKey_; }
      set {
        submitKey_ = value;
      }
    }

    /// <summary>Field number for the "autoRenewPeriod" field.</summary>
    public const int AutoRenewPeriodFieldNumber = 8;
    private global::Proto.Duration autoRenewPeriod_;
    /// <summary>
    ///
    /// An updated value for the number of seconds by which the topic expiration
    /// will be automatically extended upon expiration, if it has a valid
    /// auto-renew account.
    /// &lt;p>
    /// If this value is set, the current `adminKey` for the topic MUST sign
    /// this transaction.&lt;br/>
    /// This value, if set, MUST be greater than the
    /// configured MIN_AUTORENEW_PERIOD.&lt;br/>
    /// This value, if set, MUST be less than the
    /// configured MAX_AUTORENEW_PERIOD.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.Duration AutoRenewPeriod {
      get { return autoRenewPeriod_; }
      set {
        autoRenewPeriod_ = value;
      }
    }

    /// <summary>Field number for the "autoRenewAccount" field.</summary>
    public const int AutoRenewAccountFieldNumber = 9;
    private global::Proto.AccountID autoRenewAccount_;
    /// <summary>
    ///*
    /// An updated ID for the account to be charged renewal fees at the topic's
    /// `expirationTime` to extend the lifetime of the topic.
    /// &lt;p>
    /// If this value is set and not the "sentinel account", the referenced
    /// account MUST sign this transaction.&lt;br/>
    /// If this value is set, the current `adminKey` for the topic MUST sign
    /// this transaction.&lt;br/>
    /// If this value is set to the "sentinel account", which is `0.0.0`, the
    /// `autoRenewAccount` SHALL be removed from the topic.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.AccountID AutoRenewAccount {
      get { return autoRenewAccount_; }
      set {
        autoRenewAccount_ = value;
      }
    }

    /// <summary>Field number for the "fee_schedule_key" field.</summary>
    public const int FeeScheduleKeyFieldNumber = 10;
    private global::Proto.Key feeScheduleKey_;
    /// <summary>
    ///*
    /// Access control for update/delete of custom fees.
    /// &lt;p>
    /// If set, subsequent consensus_update_topic transactions signed with this
    /// key MAY update or delete the custom fees for this topic.&lt;br/>
    /// If this field is set, the admin key MUST sign this transaction.&lt;br/>
    /// If this field is set, the previous value SHALL be replaced.&lt;br/>
    /// If set to a 'Key' containing an empty 'KeyList', the previous value
    /// SHALL be cleared.&lt;br/>
    /// If not set, the current key SHALL NOT change.&lt;br/>
    /// If unset in state, this field MUST NOT be set in this transaction.&lt;br/>
    /// If not set when the topic is created, this field CANNOT be set via
    /// update.&lt;br/>
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.Key FeeScheduleKey {
      get { return feeScheduleKey_; }
      set {
        feeScheduleKey_ = value;
      }
    }

    /// <summary>Field number for the "fee_exempt_key_list" field.</summary>
    public const int FeeExemptKeyListFieldNumber = 11;
    private global::Proto.FeeExemptKeyList feeExemptKeyList_;
    /// <summary>
    ///*
    /// A set of keys&lt;br/>
    /// Keys in this list are permitted to submit messages to this topic without
    /// paying custom fees associated with this topic.
    /// &lt;p>
    /// If a submit transaction is signed by _any_ key included in this set,
    /// custom fees SHALL NOT be charged for that transaction.&lt;br/>
    /// If this field is not set, the current set of keys SHALL NOT change.&lt;br/>
    /// If this field is set, but contains an empty list, any existing fee-exempt
    /// keys SHALL be removed.&lt;br/>
    /// A `fee_exempt_key_list` MUST NOT contain more than
    /// `MAX_ENTRIES_FOR_FEE_EXEMPT_KEY_LIST` keys.&lt;br/>
    /// A `fee_exempt_key_list` MUST NOT contain any duplicate keys.&lt;br/>
    /// A `fee_exempt_key_list` MAY contain keys for accounts that are inactive,
    /// deleted, or non-existent.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.FeeExemptKeyList FeeExemptKeyList {
      get { return feeExemptKeyList_; }
      set {
        feeExemptKeyList_ = value;
      }
    }

    /// <summary>Field number for the "custom_fees" field.</summary>
    public const int CustomFeesFieldNumber = 12;
    private global::Proto.FixedCustomFeeList customFees_;
    /// <summary>
    ///*
    /// A set of custom fee definitions.&lt;br/>
    /// These are fees to be assessed for each submit to this topic.
    /// &lt;p>
    /// Each fee defined in this set SHALL be evaluated for
    /// each message submitted to this topic, and the resultant
    /// total assessed fees SHALL be charged.&lt;br/>
    /// Custom fees defined here SHALL be assessed in addition to the base
    /// network and node fees.&lt;br/>
    /// If this field is not set, the current set of custom fees
    /// SHALL NOT change.&lt;br/>
    /// If this field is set, but contains an empty list, all current custom fees
    /// SHALL be removed.
    /// custom_fees list SHALL NOT contain more than
    /// `MAX_CUSTOM_FEE_ENTRIES_FOR_TOPICS` entries.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.FixedCustomFeeList CustomFees {
      get { return customFees_; }
      set {
        customFees_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ConsensusUpdateTopicTransactionBody);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ConsensusUpdateTopicTransactionBody other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(TopicID, other.TopicID)) return false;
      if (Memo != other.Memo) return false;
      if (!object.Equals(ExpirationTime, other.ExpirationTime)) return false;
      if (!object.Equals(AdminKey, other.AdminKey)) return false;
      if (!object.Equals(SubmitKey, other.SubmitKey)) return false;
      if (!object.Equals(AutoRenewPeriod, other.AutoRenewPeriod)) return false;
      if (!object.Equals(AutoRenewAccount, other.AutoRenewAccount)) return false;
      if (!object.Equals(FeeScheduleKey, other.FeeScheduleKey)) return false;
      if (!object.Equals(FeeExemptKeyList, other.FeeExemptKeyList)) return false;
      if (!object.Equals(CustomFees, other.CustomFees)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (topicID_ != null) hash ^= TopicID.GetHashCode();
      if (memo_ != null) hash ^= Memo.GetHashCode();
      if (expirationTime_ != null) hash ^= ExpirationTime.GetHashCode();
      if (adminKey_ != null) hash ^= AdminKey.GetHashCode();
      if (submitKey_ != null) hash ^= SubmitKey.GetHashCode();
      if (autoRenewPeriod_ != null) hash ^= AutoRenewPeriod.GetHashCode();
      if (autoRenewAccount_ != null) hash ^= AutoRenewAccount.GetHashCode();
      if (feeScheduleKey_ != null) hash ^= FeeScheduleKey.GetHashCode();
      if (feeExemptKeyList_ != null) hash ^= FeeExemptKeyList.GetHashCode();
      if (customFees_ != null) hash ^= CustomFees.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (topicID_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(TopicID);
      }
      if (memo_ != null) {
        _single_memo_codec.WriteTagAndValue(output, Memo);
      }
      if (expirationTime_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(ExpirationTime);
      }
      if (adminKey_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(AdminKey);
      }
      if (submitKey_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(SubmitKey);
      }
      if (autoRenewPeriod_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(AutoRenewPeriod);
      }
      if (autoRenewAccount_ != null) {
        output.WriteRawTag(74);
        output.WriteMessage(AutoRenewAccount);
      }
      if (feeScheduleKey_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(FeeScheduleKey);
      }
      if (feeExemptKeyList_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(FeeExemptKeyList);
      }
      if (customFees_ != null) {
        output.WriteRawTag(98);
        output.WriteMessage(CustomFees);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (topicID_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(TopicID);
      }
      if (memo_ != null) {
        _single_memo_codec.WriteTagAndValue(ref output, Memo);
      }
      if (expirationTime_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(ExpirationTime);
      }
      if (adminKey_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(AdminKey);
      }
      if (submitKey_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(SubmitKey);
      }
      if (autoRenewPeriod_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(AutoRenewPeriod);
      }
      if (autoRenewAccount_ != null) {
        output.WriteRawTag(74);
        output.WriteMessage(AutoRenewAccount);
      }
      if (feeScheduleKey_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(FeeScheduleKey);
      }
      if (feeExemptKeyList_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(FeeExemptKeyList);
      }
      if (customFees_ != null) {
        output.WriteRawTag(98);
        output.WriteMessage(CustomFees);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (topicID_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TopicID);
      }
      if (memo_ != null) {
        size += _single_memo_codec.CalculateSizeWithTag(Memo);
      }
      if (expirationTime_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ExpirationTime);
      }
      if (adminKey_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(AdminKey);
      }
      if (submitKey_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SubmitKey);
      }
      if (autoRenewPeriod_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(AutoRenewPeriod);
      }
      if (autoRenewAccount_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(AutoRenewAccount);
      }
      if (feeScheduleKey_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(FeeScheduleKey);
      }
      if (feeExemptKeyList_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(FeeExemptKeyList);
      }
      if (customFees_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(CustomFees);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ConsensusUpdateTopicTransactionBody other) {
      if (other == null) {
        return;
      }
      if (other.topicID_ != null) {
        if (topicID_ == null) {
          TopicID = new global::Proto.TopicID();
        }
        TopicID.MergeFrom(other.TopicID);
      }
      if (other.memo_ != null) {
        if (memo_ == null || other.Memo != "") {
          Memo = other.Memo;
        }
      }
      if (other.expirationTime_ != null) {
        if (expirationTime_ == null) {
          ExpirationTime = new global::Proto.Timestamp();
        }
        ExpirationTime.MergeFrom(other.ExpirationTime);
      }
      if (other.adminKey_ != null) {
        if (adminKey_ == null) {
          AdminKey = new global::Proto.Key();
        }
        AdminKey.MergeFrom(other.AdminKey);
      }
      if (other.submitKey_ != null) {
        if (submitKey_ == null) {
          SubmitKey = new global::Proto.Key();
        }
        SubmitKey.MergeFrom(other.SubmitKey);
      }
      if (other.autoRenewPeriod_ != null) {
        if (autoRenewPeriod_ == null) {
          AutoRenewPeriod = new global::Proto.Duration();
        }
        AutoRenewPeriod.MergeFrom(other.AutoRenewPeriod);
      }
      if (other.autoRenewAccount_ != null) {
        if (autoRenewAccount_ == null) {
          AutoRenewAccount = new global::Proto.AccountID();
        }
        AutoRenewAccount.MergeFrom(other.AutoRenewAccount);
      }
      if (other.feeScheduleKey_ != null) {
        if (feeScheduleKey_ == null) {
          FeeScheduleKey = new global::Proto.Key();
        }
        FeeScheduleKey.MergeFrom(other.FeeScheduleKey);
      }
      if (other.feeExemptKeyList_ != null) {
        if (feeExemptKeyList_ == null) {
          FeeExemptKeyList = new global::Proto.FeeExemptKeyList();
        }
        FeeExemptKeyList.MergeFrom(other.FeeExemptKeyList);
      }
      if (other.customFees_ != null) {
        if (customFees_ == null) {
          CustomFees = new global::Proto.FixedCustomFeeList();
        }
        CustomFees.MergeFrom(other.CustomFees);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (topicID_ == null) {
              TopicID = new global::Proto.TopicID();
            }
            input.ReadMessage(TopicID);
            break;
          }
          case 18: {
            string value = _single_memo_codec.Read(input);
            if (memo_ == null || value != "") {
              Memo = value;
            }
            break;
          }
          case 34: {
            if (expirationTime_ == null) {
              ExpirationTime = new global::Proto.Timestamp();
            }
            input.ReadMessage(ExpirationTime);
            break;
          }
          case 50: {
            if (adminKey_ == null) {
              AdminKey = new global::Proto.Key();
            }
            input.ReadMessage(AdminKey);
            break;
          }
          case 58: {
            if (submitKey_ == null) {
              SubmitKey = new global::Proto.Key();
            }
            input.ReadMessage(SubmitKey);
            break;
          }
          case 66: {
            if (autoRenewPeriod_ == null) {
              AutoRenewPeriod = new global::Proto.Duration();
            }
            input.ReadMessage(AutoRenewPeriod);
            break;
          }
          case 74: {
            if (autoRenewAccount_ == null) {
              AutoRenewAccount = new global::Proto.AccountID();
            }
            input.ReadMessage(AutoRenewAccount);
            break;
          }
          case 82: {
            if (feeScheduleKey_ == null) {
              FeeScheduleKey = new global::Proto.Key();
            }
            input.ReadMessage(FeeScheduleKey);
            break;
          }
          case 90: {
            if (feeExemptKeyList_ == null) {
              FeeExemptKeyList = new global::Proto.FeeExemptKeyList();
            }
            input.ReadMessage(FeeExemptKeyList);
            break;
          }
          case 98: {
            if (customFees_ == null) {
              CustomFees = new global::Proto.FixedCustomFeeList();
            }
            input.ReadMessage(CustomFees);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (topicID_ == null) {
              TopicID = new global::Proto.TopicID();
            }
            input.ReadMessage(TopicID);
            break;
          }
          case 18: {
            string value = _single_memo_codec.Read(ref input);
            if (memo_ == null || value != "") {
              Memo = value;
            }
            break;
          }
          case 34: {
            if (expirationTime_ == null) {
              ExpirationTime = new global::Proto.Timestamp();
            }
            input.ReadMessage(ExpirationTime);
            break;
          }
          case 50: {
            if (adminKey_ == null) {
              AdminKey = new global::Proto.Key();
            }
            input.ReadMessage(AdminKey);
            break;
          }
          case 58: {
            if (submitKey_ == null) {
              SubmitKey = new global::Proto.Key();
            }
            input.ReadMessage(SubmitKey);
            break;
          }
          case 66: {
            if (autoRenewPeriod_ == null) {
              AutoRenewPeriod = new global::Proto.Duration();
            }
            input.ReadMessage(AutoRenewPeriod);
            break;
          }
          case 74: {
            if (autoRenewAccount_ == null) {
              AutoRenewAccount = new global::Proto.AccountID();
            }
            input.ReadMessage(AutoRenewAccount);
            break;
          }
          case 82: {
            if (feeScheduleKey_ == null) {
              FeeScheduleKey = new global::Proto.Key();
            }
            input.ReadMessage(FeeScheduleKey);
            break;
          }
          case 90: {
            if (feeExemptKeyList_ == null) {
              FeeExemptKeyList = new global::Proto.FeeExemptKeyList();
            }
            input.ReadMessage(FeeExemptKeyList);
            break;
          }
          case 98: {
            if (customFees_ == null) {
              CustomFees = new global::Proto.FixedCustomFeeList();
            }
            input.ReadMessage(CustomFees);
            break;
          }
        }
      }
    }
    #endif

  }

  #endregion

}

#endregion Designer generated code
