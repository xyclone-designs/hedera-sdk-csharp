// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: smart_contract_service.proto
// </auto-generated>
// Original file comments:
// *
// # Smart Contract Service
// gRPC service definitions for calls to the Hedera EVM-compatible
// Smart Contract service.
//
// ### Keywords
// The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
// "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
// document are to be interpreted as described in
// [RFC2119](https://www.ietf.org/rfc/rfc2119) and clarified in
// [RFC8174](https://www.ietf.org/rfc/rfc8174).
#pragma warning disable 0414, 1591, 8981, 0612
#region Designer generated code

using grpc = global::Grpc.Core;

namespace Hedera.Hashgraph.Proto {
  /// <summary>
  ///*
  /// The Hedera Smart Contract Service (HSCS) provides an interface to an EVM
  /// compatible environment to create, store, manage, and execute smart contract
  /// calls. Smart Contracts implement useful and often highly complex
  /// interactions between individuals, systems, and the distributed ledger.
  /// </summary>
  public static partial class SmartContractService
  {
    static readonly string __ServiceName = "proto.SmartContractService";

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static void __Helper_SerializeMessage(global::Google.Protobuf.IMessage message, grpc::SerializationContext context)
    {
      #if !GRPC_DISABLE_PROTOBUF_BUFFER_SERIALIZATION
      if (message is global::Google.Protobuf.IBufferMessage)
      {
        context.SetPayloadLength(message.CalculateSize());
        global::Google.Protobuf.MessageExtensions.WriteTo(message, context.GetBufferWriter());
        context.Complete();
        return;
      }
      #endif
      context.Complete(global::Google.Protobuf.MessageExtensions.ToByteArray(message));
    }

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static class __Helper_MessageCache<T>
    {
      public static readonly bool IsBufferMessage = global::System.Reflection.IntrospectionExtensions.GetTypeInfo(typeof(global::Google.Protobuf.IBufferMessage)).IsAssignableFrom(typeof(T));
    }

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static T __Helper_DeserializeMessage<T>(grpc::DeserializationContext context, global::Google.Protobuf.MessageParser<T> parser) where T : global::Google.Protobuf.IMessage<T>
    {
      #if !GRPC_DISABLE_PROTOBUF_BUFFER_SERIALIZATION
      if (__Helper_MessageCache<T>.IsBufferMessage)
      {
        return parser.ParseFrom(context.PayloadAsReadOnlySequence());
      }
      #endif
      return parser.ParseFrom(context.PayloadAsNewBuffer());
    }

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::Hedera.Hashgraph.Proto.Transaction> __Marshaller_proto_Transaction = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Hedera.Hashgraph.Proto.Transaction.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::Hedera.Hashgraph.Proto.TransactionResponse> __Marshaller_proto_TransactionResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Hedera.Hashgraph.Proto.TransactionResponse.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::Hedera.Hashgraph.Proto.Query> __Marshaller_proto_Query = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Hedera.Hashgraph.Proto.Query.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::Hedera.Hashgraph.Proto.Response> __Marshaller_proto_Response = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Hedera.Hashgraph.Proto.Response.Parser));

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse> __Method_createContract = new grpc::Method<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "createContract",
        __Marshaller_proto_Transaction,
        __Marshaller_proto_TransactionResponse);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse> __Method_updateContract = new grpc::Method<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "updateContract",
        __Marshaller_proto_Transaction,
        __Marshaller_proto_TransactionResponse);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse> __Method_contractCallMethod = new grpc::Method<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "contractCallMethod",
        __Marshaller_proto_Transaction,
        __Marshaller_proto_TransactionResponse);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::Hedera.Hashgraph.Proto.Query, global::Hedera.Hashgraph.Proto.Response> __Method_contractCallLocalMethod = new grpc::Method<global::Hedera.Hashgraph.Proto.Query, global::Hedera.Hashgraph.Proto.Response>(
        grpc::MethodType.Unary,
        __ServiceName,
        "contractCallLocalMethod",
        __Marshaller_proto_Query,
        __Marshaller_proto_Response);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::Hedera.Hashgraph.Proto.Query, global::Hedera.Hashgraph.Proto.Response> __Method_getContractInfo = new grpc::Method<global::Hedera.Hashgraph.Proto.Query, global::Hedera.Hashgraph.Proto.Response>(
        grpc::MethodType.Unary,
        __ServiceName,
        "getContractInfo",
        __Marshaller_proto_Query,
        __Marshaller_proto_Response);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::Hedera.Hashgraph.Proto.Query, global::Hedera.Hashgraph.Proto.Response> __Method_ContractGetBytecode = new grpc::Method<global::Hedera.Hashgraph.Proto.Query, global::Hedera.Hashgraph.Proto.Response>(
        grpc::MethodType.Unary,
        __ServiceName,
        "ContractGetBytecode",
        __Marshaller_proto_Query,
        __Marshaller_proto_Response);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::Hedera.Hashgraph.Proto.Query, global::Hedera.Hashgraph.Proto.Response> __Method_getBySolidityID = new grpc::Method<global::Hedera.Hashgraph.Proto.Query, global::Hedera.Hashgraph.Proto.Response>(
        grpc::MethodType.Unary,
        __ServiceName,
        "getBySolidityID",
        __Marshaller_proto_Query,
        __Marshaller_proto_Response);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::Hedera.Hashgraph.Proto.Query, global::Hedera.Hashgraph.Proto.Response> __Method_getTxRecordByContractID = new grpc::Method<global::Hedera.Hashgraph.Proto.Query, global::Hedera.Hashgraph.Proto.Response>(
        grpc::MethodType.Unary,
        __ServiceName,
        "getTxRecordByContractID",
        __Marshaller_proto_Query,
        __Marshaller_proto_Response);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse> __Method_deleteContract = new grpc::Method<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "deleteContract",
        __Marshaller_proto_Transaction,
        __Marshaller_proto_TransactionResponse);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse> __Method_systemDelete = new grpc::Method<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "systemDelete",
        __Marshaller_proto_Transaction,
        __Marshaller_proto_TransactionResponse);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse> __Method_systemUndelete = new grpc::Method<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "systemUndelete",
        __Marshaller_proto_Transaction,
        __Marshaller_proto_TransactionResponse);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse> __Method_callEthereum = new grpc::Method<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "callEthereum",
        __Marshaller_proto_Transaction,
        __Marshaller_proto_TransactionResponse);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse> __Method_lambdaSStore = new grpc::Method<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "lambdaSStore",
        __Marshaller_proto_Transaction,
        __Marshaller_proto_TransactionResponse);

    /// <summary>Service descriptor</summary>
    public static global::Google.Protobuf.Reflection.ServiceDescriptor Descriptor
    {
      get { return global::Hedera.Hashgraph.Proto.SmartContractServiceReflection.Descriptor.Services[0]; }
    }

    /// <summary>Base class for server-side implementations of SmartContractService</summary>
    [grpc::BindServiceMethod(typeof(SmartContractService), "BindService")]
    public abstract partial class SmartContractServiceBase
    {
      /// <summary>
      ///*
      /// Create a new smart contract.
      /// &lt;p>
      /// If this transaction succeeds, the `ContractID` for the new smart
      /// contract SHALL be set in the transaction receipt.&lt;br/>
      /// The contract is defined by the initial bytecode (or `initcode`).
      /// The `initcode` SHALL be provided either in a previously created file,
      /// or in the transaction body itself for very small contracts.&lt;br/>
      /// As part of contract creation, the constructor defined for the new
      /// smart contract SHALL run with the parameters provided in
      /// the `constructorParameters` field.&lt;br/>
      /// The gas to "power" that constructor MUST be provided via the `gas`
      /// field, and SHALL be charged to the payer for this transaction.&lt;br/>
      /// If the contract _constructor_ stores information, it is charged gas for
      /// that storage. There is a separate fee in HBAR to maintain that storage
      /// until the expiration, and that fee SHALL be added to this transaction
      /// as part of the _transaction fee_, rather than gas.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::Hedera.Hashgraph.Proto.TransactionResponse> createContract(global::Hedera.Hashgraph.Proto.Transaction request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///*
      /// Modify a smart contract.&lt;br/>
      /// Any change other than updating the expiration time requires that the
      /// contract be modifiable (has a valid `adminKey`) and that the
      /// transaction be signed by the `adminKey`
      /// &lt;p>
      /// Fields _not set_ on the request SHALL NOT be modified.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::Hedera.Hashgraph.Proto.TransactionResponse> updateContract(global::Hedera.Hashgraph.Proto.Transaction request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///*
      /// Call a function of a given smart contract, providing function parameter
      /// inputs as needed.
      /// &lt;p>
      /// Resource ("gas") charges SHALL include all relevant fees incurred by
      /// the contract execution, including any storage required.&lt;br/>
      /// The total transaction fee SHALL incorporate all of the "gas" actually
      /// consumed as well as the standard fees for transaction handling,
      /// data transfers, signature verification, etc...
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::Hedera.Hashgraph.Proto.TransactionResponse> contractCallMethod(global::Hedera.Hashgraph.Proto.Transaction request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///*
      /// Call a query function of a given smart contract, providing
      /// function parameter inputs as needed.&lt;br/>
      /// This is performed locally on the particular node that the client is
      /// communicating with. Executing the call locally is faster and less
      /// costly, but imposes certain restrictions.
      /// &lt;p>
      /// The call MUST NOT change the state of the contract instance. This also
      /// precludes any expenditure or transfer of HBAR or other tokens.&lt;br/>
      /// The call SHALL NOT have a separate consensus timestamp.&lt;br/>
      /// The call SHALL NOT generate a record nor a receipt.&lt;br/>
      /// The response SHALL contain the output returned by the function call.&lt;br/>
      /// &lt;p>
      /// This is generally useful for calling accessor functions which read
      /// (query) state without changes or side effects. Any contract call that
      /// would use the `STATICCALL` opcode MAY be called via contract call local
      /// with performance and cost benefits.
      /// &lt;p>
      /// Unlike a ContractCall transaction, the node SHALL always consume the
      /// _entire_ amount of offered "gas" in determining the fee for this query,
      /// so accurate gas estimation is important.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::Hedera.Hashgraph.Proto.Response> contractCallLocalMethod(global::Hedera.Hashgraph.Proto.Query request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///*
      /// A standard query to obtain detailed information for a smart contract.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::Hedera.Hashgraph.Proto.Response> getContractInfo(global::Hedera.Hashgraph.Proto.Query request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///*
      /// A standard query to read the current bytecode for a smart contract.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::Hedera.Hashgraph.Proto.Response> ContractGetBytecode(global::Hedera.Hashgraph.Proto.Query request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///*
      /// A standard query to obtain account and contract identifiers for a smart
      /// contract, given the Solidity identifier for that contract.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      [global::System.ObsoleteAttribute]
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::Hedera.Hashgraph.Proto.Response> getBySolidityID(global::Hedera.Hashgraph.Proto.Query request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///*
      /// &lt;blockquote>This query is no longer supported.&lt;/blockquote>
      /// This query always returned an empty record list.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      [global::System.ObsoleteAttribute]
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::Hedera.Hashgraph.Proto.Response> getTxRecordByContractID(global::Hedera.Hashgraph.Proto.Query request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///*
      /// Delete a smart contract, and transfer any remaining HBAR balance
      /// to a designated account.
      /// &lt;p>
      /// If this call succeeds then all subsequent calls to that smart
      /// contract SHALL fail.&lt;br/>
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::Hedera.Hashgraph.Proto.TransactionResponse> deleteContract(global::Hedera.Hashgraph.Proto.Transaction request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///*
      /// Delete a smart contract, as a system-initiated deletion, this
      /// SHALL NOT transfer balances.
      /// &lt;blockquote>
      /// This call is an administrative function of the Hedera network, and
      /// SHALL require network administration authorization.&lt;br/>
      /// This transaction MUST be signed by one of the network administration
      /// accounts (typically `0.0.2` through `0.0.59`, as defined in the
      /// `api-permission.properties` file).
      /// &lt;/blockquote>
      /// If this call succeeds then all subsequent calls to that smart
      /// contract SHALL fail.&lt;br/>
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      [global::System.ObsoleteAttribute]
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::Hedera.Hashgraph.Proto.TransactionResponse> systemDelete(global::Hedera.Hashgraph.Proto.Transaction request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///*
      /// Un-Delete a smart contract, returning it (mostly) to its state
      /// prior to deletion.
      /// &lt;p>
      /// The contract to be restored MUST have been deleted via `systemDelete`.
      /// If the contract was deleted via `deleteContract`, it
      /// SHALL NOT be recoverable.
      /// &lt;blockquote>
      /// This call is an administrative function of the Hedera network, and
      /// SHALL require network administration authorization.&lt;br/>
      /// This transaction MUST be signed by one of the network administration
      /// accounts (typically `0.0.2` through `0.0.59`, as defined in the
      /// `api-permission.properties` file).
      /// &lt;/blockquote>
      /// If this call succeeds then subsequent calls to that smart
      /// contract MAY succeed.&lt;br/>
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      [global::System.ObsoleteAttribute]
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::Hedera.Hashgraph.Proto.TransactionResponse> systemUndelete(global::Hedera.Hashgraph.Proto.Transaction request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///*
      /// Make an Ethereum transaction "call" with all data in Ethereum formats,
      /// including the contract alias.
      /// &lt;p>
      /// Call data MAY be in the transaction, or stored within a "File".&lt;br/>
      /// The caller MAY offer additional gas above what is offered in the call
      /// data, but MAY be charged up to 80% of that value if the amount required
      /// is less than this "floor" amount.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::Hedera.Hashgraph.Proto.TransactionResponse> callEthereum(global::Hedera.Hashgraph.Proto.Transaction request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///*
      /// Update zero or more slots of a lambda.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::Hedera.Hashgraph.Proto.TransactionResponse> lambdaSStore(global::Hedera.Hashgraph.Proto.Transaction request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

    }

    /// <summary>Client for SmartContractService</summary>
    public partial class SmartContractServiceClient : grpc::ClientBase<SmartContractServiceClient>
    {
      /// <summary>Creates a new client for SmartContractService</summary>
      /// <param name="channel">The channel to use to make remote calls.</param>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public SmartContractServiceClient(grpc::ChannelBase channel) : base(channel)
      {
      }
      /// <summary>Creates a new client for SmartContractService that uses a custom <c>CallInvoker</c>.</summary>
      /// <param name="callInvoker">The callInvoker to use to make remote calls.</param>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public SmartContractServiceClient(grpc::CallInvoker callInvoker) : base(callInvoker)
      {
      }
      /// <summary>Protected parameterless constructor to allow creation of test doubles.</summary>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      protected SmartContractServiceClient() : base()
      {
      }
      /// <summary>Protected constructor to allow creation of configured clients.</summary>
      /// <param name="configuration">The client configuration.</param>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      protected SmartContractServiceClient(ClientBaseConfiguration configuration) : base(configuration)
      {
      }

      /// <summary>
      ///*
      /// Create a new smart contract.
      /// &lt;p>
      /// If this transaction succeeds, the `ContractID` for the new smart
      /// contract SHALL be set in the transaction receipt.&lt;br/>
      /// The contract is defined by the initial bytecode (or `initcode`).
      /// The `initcode` SHALL be provided either in a previously created file,
      /// or in the transaction body itself for very small contracts.&lt;br/>
      /// As part of contract creation, the constructor defined for the new
      /// smart contract SHALL run with the parameters provided in
      /// the `constructorParameters` field.&lt;br/>
      /// The gas to "power" that constructor MUST be provided via the `gas`
      /// field, and SHALL be charged to the payer for this transaction.&lt;br/>
      /// If the contract _constructor_ stores information, it is charged gas for
      /// that storage. There is a separate fee in HBAR to maintain that storage
      /// until the expiration, and that fee SHALL be added to this transaction
      /// as part of the _transaction fee_, rather than gas.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Hedera.Hashgraph.Proto.TransactionResponse createContract(global::Hedera.Hashgraph.Proto.Transaction request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return createContract(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      /// Create a new smart contract.
      /// &lt;p>
      /// If this transaction succeeds, the `ContractID` for the new smart
      /// contract SHALL be set in the transaction receipt.&lt;br/>
      /// The contract is defined by the initial bytecode (or `initcode`).
      /// The `initcode` SHALL be provided either in a previously created file,
      /// or in the transaction body itself for very small contracts.&lt;br/>
      /// As part of contract creation, the constructor defined for the new
      /// smart contract SHALL run with the parameters provided in
      /// the `constructorParameters` field.&lt;br/>
      /// The gas to "power" that constructor MUST be provided via the `gas`
      /// field, and SHALL be charged to the payer for this transaction.&lt;br/>
      /// If the contract _constructor_ stores information, it is charged gas for
      /// that storage. There is a separate fee in HBAR to maintain that storage
      /// until the expiration, and that fee SHALL be added to this transaction
      /// as part of the _transaction fee_, rather than gas.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Hedera.Hashgraph.Proto.TransactionResponse createContract(global::Hedera.Hashgraph.Proto.Transaction request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_createContract, null, options, request);
      }
      /// <summary>
      ///*
      /// Create a new smart contract.
      /// &lt;p>
      /// If this transaction succeeds, the `ContractID` for the new smart
      /// contract SHALL be set in the transaction receipt.&lt;br/>
      /// The contract is defined by the initial bytecode (or `initcode`).
      /// The `initcode` SHALL be provided either in a previously created file,
      /// or in the transaction body itself for very small contracts.&lt;br/>
      /// As part of contract creation, the constructor defined for the new
      /// smart contract SHALL run with the parameters provided in
      /// the `constructorParameters` field.&lt;br/>
      /// The gas to "power" that constructor MUST be provided via the `gas`
      /// field, and SHALL be charged to the payer for this transaction.&lt;br/>
      /// If the contract _constructor_ stores information, it is charged gas for
      /// that storage. There is a separate fee in HBAR to maintain that storage
      /// until the expiration, and that fee SHALL be added to this transaction
      /// as part of the _transaction fee_, rather than gas.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Hedera.Hashgraph.Proto.TransactionResponse> createContractAsync(global::Hedera.Hashgraph.Proto.Transaction request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return createContractAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      /// Create a new smart contract.
      /// &lt;p>
      /// If this transaction succeeds, the `ContractID` for the new smart
      /// contract SHALL be set in the transaction receipt.&lt;br/>
      /// The contract is defined by the initial bytecode (or `initcode`).
      /// The `initcode` SHALL be provided either in a previously created file,
      /// or in the transaction body itself for very small contracts.&lt;br/>
      /// As part of contract creation, the constructor defined for the new
      /// smart contract SHALL run with the parameters provided in
      /// the `constructorParameters` field.&lt;br/>
      /// The gas to "power" that constructor MUST be provided via the `gas`
      /// field, and SHALL be charged to the payer for this transaction.&lt;br/>
      /// If the contract _constructor_ stores information, it is charged gas for
      /// that storage. There is a separate fee in HBAR to maintain that storage
      /// until the expiration, and that fee SHALL be added to this transaction
      /// as part of the _transaction fee_, rather than gas.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Hedera.Hashgraph.Proto.TransactionResponse> createContractAsync(global::Hedera.Hashgraph.Proto.Transaction request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_createContract, null, options, request);
      }
      /// <summary>
      ///*
      /// Modify a smart contract.&lt;br/>
      /// Any change other than updating the expiration time requires that the
      /// contract be modifiable (has a valid `adminKey`) and that the
      /// transaction be signed by the `adminKey`
      /// &lt;p>
      /// Fields _not set_ on the request SHALL NOT be modified.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Hedera.Hashgraph.Proto.TransactionResponse updateContract(global::Hedera.Hashgraph.Proto.Transaction request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return updateContract(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      /// Modify a smart contract.&lt;br/>
      /// Any change other than updating the expiration time requires that the
      /// contract be modifiable (has a valid `adminKey`) and that the
      /// transaction be signed by the `adminKey`
      /// &lt;p>
      /// Fields _not set_ on the request SHALL NOT be modified.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Hedera.Hashgraph.Proto.TransactionResponse updateContract(global::Hedera.Hashgraph.Proto.Transaction request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_updateContract, null, options, request);
      }
      /// <summary>
      ///*
      /// Modify a smart contract.&lt;br/>
      /// Any change other than updating the expiration time requires that the
      /// contract be modifiable (has a valid `adminKey`) and that the
      /// transaction be signed by the `adminKey`
      /// &lt;p>
      /// Fields _not set_ on the request SHALL NOT be modified.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Hedera.Hashgraph.Proto.TransactionResponse> updateContractAsync(global::Hedera.Hashgraph.Proto.Transaction request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return updateContractAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      /// Modify a smart contract.&lt;br/>
      /// Any change other than updating the expiration time requires that the
      /// contract be modifiable (has a valid `adminKey`) and that the
      /// transaction be signed by the `adminKey`
      /// &lt;p>
      /// Fields _not set_ on the request SHALL NOT be modified.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Hedera.Hashgraph.Proto.TransactionResponse> updateContractAsync(global::Hedera.Hashgraph.Proto.Transaction request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_updateContract, null, options, request);
      }
      /// <summary>
      ///*
      /// Call a function of a given smart contract, providing function parameter
      /// inputs as needed.
      /// &lt;p>
      /// Resource ("gas") charges SHALL include all relevant fees incurred by
      /// the contract execution, including any storage required.&lt;br/>
      /// The total transaction fee SHALL incorporate all of the "gas" actually
      /// consumed as well as the standard fees for transaction handling,
      /// data transfers, signature verification, etc...
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Hedera.Hashgraph.Proto.TransactionResponse contractCallMethod(global::Hedera.Hashgraph.Proto.Transaction request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return contractCallMethod(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      /// Call a function of a given smart contract, providing function parameter
      /// inputs as needed.
      /// &lt;p>
      /// Resource ("gas") charges SHALL include all relevant fees incurred by
      /// the contract execution, including any storage required.&lt;br/>
      /// The total transaction fee SHALL incorporate all of the "gas" actually
      /// consumed as well as the standard fees for transaction handling,
      /// data transfers, signature verification, etc...
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Hedera.Hashgraph.Proto.TransactionResponse contractCallMethod(global::Hedera.Hashgraph.Proto.Transaction request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_contractCallMethod, null, options, request);
      }
      /// <summary>
      ///*
      /// Call a function of a given smart contract, providing function parameter
      /// inputs as needed.
      /// &lt;p>
      /// Resource ("gas") charges SHALL include all relevant fees incurred by
      /// the contract execution, including any storage required.&lt;br/>
      /// The total transaction fee SHALL incorporate all of the "gas" actually
      /// consumed as well as the standard fees for transaction handling,
      /// data transfers, signature verification, etc...
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Hedera.Hashgraph.Proto.TransactionResponse> contractCallMethodAsync(global::Hedera.Hashgraph.Proto.Transaction request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return contractCallMethodAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      /// Call a function of a given smart contract, providing function parameter
      /// inputs as needed.
      /// &lt;p>
      /// Resource ("gas") charges SHALL include all relevant fees incurred by
      /// the contract execution, including any storage required.&lt;br/>
      /// The total transaction fee SHALL incorporate all of the "gas" actually
      /// consumed as well as the standard fees for transaction handling,
      /// data transfers, signature verification, etc...
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Hedera.Hashgraph.Proto.TransactionResponse> contractCallMethodAsync(global::Hedera.Hashgraph.Proto.Transaction request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_contractCallMethod, null, options, request);
      }
      /// <summary>
      ///*
      /// Call a query function of a given smart contract, providing
      /// function parameter inputs as needed.&lt;br/>
      /// This is performed locally on the particular node that the client is
      /// communicating with. Executing the call locally is faster and less
      /// costly, but imposes certain restrictions.
      /// &lt;p>
      /// The call MUST NOT change the state of the contract instance. This also
      /// precludes any expenditure or transfer of HBAR or other tokens.&lt;br/>
      /// The call SHALL NOT have a separate consensus timestamp.&lt;br/>
      /// The call SHALL NOT generate a record nor a receipt.&lt;br/>
      /// The response SHALL contain the output returned by the function call.&lt;br/>
      /// &lt;p>
      /// This is generally useful for calling accessor functions which read
      /// (query) state without changes or side effects. Any contract call that
      /// would use the `STATICCALL` opcode MAY be called via contract call local
      /// with performance and cost benefits.
      /// &lt;p>
      /// Unlike a ContractCall transaction, the node SHALL always consume the
      /// _entire_ amount of offered "gas" in determining the fee for this query,
      /// so accurate gas estimation is important.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Hedera.Hashgraph.Proto.Response contractCallLocalMethod(global::Hedera.Hashgraph.Proto.Query request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return contractCallLocalMethod(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      /// Call a query function of a given smart contract, providing
      /// function parameter inputs as needed.&lt;br/>
      /// This is performed locally on the particular node that the client is
      /// communicating with. Executing the call locally is faster and less
      /// costly, but imposes certain restrictions.
      /// &lt;p>
      /// The call MUST NOT change the state of the contract instance. This also
      /// precludes any expenditure or transfer of HBAR or other tokens.&lt;br/>
      /// The call SHALL NOT have a separate consensus timestamp.&lt;br/>
      /// The call SHALL NOT generate a record nor a receipt.&lt;br/>
      /// The response SHALL contain the output returned by the function call.&lt;br/>
      /// &lt;p>
      /// This is generally useful for calling accessor functions which read
      /// (query) state without changes or side effects. Any contract call that
      /// would use the `STATICCALL` opcode MAY be called via contract call local
      /// with performance and cost benefits.
      /// &lt;p>
      /// Unlike a ContractCall transaction, the node SHALL always consume the
      /// _entire_ amount of offered "gas" in determining the fee for this query,
      /// so accurate gas estimation is important.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Hedera.Hashgraph.Proto.Response contractCallLocalMethod(global::Hedera.Hashgraph.Proto.Query request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_contractCallLocalMethod, null, options, request);
      }
      /// <summary>
      ///*
      /// Call a query function of a given smart contract, providing
      /// function parameter inputs as needed.&lt;br/>
      /// This is performed locally on the particular node that the client is
      /// communicating with. Executing the call locally is faster and less
      /// costly, but imposes certain restrictions.
      /// &lt;p>
      /// The call MUST NOT change the state of the contract instance. This also
      /// precludes any expenditure or transfer of HBAR or other tokens.&lt;br/>
      /// The call SHALL NOT have a separate consensus timestamp.&lt;br/>
      /// The call SHALL NOT generate a record nor a receipt.&lt;br/>
      /// The response SHALL contain the output returned by the function call.&lt;br/>
      /// &lt;p>
      /// This is generally useful for calling accessor functions which read
      /// (query) state without changes or side effects. Any contract call that
      /// would use the `STATICCALL` opcode MAY be called via contract call local
      /// with performance and cost benefits.
      /// &lt;p>
      /// Unlike a ContractCall transaction, the node SHALL always consume the
      /// _entire_ amount of offered "gas" in determining the fee for this query,
      /// so accurate gas estimation is important.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Hedera.Hashgraph.Proto.Response> contractCallLocalMethodAsync(global::Hedera.Hashgraph.Proto.Query request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return contractCallLocalMethodAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      /// Call a query function of a given smart contract, providing
      /// function parameter inputs as needed.&lt;br/>
      /// This is performed locally on the particular node that the client is
      /// communicating with. Executing the call locally is faster and less
      /// costly, but imposes certain restrictions.
      /// &lt;p>
      /// The call MUST NOT change the state of the contract instance. This also
      /// precludes any expenditure or transfer of HBAR or other tokens.&lt;br/>
      /// The call SHALL NOT have a separate consensus timestamp.&lt;br/>
      /// The call SHALL NOT generate a record nor a receipt.&lt;br/>
      /// The response SHALL contain the output returned by the function call.&lt;br/>
      /// &lt;p>
      /// This is generally useful for calling accessor functions which read
      /// (query) state without changes or side effects. Any contract call that
      /// would use the `STATICCALL` opcode MAY be called via contract call local
      /// with performance and cost benefits.
      /// &lt;p>
      /// Unlike a ContractCall transaction, the node SHALL always consume the
      /// _entire_ amount of offered "gas" in determining the fee for this query,
      /// so accurate gas estimation is important.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Hedera.Hashgraph.Proto.Response> contractCallLocalMethodAsync(global::Hedera.Hashgraph.Proto.Query request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_contractCallLocalMethod, null, options, request);
      }
      /// <summary>
      ///*
      /// A standard query to obtain detailed information for a smart contract.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Hedera.Hashgraph.Proto.Response getContractInfo(global::Hedera.Hashgraph.Proto.Query request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return getContractInfo(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      /// A standard query to obtain detailed information for a smart contract.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Hedera.Hashgraph.Proto.Response getContractInfo(global::Hedera.Hashgraph.Proto.Query request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_getContractInfo, null, options, request);
      }
      /// <summary>
      ///*
      /// A standard query to obtain detailed information for a smart contract.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Hedera.Hashgraph.Proto.Response> getContractInfoAsync(global::Hedera.Hashgraph.Proto.Query request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return getContractInfoAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      /// A standard query to obtain detailed information for a smart contract.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Hedera.Hashgraph.Proto.Response> getContractInfoAsync(global::Hedera.Hashgraph.Proto.Query request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_getContractInfo, null, options, request);
      }
      /// <summary>
      ///*
      /// A standard query to read the current bytecode for a smart contract.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Hedera.Hashgraph.Proto.Response ContractGetBytecode(global::Hedera.Hashgraph.Proto.Query request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return ContractGetBytecode(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      /// A standard query to read the current bytecode for a smart contract.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Hedera.Hashgraph.Proto.Response ContractGetBytecode(global::Hedera.Hashgraph.Proto.Query request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_ContractGetBytecode, null, options, request);
      }
      /// <summary>
      ///*
      /// A standard query to read the current bytecode for a smart contract.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Hedera.Hashgraph.Proto.Response> ContractGetBytecodeAsync(global::Hedera.Hashgraph.Proto.Query request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return ContractGetBytecodeAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      /// A standard query to read the current bytecode for a smart contract.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Hedera.Hashgraph.Proto.Response> ContractGetBytecodeAsync(global::Hedera.Hashgraph.Proto.Query request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_ContractGetBytecode, null, options, request);
      }
      /// <summary>
      ///*
      /// A standard query to obtain account and contract identifiers for a smart
      /// contract, given the Solidity identifier for that contract.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.ObsoleteAttribute]
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Hedera.Hashgraph.Proto.Response getBySolidityID(global::Hedera.Hashgraph.Proto.Query request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return getBySolidityID(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      /// A standard query to obtain account and contract identifiers for a smart
      /// contract, given the Solidity identifier for that contract.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.ObsoleteAttribute]
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Hedera.Hashgraph.Proto.Response getBySolidityID(global::Hedera.Hashgraph.Proto.Query request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_getBySolidityID, null, options, request);
      }
      /// <summary>
      ///*
      /// A standard query to obtain account and contract identifiers for a smart
      /// contract, given the Solidity identifier for that contract.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.ObsoleteAttribute]
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Hedera.Hashgraph.Proto.Response> getBySolidityIDAsync(global::Hedera.Hashgraph.Proto.Query request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return getBySolidityIDAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      /// A standard query to obtain account and contract identifiers for a smart
      /// contract, given the Solidity identifier for that contract.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.ObsoleteAttribute]
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Hedera.Hashgraph.Proto.Response> getBySolidityIDAsync(global::Hedera.Hashgraph.Proto.Query request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_getBySolidityID, null, options, request);
      }
      /// <summary>
      ///*
      /// &lt;blockquote>This query is no longer supported.&lt;/blockquote>
      /// This query always returned an empty record list.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.ObsoleteAttribute]
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Hedera.Hashgraph.Proto.Response getTxRecordByContractID(global::Hedera.Hashgraph.Proto.Query request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return getTxRecordByContractID(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      /// &lt;blockquote>This query is no longer supported.&lt;/blockquote>
      /// This query always returned an empty record list.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.ObsoleteAttribute]
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Hedera.Hashgraph.Proto.Response getTxRecordByContractID(global::Hedera.Hashgraph.Proto.Query request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_getTxRecordByContractID, null, options, request);
      }
      /// <summary>
      ///*
      /// &lt;blockquote>This query is no longer supported.&lt;/blockquote>
      /// This query always returned an empty record list.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.ObsoleteAttribute]
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Hedera.Hashgraph.Proto.Response> getTxRecordByContractIDAsync(global::Hedera.Hashgraph.Proto.Query request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return getTxRecordByContractIDAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      /// &lt;blockquote>This query is no longer supported.&lt;/blockquote>
      /// This query always returned an empty record list.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.ObsoleteAttribute]
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Hedera.Hashgraph.Proto.Response> getTxRecordByContractIDAsync(global::Hedera.Hashgraph.Proto.Query request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_getTxRecordByContractID, null, options, request);
      }
      /// <summary>
      ///*
      /// Delete a smart contract, and transfer any remaining HBAR balance
      /// to a designated account.
      /// &lt;p>
      /// If this call succeeds then all subsequent calls to that smart
      /// contract SHALL fail.&lt;br/>
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Hedera.Hashgraph.Proto.TransactionResponse deleteContract(global::Hedera.Hashgraph.Proto.Transaction request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return deleteContract(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      /// Delete a smart contract, and transfer any remaining HBAR balance
      /// to a designated account.
      /// &lt;p>
      /// If this call succeeds then all subsequent calls to that smart
      /// contract SHALL fail.&lt;br/>
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Hedera.Hashgraph.Proto.TransactionResponse deleteContract(global::Hedera.Hashgraph.Proto.Transaction request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_deleteContract, null, options, request);
      }
      /// <summary>
      ///*
      /// Delete a smart contract, and transfer any remaining HBAR balance
      /// to a designated account.
      /// &lt;p>
      /// If this call succeeds then all subsequent calls to that smart
      /// contract SHALL fail.&lt;br/>
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Hedera.Hashgraph.Proto.TransactionResponse> deleteContractAsync(global::Hedera.Hashgraph.Proto.Transaction request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return deleteContractAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      /// Delete a smart contract, and transfer any remaining HBAR balance
      /// to a designated account.
      /// &lt;p>
      /// If this call succeeds then all subsequent calls to that smart
      /// contract SHALL fail.&lt;br/>
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Hedera.Hashgraph.Proto.TransactionResponse> deleteContractAsync(global::Hedera.Hashgraph.Proto.Transaction request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_deleteContract, null, options, request);
      }
      /// <summary>
      ///*
      /// Delete a smart contract, as a system-initiated deletion, this
      /// SHALL NOT transfer balances.
      /// &lt;blockquote>
      /// This call is an administrative function of the Hedera network, and
      /// SHALL require network administration authorization.&lt;br/>
      /// This transaction MUST be signed by one of the network administration
      /// accounts (typically `0.0.2` through `0.0.59`, as defined in the
      /// `api-permission.properties` file).
      /// &lt;/blockquote>
      /// If this call succeeds then all subsequent calls to that smart
      /// contract SHALL fail.&lt;br/>
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.ObsoleteAttribute]
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Hedera.Hashgraph.Proto.TransactionResponse systemDelete(global::Hedera.Hashgraph.Proto.Transaction request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return systemDelete(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      /// Delete a smart contract, as a system-initiated deletion, this
      /// SHALL NOT transfer balances.
      /// &lt;blockquote>
      /// This call is an administrative function of the Hedera network, and
      /// SHALL require network administration authorization.&lt;br/>
      /// This transaction MUST be signed by one of the network administration
      /// accounts (typically `0.0.2` through `0.0.59`, as defined in the
      /// `api-permission.properties` file).
      /// &lt;/blockquote>
      /// If this call succeeds then all subsequent calls to that smart
      /// contract SHALL fail.&lt;br/>
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.ObsoleteAttribute]
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Hedera.Hashgraph.Proto.TransactionResponse systemDelete(global::Hedera.Hashgraph.Proto.Transaction request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_systemDelete, null, options, request);
      }
      /// <summary>
      ///*
      /// Delete a smart contract, as a system-initiated deletion, this
      /// SHALL NOT transfer balances.
      /// &lt;blockquote>
      /// This call is an administrative function of the Hedera network, and
      /// SHALL require network administration authorization.&lt;br/>
      /// This transaction MUST be signed by one of the network administration
      /// accounts (typically `0.0.2` through `0.0.59`, as defined in the
      /// `api-permission.properties` file).
      /// &lt;/blockquote>
      /// If this call succeeds then all subsequent calls to that smart
      /// contract SHALL fail.&lt;br/>
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.ObsoleteAttribute]
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Hedera.Hashgraph.Proto.TransactionResponse> systemDeleteAsync(global::Hedera.Hashgraph.Proto.Transaction request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return systemDeleteAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      /// Delete a smart contract, as a system-initiated deletion, this
      /// SHALL NOT transfer balances.
      /// &lt;blockquote>
      /// This call is an administrative function of the Hedera network, and
      /// SHALL require network administration authorization.&lt;br/>
      /// This transaction MUST be signed by one of the network administration
      /// accounts (typically `0.0.2` through `0.0.59`, as defined in the
      /// `api-permission.properties` file).
      /// &lt;/blockquote>
      /// If this call succeeds then all subsequent calls to that smart
      /// contract SHALL fail.&lt;br/>
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.ObsoleteAttribute]
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Hedera.Hashgraph.Proto.TransactionResponse> systemDeleteAsync(global::Hedera.Hashgraph.Proto.Transaction request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_systemDelete, null, options, request);
      }
      /// <summary>
      ///*
      /// Un-Delete a smart contract, returning it (mostly) to its state
      /// prior to deletion.
      /// &lt;p>
      /// The contract to be restored MUST have been deleted via `systemDelete`.
      /// If the contract was deleted via `deleteContract`, it
      /// SHALL NOT be recoverable.
      /// &lt;blockquote>
      /// This call is an administrative function of the Hedera network, and
      /// SHALL require network administration authorization.&lt;br/>
      /// This transaction MUST be signed by one of the network administration
      /// accounts (typically `0.0.2` through `0.0.59`, as defined in the
      /// `api-permission.properties` file).
      /// &lt;/blockquote>
      /// If this call succeeds then subsequent calls to that smart
      /// contract MAY succeed.&lt;br/>
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.ObsoleteAttribute]
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Hedera.Hashgraph.Proto.TransactionResponse systemUndelete(global::Hedera.Hashgraph.Proto.Transaction request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return systemUndelete(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      /// Un-Delete a smart contract, returning it (mostly) to its state
      /// prior to deletion.
      /// &lt;p>
      /// The contract to be restored MUST have been deleted via `systemDelete`.
      /// If the contract was deleted via `deleteContract`, it
      /// SHALL NOT be recoverable.
      /// &lt;blockquote>
      /// This call is an administrative function of the Hedera network, and
      /// SHALL require network administration authorization.&lt;br/>
      /// This transaction MUST be signed by one of the network administration
      /// accounts (typically `0.0.2` through `0.0.59`, as defined in the
      /// `api-permission.properties` file).
      /// &lt;/blockquote>
      /// If this call succeeds then subsequent calls to that smart
      /// contract MAY succeed.&lt;br/>
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.ObsoleteAttribute]
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Hedera.Hashgraph.Proto.TransactionResponse systemUndelete(global::Hedera.Hashgraph.Proto.Transaction request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_systemUndelete, null, options, request);
      }
      /// <summary>
      ///*
      /// Un-Delete a smart contract, returning it (mostly) to its state
      /// prior to deletion.
      /// &lt;p>
      /// The contract to be restored MUST have been deleted via `systemDelete`.
      /// If the contract was deleted via `deleteContract`, it
      /// SHALL NOT be recoverable.
      /// &lt;blockquote>
      /// This call is an administrative function of the Hedera network, and
      /// SHALL require network administration authorization.&lt;br/>
      /// This transaction MUST be signed by one of the network administration
      /// accounts (typically `0.0.2` through `0.0.59`, as defined in the
      /// `api-permission.properties` file).
      /// &lt;/blockquote>
      /// If this call succeeds then subsequent calls to that smart
      /// contract MAY succeed.&lt;br/>
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.ObsoleteAttribute]
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Hedera.Hashgraph.Proto.TransactionResponse> systemUndeleteAsync(global::Hedera.Hashgraph.Proto.Transaction request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return systemUndeleteAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      /// Un-Delete a smart contract, returning it (mostly) to its state
      /// prior to deletion.
      /// &lt;p>
      /// The contract to be restored MUST have been deleted via `systemDelete`.
      /// If the contract was deleted via `deleteContract`, it
      /// SHALL NOT be recoverable.
      /// &lt;blockquote>
      /// This call is an administrative function of the Hedera network, and
      /// SHALL require network administration authorization.&lt;br/>
      /// This transaction MUST be signed by one of the network administration
      /// accounts (typically `0.0.2` through `0.0.59`, as defined in the
      /// `api-permission.properties` file).
      /// &lt;/blockquote>
      /// If this call succeeds then subsequent calls to that smart
      /// contract MAY succeed.&lt;br/>
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.ObsoleteAttribute]
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Hedera.Hashgraph.Proto.TransactionResponse> systemUndeleteAsync(global::Hedera.Hashgraph.Proto.Transaction request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_systemUndelete, null, options, request);
      }
      /// <summary>
      ///*
      /// Make an Ethereum transaction "call" with all data in Ethereum formats,
      /// including the contract alias.
      /// &lt;p>
      /// Call data MAY be in the transaction, or stored within a "File".&lt;br/>
      /// The caller MAY offer additional gas above what is offered in the call
      /// data, but MAY be charged up to 80% of that value if the amount required
      /// is less than this "floor" amount.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Hedera.Hashgraph.Proto.TransactionResponse callEthereum(global::Hedera.Hashgraph.Proto.Transaction request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return callEthereum(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      /// Make an Ethereum transaction "call" with all data in Ethereum formats,
      /// including the contract alias.
      /// &lt;p>
      /// Call data MAY be in the transaction, or stored within a "File".&lt;br/>
      /// The caller MAY offer additional gas above what is offered in the call
      /// data, but MAY be charged up to 80% of that value if the amount required
      /// is less than this "floor" amount.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Hedera.Hashgraph.Proto.TransactionResponse callEthereum(global::Hedera.Hashgraph.Proto.Transaction request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_callEthereum, null, options, request);
      }
      /// <summary>
      ///*
      /// Make an Ethereum transaction "call" with all data in Ethereum formats,
      /// including the contract alias.
      /// &lt;p>
      /// Call data MAY be in the transaction, or stored within a "File".&lt;br/>
      /// The caller MAY offer additional gas above what is offered in the call
      /// data, but MAY be charged up to 80% of that value if the amount required
      /// is less than this "floor" amount.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Hedera.Hashgraph.Proto.TransactionResponse> callEthereumAsync(global::Hedera.Hashgraph.Proto.Transaction request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return callEthereumAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      /// Make an Ethereum transaction "call" with all data in Ethereum formats,
      /// including the contract alias.
      /// &lt;p>
      /// Call data MAY be in the transaction, or stored within a "File".&lt;br/>
      /// The caller MAY offer additional gas above what is offered in the call
      /// data, but MAY be charged up to 80% of that value if the amount required
      /// is less than this "floor" amount.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Hedera.Hashgraph.Proto.TransactionResponse> callEthereumAsync(global::Hedera.Hashgraph.Proto.Transaction request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_callEthereum, null, options, request);
      }
      /// <summary>
      ///*
      /// Update zero or more slots of a lambda.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Hedera.Hashgraph.Proto.TransactionResponse lambdaSStore(global::Hedera.Hashgraph.Proto.Transaction request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return lambdaSStore(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      /// Update zero or more slots of a lambda.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Hedera.Hashgraph.Proto.TransactionResponse lambdaSStore(global::Hedera.Hashgraph.Proto.Transaction request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_lambdaSStore, null, options, request);
      }
      /// <summary>
      ///*
      /// Update zero or more slots of a lambda.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Hedera.Hashgraph.Proto.TransactionResponse> lambdaSStoreAsync(global::Hedera.Hashgraph.Proto.Transaction request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return lambdaSStoreAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      /// Update zero or more slots of a lambda.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Hedera.Hashgraph.Proto.TransactionResponse> lambdaSStoreAsync(global::Hedera.Hashgraph.Proto.Transaction request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_lambdaSStore, null, options, request);
      }
      /// <summary>Creates a new instance of client from given <c>ClientBaseConfiguration</c>.</summary>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      protected override SmartContractServiceClient NewInstance(ClientBaseConfiguration configuration)
      {
        return new SmartContractServiceClient(configuration);
      }
    }

    /// <summary>Creates service definition that can be registered with a server</summary>
    /// <param name="serviceImpl">An object implementing the server-side handling logic.</param>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public static grpc::ServerServiceDefinition BindService(SmartContractServiceBase serviceImpl)
    {
      return grpc::ServerServiceDefinition.CreateBuilder()
          .AddMethod(__Method_createContract, serviceImpl.createContract)
          .AddMethod(__Method_updateContract, serviceImpl.updateContract)
          .AddMethod(__Method_contractCallMethod, serviceImpl.contractCallMethod)
          .AddMethod(__Method_contractCallLocalMethod, serviceImpl.contractCallLocalMethod)
          .AddMethod(__Method_getContractInfo, serviceImpl.getContractInfo)
          .AddMethod(__Method_ContractGetBytecode, serviceImpl.ContractGetBytecode)
          .AddMethod(__Method_getBySolidityID, serviceImpl.getBySolidityID)
          .AddMethod(__Method_getTxRecordByContractID, serviceImpl.getTxRecordByContractID)
          .AddMethod(__Method_deleteContract, serviceImpl.deleteContract)
          .AddMethod(__Method_systemDelete, serviceImpl.systemDelete)
          .AddMethod(__Method_systemUndelete, serviceImpl.systemUndelete)
          .AddMethod(__Method_callEthereum, serviceImpl.callEthereum)
          .AddMethod(__Method_lambdaSStore, serviceImpl.lambdaSStore).Build();
    }

    /// <summary>Register service method with a service binder with or without implementation. Useful when customizing the service binding logic.
    /// Note: this method is part of an experimental API that can change or be removed without any prior notice.</summary>
    /// <param name="serviceBinder">Service methods will be bound by calling <c>AddMethod</c> on this object.</param>
    /// <param name="serviceImpl">An object implementing the server-side handling logic.</param>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public static void BindService(grpc::ServiceBinderBase serviceBinder, SmartContractServiceBase serviceImpl)
    {
      serviceBinder.AddMethod(__Method_createContract, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse>(serviceImpl.createContract));
      serviceBinder.AddMethod(__Method_updateContract, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse>(serviceImpl.updateContract));
      serviceBinder.AddMethod(__Method_contractCallMethod, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse>(serviceImpl.contractCallMethod));
      serviceBinder.AddMethod(__Method_contractCallLocalMethod, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::Hedera.Hashgraph.Proto.Query, global::Hedera.Hashgraph.Proto.Response>(serviceImpl.contractCallLocalMethod));
      serviceBinder.AddMethod(__Method_getContractInfo, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::Hedera.Hashgraph.Proto.Query, global::Hedera.Hashgraph.Proto.Response>(serviceImpl.getContractInfo));
      serviceBinder.AddMethod(__Method_ContractGetBytecode, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::Hedera.Hashgraph.Proto.Query, global::Hedera.Hashgraph.Proto.Response>(serviceImpl.ContractGetBytecode));
      serviceBinder.AddMethod(__Method_getBySolidityID, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::Hedera.Hashgraph.Proto.Query, global::Hedera.Hashgraph.Proto.Response>(serviceImpl.getBySolidityID));
      serviceBinder.AddMethod(__Method_getTxRecordByContractID, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::Hedera.Hashgraph.Proto.Query, global::Hedera.Hashgraph.Proto.Response>(serviceImpl.getTxRecordByContractID));
      serviceBinder.AddMethod(__Method_deleteContract, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse>(serviceImpl.deleteContract));
      serviceBinder.AddMethod(__Method_systemDelete, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse>(serviceImpl.systemDelete));
      serviceBinder.AddMethod(__Method_systemUndelete, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse>(serviceImpl.systemUndelete));
      serviceBinder.AddMethod(__Method_callEthereum, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse>(serviceImpl.callEthereum));
      serviceBinder.AddMethod(__Method_lambdaSStore, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse>(serviceImpl.lambdaSStore));
    }

  }
}
#endregion
