// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: account.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021, 8981
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Proto {

  /// <summary>Holder for reflection information generated from account.proto</summary>
  public static partial class AccountReflection {

    #region Descriptor
    /// <summary>File descriptor for account.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static AccountReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "Cg1hY2NvdW50LnByb3RvEgVwcm90bxoRYmFzaWNfdHlwZXMucHJvdG8ioQoK",
            "B0FjY291bnQSJAoKYWNjb3VudF9pZBgBIAEoCzIQLnByb3RvLkFjY291bnRJ",
            "RBINCgVhbGlhcxgCIAEoDBIXCgNrZXkYAyABKAsyCi5wcm90by5LZXkSGQoR",
            "ZXhwaXJhdGlvbl9zZWNvbmQYBCABKAMSFwoPdGlueWJhcl9iYWxhbmNlGAUg",
            "ASgDEgwKBG1lbW8YBiABKAkSDwoHZGVsZXRlZBgHIAEoCBIUCgxzdGFrZWRf",
            "dG9fbWUYCCABKAMSGgoSc3Rha2VfcGVyaW9kX3N0YXJ0GAkgASgDEi0KEXN0",
            "YWtlZF9hY2NvdW50X2lkGAogASgLMhAucHJvdG8uQWNjb3VudElESAASGAoO",
            "c3Rha2VkX25vZGVfaWQYCyABKANIABIWCg5kZWNsaW5lX3Jld2FyZBgMIAEo",
            "CBIdChVyZWNlaXZlcl9zaWdfcmVxdWlyZWQYDSABKAgSJQoNaGVhZF90b2tl",
            "bl9pZBgOIAEoCzIOLnByb3RvLlRva2VuSUQSIQoLaGVhZF9uZnRfaWQYDyAB",
            "KAsyDC5wcm90by5OZnRJRBIeChZoZWFkX25mdF9zZXJpYWxfbnVtYmVyGBAg",
            "ASgDEhkKEW51bWJlcl9vd25lZF9uZnRzGBEgASgDEh0KFW1heF9hdXRvX2Fz",
            "c29jaWF0aW9ucxgSIAEoBRIeChZ1c2VkX2F1dG9fYXNzb2NpYXRpb25zGBMg",
            "ASgFEhsKE251bWJlcl9hc3NvY2lhdGlvbnMYFCABKAUSFgoOc21hcnRfY29u",
            "dHJhY3QYFSABKAgSIAoYbnVtYmVyX3Bvc2l0aXZlX2JhbGFuY2VzGBYgASgF",
            "EhYKDmV0aGVyZXVtX25vbmNlGBcgASgDEi4KJnN0YWtlX2F0X3N0YXJ0X29m",
            "X2xhc3RfcmV3YXJkZWRfcGVyaW9kGBggASgDEi8KFWF1dG9fcmVuZXdfYWNj",
            "b3VudF9pZBgZIAEoCzIQLnByb3RvLkFjY291bnRJRBIaChJhdXRvX3JlbmV3",
            "X3NlY29uZHMYGiABKAMSIAoYY29udHJhY3Rfa3ZfcGFpcnNfbnVtYmVyGBsg",
            "ASgFEjgKEWNyeXB0b19hbGxvd2FuY2VzGBwgAygLMh0ucHJvdG8uQWNjb3Vu",
            "dENyeXB0b0FsbG93YW5jZRJNCh5hcHByb3ZlX2Zvcl9hbGxfbmZ0X2FsbG93",
            "YW5jZXMYHSADKAsyJS5wcm90by5BY2NvdW50QXBwcm92YWxGb3JBbGxBbGxv",
            "d2FuY2USPgoQdG9rZW5fYWxsb3dhbmNlcxgeIAMoCzIkLnByb3RvLkFjY291",
            "bnRGdW5naWJsZVRva2VuQWxsb3dhbmNlEh4KFm51bWJlcl90cmVhc3VyeV90",
            "aXRsZXMYHyABKA0SIwobZXhwaXJlZF9hbmRfcGVuZGluZ19yZW1vdmFsGCAg",
            "ASgIEiIKGmZpcnN0X2NvbnRyYWN0X3N0b3JhZ2Vfa2V5GCEgASgMEjgKF2hl",
            "YWRfcGVuZGluZ19haXJkcm9wX2lkGCIgASgLMhcucHJvdG8uUGVuZGluZ0Fp",
            "cmRyb3BJZBIfChdudW1iZXJfcGVuZGluZ19haXJkcm9wcxgjIAEoBBIbChNu",
            "dW1iZXJfaG9va3NfaW5fdXNlGCQgASgEEhUKDWZpcnN0X2hvb2tfaWQYJSAB",
            "KAMSIwobbnVtYmVyX2xhbWJkYV9zdG9yYWdlX3Nsb3RzGCYgASgEQgsKCXN0",
            "YWtlZF9pZCJoCh5BY2NvdW50QXBwcm92YWxGb3JBbGxBbGxvd2FuY2USIAoI",
            "dG9rZW5faWQYASABKAsyDi5wcm90by5Ub2tlbklEEiQKCnNwZW5kZXJfaWQY",
            "AiABKAsyEC5wcm90by5BY2NvdW50SUQidwodQWNjb3VudEZ1bmdpYmxlVG9r",
            "ZW5BbGxvd2FuY2USIAoIdG9rZW5faWQYASABKAsyDi5wcm90by5Ub2tlbklE",
            "EiQKCnNwZW5kZXJfaWQYAiABKAsyEC5wcm90by5BY2NvdW50SUQSDgoGYW1v",
            "dW50GAMgASgDIk4KFkFjY291bnRDcnlwdG9BbGxvd2FuY2USJAoKc3BlbmRl",
            "cl9pZBgBIAEoCzIQLnByb3RvLkFjY291bnRJRBIOCgZhbW91bnQYAiABKANC",
            "IgoeY29tLmhlZGVyYS5oYXNoZ3JhcGguc2RrLnByb3RvUAFiBnByb3RvMw=="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Proto.BasicTypesReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Proto.Account), global::Proto.Account.Parser, new[]{ "AccountId", "Alias", "Key", "ExpirationSecond", "TinybarBalance", "Memo", "Deleted", "StakedToMe", "StakePeriodStart", "StakedAccountId", "StakedNodeId", "DeclineReward", "ReceiverSigRequired", "HeadTokenId", "HeadNftId", "HeadNftSerialNumber", "NumberOwnedNfts", "MaxAutoAssociations", "UsedAutoAssociations", "NumberAssociations", "SmartContract", "NumberPositiveBalances", "EthereumNonce", "StakeAtStartOfLastRewardedPeriod", "AutoRenewAccountId", "AutoRenewSeconds", "ContractKvPairsNumber", "CryptoAllowances", "ApproveForAllNftAllowances", "TokenAllowances", "NumberTreasuryTitles", "ExpiredAndPendingRemoval", "FirstContractStorageKey", "HeadPendingAirdropId", "NumberPendingAirdrops", "NumberHooksInUse", "FirstHookId", "NumberLambdaStorageSlots" }, new[]{ "StakedId" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Proto.AccountApprovalForAllAllowance), global::Proto.AccountApprovalForAllAllowance.Parser, new[]{ "TokenId", "SpenderId" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Proto.AccountFungibleTokenAllowance), global::Proto.AccountFungibleTokenAllowance.Parser, new[]{ "TokenId", "SpenderId", "Amount" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Proto.AccountCryptoAllowance), global::Proto.AccountCryptoAllowance.Parser, new[]{ "SpenderId", "Amount" }, null, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  ///*
  /// A single Account in the Hedera distributed ledger.
  ///
  /// Each Account SHALL have a unique three-part identifier, a Key, and one
  /// or more token balances.&lt;br/>
  /// Each Account SHALL have an alias, which has multiple forms, and MAY be set automatically.&lt;br/>
  /// Several additional items SHALL be associated with the Account to enable
  /// full functionality.&lt;br/>
  /// Assets SHALL be represented as linked-lists with only the "head" item
  /// referenced directly in the Account, and the remaining items SHALL be
  /// accessible via the token relation or unique tokens maps.&lt;br/>
  /// Accounts, as most items in the network, SHALL have an expiration time,
  /// recorded as seconds since the epoch, and MUST be "renewed" for a small fee
  /// at expiration. This helps to reduce the amount of inactive accounts retained
  /// in state.&lt;br/>
  /// Another account MAY be designated to pay any renewal fees and automatically
  /// renew an account for (by default) 30-90 days at a time as a means to
  /// optionally ensure important accounts remain active.&lt;br/>
  /// Accounts MAY participate in securing the network by "staking" the account
  /// balances to a particular network node, and receive a portion of network
  /// fees as a reward. An account MAY optionally decline these rewards but still
  /// stake its balances.&lt;br/>
  /// An account MAY optionally require that inbound transfer transactions be
  /// signed by that account as receiver
  /// (in addition to the sender's signature).&lt;br/>
  /// As with all network entities, Account ID SHALL be represented as
  /// shard.realm.X.&lt;br/>
  /// Alias and contractId SHALL be additional identifiers used to connect accounts
  /// to transactions before the account is fully enabled,
  /// or in EVM contracts.&lt;br/>
  ///
  /// ---
  ///
  /// #### Alias
  /// There is considerable complexity with `alias` (aka `evm_address`) for
  /// Accounts. Much of this comes from the existence of a "hidden" alias for
  /// almost all accounts, and the reuse of the alias field for both EVM reference
  /// and "automatic" account creation.
  ///
  /// For the purposes of this specification, we will use the following terms for
  /// clarity.
  ///   - `key_alias` is the account public key as a protobuf serialized message
  ///     and used for auto-creation and subsequent lookup. This is only valid if
  ///     the account key is a
  ///     single `primitive` key, either ED25519 or ECDSA_SECP256K1.
  ///   - `evm_address` exists for every account and is one of
  ///      - `contract_address`, which is the 20 byte EVM contract address per
  ///        EIP-1014
  ///      - `evm_key_address`, which is the keccak-256 hash of a ECDSA_SECP256K1
  ///        `primitive` key.
  ///         - This is for accounts lazy-created from EVM public keys, when the
  ///           corresponding ECDSA_SECP256K1 public key is presented in a
  ///           transaction signed by the private key for that public key, the
  ///           account is created that key assigned, and the protobuf-serialized
  ///           form is set as the account alias.
  ///      - `long_zero`, is a synthetic 20 byte address inferred for "normally"
  ///        created accounts. It is constructed from the "standard" AccountID as
  ///        follows.
  ///         - 4 byte big-endian shard number
  ///         - 8 byte big-endian realm number
  ///         - 8 byte big-endian entity number
  ///
  /// The `alias` field in the `Account` message SHALL contain one of four values
  /// for any given account.
  ///   - The `key_alias`, if the account was created by transferring HBAR to the
  ///     account referenced by `key_alias`.
  ///   - The `evm_key_address` if the account was created from an EVM public key
  ///   - The `contract_address` if the account belongs to an EVM contract
  ///   - Not-Set/null/Bytes.EMPTY (collectively `null`) if the account was
  ///     created normally
  ///
  /// If the `alias` field of an `Account` is any form of `null`, then the account
  /// MAY be referenced by `alias` in an `AccountID` by using the `long_zero`
  /// address for the account. This "hidden default" alias SHALL NOT be stored,
  /// but is synthesized by the node software as needed, and may be synthesized by
  /// an EVM contract or client software as well.
  ///
  /// An AccountID in a transaction MAY reference an `Account` with
  /// `shard`.`realm`.`alias`.&lt;br/>
  /// If the account `alias` field is set for an Account, that value SHALL be the
  /// account alias.&lt;br/>
  /// If the account `alias` field is not set for an Account, the `long_zero`
  /// alias SHALL be the account alias.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class Account : pb::IMessage<Account>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Account> _parser = new pb::MessageParser<Account>(() => new Account());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Account> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Proto.AccountReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Account() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Account(Account other) : this() {
      accountId_ = other.accountId_ != null ? other.accountId_.Clone() : null;
      alias_ = other.alias_;
      key_ = other.key_ != null ? other.key_.Clone() : null;
      expirationSecond_ = other.expirationSecond_;
      tinybarBalance_ = other.tinybarBalance_;
      memo_ = other.memo_;
      deleted_ = other.deleted_;
      stakedToMe_ = other.stakedToMe_;
      stakePeriodStart_ = other.stakePeriodStart_;
      declineReward_ = other.declineReward_;
      receiverSigRequired_ = other.receiverSigRequired_;
      headTokenId_ = other.headTokenId_ != null ? other.headTokenId_.Clone() : null;
      headNftId_ = other.headNftId_ != null ? other.headNftId_.Clone() : null;
      headNftSerialNumber_ = other.headNftSerialNumber_;
      numberOwnedNfts_ = other.numberOwnedNfts_;
      maxAutoAssociations_ = other.maxAutoAssociations_;
      usedAutoAssociations_ = other.usedAutoAssociations_;
      numberAssociations_ = other.numberAssociations_;
      smartContract_ = other.smartContract_;
      numberPositiveBalances_ = other.numberPositiveBalances_;
      ethereumNonce_ = other.ethereumNonce_;
      stakeAtStartOfLastRewardedPeriod_ = other.stakeAtStartOfLastRewardedPeriod_;
      autoRenewAccountId_ = other.autoRenewAccountId_ != null ? other.autoRenewAccountId_.Clone() : null;
      autoRenewSeconds_ = other.autoRenewSeconds_;
      contractKvPairsNumber_ = other.contractKvPairsNumber_;
      cryptoAllowances_ = other.cryptoAllowances_.Clone();
      approveForAllNftAllowances_ = other.approveForAllNftAllowances_.Clone();
      tokenAllowances_ = other.tokenAllowances_.Clone();
      numberTreasuryTitles_ = other.numberTreasuryTitles_;
      expiredAndPendingRemoval_ = other.expiredAndPendingRemoval_;
      firstContractStorageKey_ = other.firstContractStorageKey_;
      headPendingAirdropId_ = other.headPendingAirdropId_ != null ? other.headPendingAirdropId_.Clone() : null;
      numberPendingAirdrops_ = other.numberPendingAirdrops_;
      numberHooksInUse_ = other.numberHooksInUse_;
      firstHookId_ = other.firstHookId_;
      numberLambdaStorageSlots_ = other.numberLambdaStorageSlots_;
      switch (other.StakedIdCase) {
        case StakedIdOneofCase.StakedAccountId:
          StakedAccountId = other.StakedAccountId.Clone();
          break;
        case StakedIdOneofCase.StakedNodeId:
          StakedNodeId = other.StakedNodeId;
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Account Clone() {
      return new Account(this);
    }

    /// <summary>Field number for the "account_id" field.</summary>
    public const int AccountIdFieldNumber = 1;
    private global::Proto.AccountID accountId_;
    /// <summary>
    ///*
    /// The unique ID of this account.
    /// &lt;p>
    /// An account ID, when assigned to this field, SHALL be of
    /// the form `shard.realm.number`.&lt;br/>
    /// Transactions MAY reference the account by alias, but the account itself
    /// MUST always have a purely numeric identifier. This numeric ID is the
    /// value used to reference the account in query responses, transaction
    /// receipts, transaction records, and the block stream.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.AccountID AccountId {
      get { return accountId_; }
      set {
        accountId_ = value;
      }
    }

    /// <summary>Field number for the "alias" field.</summary>
    public const int AliasFieldNumber = 2;
    private pb::ByteString alias_ = pb::ByteString.Empty;
    /// <summary>
    ///*
    /// An account EVM alias.
    /// &lt;p>
    /// This is a value used in some contexts to reference an account when the
    /// numeric account identifier is not available.&lt;br/>
    /// This field, when set to a non-default value, is immutable and
    /// SHALL NOT be changed.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString Alias {
      get { return alias_; }
      set {
        alias_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "key" field.</summary>
    public const int KeyFieldNumber = 3;
    private global::Proto.Key key_;
    /// <summary>
    ///*
    /// The key to be used to sign transactions from this account, if any.
    /// &lt;p>
    /// This key SHALL NOT be set for hollow accounts until the account
    /// is finalized.&lt;br/>
    /// This key SHALL be set on all other accounts, except for certain
    /// immutable accounts (0.0.800 and 0.0.801) necessary for network function
    /// and otherwise secured by the governing council.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.Key Key {
      get { return key_; }
      set {
        key_ = value;
      }
    }

    /// <summary>Field number for the "expiration_second" field.</summary>
    public const int ExpirationSecondFieldNumber = 4;
    private long expirationSecond_;
    /// <summary>
    ///*
    /// The current expiration time of this account, in seconds since the epoch.
    /// &lt;p>
    /// For this purpose, `epoch` SHALL be the UNIX epoch
    /// with 0 at `1970-01-01T00:00:00.000Z`.&lt;br/>
    /// This account SHALL be due standard renewal fees when the network
    /// consensus time exceeds this time.&lt;br/>
    /// If rent and expiration are enabled for the network, and automatic
    /// renewal is enabled for this account, renewal fees SHALL be charged
    /// after this time, and, if charged, the expiration time SHALL be
    /// extended for another renewal period.&lt;br/>
    /// This account MAY be expired and removed from state at any point
    /// after this time if not renewed.&lt;br/>
    /// An account holder MAY extend this time by submitting an account
    /// update transaction to modify expiration time, subject to the current
    /// maximum expiration time for the network.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long ExpirationSecond {
      get { return expirationSecond_; }
      set {
        expirationSecond_ = value;
      }
    }

    /// <summary>Field number for the "tinybar_balance" field.</summary>
    public const int TinybarBalanceFieldNumber = 5;
    private long tinybarBalance_;
    /// <summary>
    ///*
    /// The HBAR balance of this account, in tinybar (10&lt;sup>-8&lt;/sup> HBAR).
    /// &lt;p>
    /// This value is a signed integer for efficiency, but MUST always
    /// be a whole number.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long TinybarBalance {
      get { return tinybarBalance_; }
      set {
        tinybarBalance_ = value;
      }
    }

    /// <summary>Field number for the "memo" field.</summary>
    public const int MemoFieldNumber = 6;
    private string memo_ = "";
    /// <summary>
    ///*
    /// A short description of this account.
    /// &lt;p>
    /// This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
    /// (default 100) bytes when encoded as UTF-8.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Memo {
      get { return memo_; }
      set {
        memo_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "deleted" field.</summary>
    public const int DeletedFieldNumber = 7;
    private bool deleted_;
    /// <summary>
    ///*
    /// A bool indicating that this account is deleted.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Deleted {
      get { return deleted_; }
      set {
        deleted_ = value;
      }
    }

    /// <summary>Field number for the "staked_to_me" field.</summary>
    public const int StakedToMeFieldNumber = 8;
    private long stakedToMe_;
    /// <summary>
    ///*
    /// The amount of HBAR staked to this account by others.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long StakedToMe {
      get { return stakedToMe_; }
      set {
        stakedToMe_ = value;
      }
    }

    /// <summary>Field number for the "stake_period_start" field.</summary>
    public const int StakePeriodStartFieldNumber = 9;
    private long stakePeriodStart_;
    /// <summary>
    ///*
    /// If this account stakes to another account, this value SHALL be set to
    /// the time when the current period for staking and reward
    /// calculations began.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long StakePeriodStart {
      get { return stakePeriodStart_; }
      set {
        stakePeriodStart_ = value;
      }
    }

    /// <summary>Field number for the "staked_account_id" field.</summary>
    public const int StakedAccountIdFieldNumber = 10;
    /// <summary>
    ///*
    /// An identifier for the account to which this account is
    /// staking its balances as a proxy.
    /// &lt;p>
    /// If this account is not currently staking its balances, then this
    /// field, if set, SHALL be the sentinel value of `0.0.0`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.AccountID StakedAccountId {
      get { return stakedIdCase_ == StakedIdOneofCase.StakedAccountId ? (global::Proto.AccountID) stakedId_ : null; }
      set {
        stakedId_ = value;
        stakedIdCase_ = value == null ? StakedIdOneofCase.None : StakedIdOneofCase.StakedAccountId;
      }
    }

    /// <summary>Field number for the "staked_node_id" field.</summary>
    public const int StakedNodeIdFieldNumber = 11;
    /// <summary>
    ///*
    /// An identifier for the node this account is staked to.
    /// &lt;p>
    /// If this account is not currently staking its balances, then this
    /// field, if set, SHALL be the sentinel value of `-1`.
    /// Wallet software SHOULD surface staking issues to users and provide a
    /// simple mechanism to update staking to a new node ID in the event the
    /// prior staked node ID ceases to be valid.
    /// &lt;p>
    /// &lt;blockquote>Note: node IDs do fluctuate as node operators change.
    /// The Account owner MUST submit a new transaction to change this value
    /// if the current node ID changes or ceases to operate as a node. An
    /// account with an invalid `staked_node_id` SHALL NOT participate in
    /// staking until the `staked_node_id` is updated to a valid node ID.
    /// &lt;/blockquote>
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long StakedNodeId {
      get { return HasStakedNodeId ? (long) stakedId_ : 0L; }
      set {
        stakedId_ = value;
        stakedIdCase_ = StakedIdOneofCase.StakedNodeId;
      }
    }
    /// <summary>Gets whether the "staked_node_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasStakedNodeId {
      get { return stakedIdCase_ == StakedIdOneofCase.StakedNodeId; }
    }
    /// <summary> Clears the value of the oneof if it's currently set to "staked_node_id" </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearStakedNodeId() {
      if (HasStakedNodeId) {
        ClearStakedId();
      }
    }

    /// <summary>Field number for the "decline_reward" field.</summary>
    public const int DeclineRewardFieldNumber = 12;
    private bool declineReward_;
    /// <summary>
    ///*
    /// A bool indicating that this account has chosen to decline rewards for
    /// staking its balances.
    /// &lt;p>
    /// This account MAY still stake its balances, but SHALL NOT receive reward
    /// payments for doing so.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool DeclineReward {
      get { return declineReward_; }
      set {
        declineReward_ = value;
      }
    }

    /// <summary>Field number for the "receiver_sig_required" field.</summary>
    public const int ReceiverSigRequiredFieldNumber = 13;
    private bool receiverSigRequired_;
    /// <summary>
    ///*
    /// A bool indicating that the account requires a receiver signature for
    /// inbound token transfer transactions.
    /// &lt;p>
    /// If this value is `true` then a transaction to transfer tokens to this
    /// account SHALL NOT succeed unless this account has signed the transfer
    /// transaction.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool ReceiverSigRequired {
      get { return receiverSigRequired_; }
      set {
        receiverSigRequired_ = value;
      }
    }

    /// <summary>Field number for the "head_token_id" field.</summary>
    public const int HeadTokenIdFieldNumber = 14;
    private global::Proto.TokenID headTokenId_;
    /// <summary>
    ///*
    /// A token ID at the head of the linked list for this account from the
    /// token relations map.&lt;br/>
    /// The token relations are connected by including the "next" and "previous"
    /// TokenID in each TokenRelation message. The "head" item in that list is
    /// found by looking up the TokenRelation with this Account's account_id and
    /// this head_token_id. Each subsequent item in the list is found via
    /// similar lookup with both an AccountID and a TokenID.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.TokenID HeadTokenId {
      get { return headTokenId_; }
      set {
        headTokenId_ = value;
      }
    }

    /// <summary>Field number for the "head_nft_id" field.</summary>
    public const int HeadNftIdFieldNumber = 15;
    private global::Proto.NftID headNftId_;
    /// <summary>
    ///*
    /// A NftID at the head of the linked list for this account from
    /// the unique tokens map.&lt;br/>
    /// The unique token relations are connected by including the "next" and
    /// "previous" NftID in each Nft message. The "head" item in that list is
    /// found by looking up the Nft with ID matching this head_nft_id. Each
    /// subsequent item in the list is found via similar lookup with the next
    /// or previous NftID.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.NftID HeadNftId {
      get { return headNftId_; }
      set {
        headNftId_ = value;
      }
    }

    /// <summary>Field number for the "head_nft_serial_number" field.</summary>
    public const int HeadNftSerialNumberFieldNumber = 16;
    private long headNftSerialNumber_;
    /// <summary>
    ///*
    /// A serial number in the NftID at the head of the linked list for this
    /// account from unique tokens map.
    /// &lt;p>
    /// This MUST match the `serial_number` field of `head_nft_id`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long HeadNftSerialNumber {
      get { return headNftSerialNumber_; }
      set {
        headNftSerialNumber_ = value;
      }
    }

    /// <summary>Field number for the "number_owned_nfts" field.</summary>
    public const int NumberOwnedNftsFieldNumber = 17;
    private long numberOwnedNfts_;
    /// <summary>
    ///*
    /// A number of non-fungible tokens (NTFs) owned by the account.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long NumberOwnedNfts {
      get { return numberOwnedNfts_; }
      set {
        numberOwnedNfts_ = value;
      }
    }

    /// <summary>Field number for the "max_auto_associations" field.</summary>
    public const int MaxAutoAssociationsFieldNumber = 18;
    private int maxAutoAssociations_;
    /// <summary>
    ///*
    /// A maximum for the number of tokens that can be automatically
    /// associated with this account.
    /// &lt;p>
    /// If this is less than or equal to `used_auto_associations` (or 0), then
    /// this account MUST manually associate with a token before transacting in
    /// that token.&lt;br/>
    /// This value may also be `-1` to indicate no limit.&lt;br/>
    /// This value MUST NOT be less than `-1`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int MaxAutoAssociations {
      get { return maxAutoAssociations_; }
      set {
        maxAutoAssociations_ = value;
      }
    }

    /// <summary>Field number for the "used_auto_associations" field.</summary>
    public const int UsedAutoAssociationsFieldNumber = 19;
    private int usedAutoAssociations_;
    /// <summary>
    ///*
    /// A count of used auto-association slots.
    /// &lt;p>
    /// If this is greater than, or equal to, the current value of
    /// `max_auto_associations`, then this account MUST manually associate with
    /// a new token before transacting in that token.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int UsedAutoAssociations {
      get { return usedAutoAssociations_; }
      set {
        usedAutoAssociations_ = value;
      }
    }

    /// <summary>Field number for the "number_associations" field.</summary>
    public const int NumberAssociationsFieldNumber = 20;
    private int numberAssociations_;
    /// <summary>
    ///*
    /// A count of tokens associated with this account.
    /// &lt;p>
    /// This value determines a portion of the renewal fee for this account.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int NumberAssociations {
      get { return numberAssociations_; }
      set {
        numberAssociations_ = value;
      }
    }

    /// <summary>Field number for the "smart_contract" field.</summary>
    public const int SmartContractFieldNumber = 21;
    private bool smartContract_;
    /// <summary>
    ///*
    /// A bool indicating that this account is owned by a smart contract.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool SmartContract {
      get { return smartContract_; }
      set {
        smartContract_ = value;
      }
    }

    /// <summary>Field number for the "number_positive_balances" field.</summary>
    public const int NumberPositiveBalancesFieldNumber = 22;
    private int numberPositiveBalances_;
    /// <summary>
    ///*
    /// A count of tokens with a positive balance associated with this account.
    /// &lt;p>
    /// If the account has a positive balance in any token,
    /// it SHALL NOT be deleted.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int NumberPositiveBalances {
      get { return numberPositiveBalances_; }
      set {
        numberPositiveBalances_ = value;
      }
    }

    /// <summary>Field number for the "ethereum_nonce" field.</summary>
    public const int EthereumNonceFieldNumber = 23;
    private long ethereumNonce_;
    /// <summary>
    ///*
    /// A nonce of this account for Ethereum interoperability.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long EthereumNonce {
      get { return ethereumNonce_; }
      set {
        ethereumNonce_ = value;
      }
    }

    /// <summary>Field number for the "stake_at_start_of_last_rewarded_period" field.</summary>
    public const int StakeAtStartOfLastRewardedPeriodFieldNumber = 24;
    private long stakeAtStartOfLastRewardedPeriod_;
    /// <summary>
    ///*
    /// An amount of HBAR staked by this account at the start of
    /// the last reward period.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long StakeAtStartOfLastRewardedPeriod {
      get { return stakeAtStartOfLastRewardedPeriod_; }
      set {
        stakeAtStartOfLastRewardedPeriod_ = value;
      }
    }

    /// <summary>Field number for the "auto_renew_account_id" field.</summary>
    public const int AutoRenewAccountIdFieldNumber = 25;
    private global::Proto.AccountID autoRenewAccountId_;
    /// <summary>
    ///*
    /// An account identifier for automatic renewal.&lt;br/>
    /// This is the identifier of another account, in the same shard and
    /// realm as this account, that has signed a transaction allowing the
    /// network to use its balance, if needed, to automatically extend this
    /// account's expiration time during automatic renewal processing.
    /// &lt;p>
    /// If this is set, and this account lack sufficient HBAR balance to pay
    /// renewal fees when due, then the network SHALL deduct the necessary fees
    /// from the designated auto renew account, if that account has sufficient
    /// balance.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.AccountID AutoRenewAccountId {
      get { return autoRenewAccountId_; }
      set {
        autoRenewAccountId_ = value;
      }
    }

    /// <summary>Field number for the "auto_renew_seconds" field.</summary>
    public const int AutoRenewSecondsFieldNumber = 26;
    private long autoRenewSeconds_;
    /// <summary>
    ///*
    /// A count of the number of seconds to extend this account's expiration.
    /// &lt;p>
    /// The network SHALL extend the account's expiration by this number of
    /// seconds, if funds are available, upon automatic renewal.&lt;br/>
    /// This SHALL NOT apply if the account is already deleted
    /// upon expiration.&lt;br/>
    /// If this is not provided in an allowed range on account creation, the
    /// transaction SHALL fail with INVALID_AUTO_RENEWAL_PERIOD. The default
    /// values for the minimum period and maximum period are currently 30 days
    /// and 90 days, respectively.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long AutoRenewSeconds {
      get { return autoRenewSeconds_; }
      set {
        autoRenewSeconds_ = value;
      }
    }

    /// <summary>Field number for the "contract_kv_pairs_number" field.</summary>
    public const int ContractKvPairsNumberFieldNumber = 27;
    private int contractKvPairsNumber_;
    /// <summary>
    ///*
    /// A count of smart contract key-value pairs.&lt;br/>
    /// If this account is a smart-contract, this is the number of key-value
    /// pairs stored on the contract.
    /// &lt;p>
    /// If this account is not a smart contract, this field
    /// SHALL NOT be used.&lt;br/>
    /// This value SHALL determine a portion of the storage rental
    ///fees for the contract.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int ContractKvPairsNumber {
      get { return contractKvPairsNumber_; }
      set {
        contractKvPairsNumber_ = value;
      }
    }

    /// <summary>Field number for the "crypto_allowances" field.</summary>
    public const int CryptoAllowancesFieldNumber = 28;
    private static readonly pb::FieldCodec<global::Proto.AccountCryptoAllowance> _repeated_cryptoAllowances_codec
        = pb::FieldCodec.ForMessage(226, global::Proto.AccountCryptoAllowance.Parser);
    private readonly pbc::RepeatedField<global::Proto.AccountCryptoAllowance> cryptoAllowances_ = new pbc::RepeatedField<global::Proto.AccountCryptoAllowance>();
    /// <summary>
    ///*
    /// A list of crypto (HBAR) allowances approved by this account.
    /// &lt;p>
    /// If this is not empty, each allowance SHALL permit a specified "spender"
    /// account to spend this account's HBAR balance, up to a designated
    /// limit.&lt;br/>
    /// This field SHALL permit spending only HBAR balance, not other tokens the
    /// account may hold. Allowances for other tokens SHALL be listed in the
    /// `token_allowances` field or the `approve_for_all_nft_allowances` field.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Proto.AccountCryptoAllowance> CryptoAllowances {
      get { return cryptoAllowances_; }
    }

    /// <summary>Field number for the "approve_for_all_nft_allowances" field.</summary>
    public const int ApproveForAllNftAllowancesFieldNumber = 29;
    private static readonly pb::FieldCodec<global::Proto.AccountApprovalForAllAllowance> _repeated_approveForAllNftAllowances_codec
        = pb::FieldCodec.ForMessage(234, global::Proto.AccountApprovalForAllAllowance.Parser);
    private readonly pbc::RepeatedField<global::Proto.AccountApprovalForAllAllowance> approveForAllNftAllowances_ = new pbc::RepeatedField<global::Proto.AccountApprovalForAllAllowance>();
    /// <summary>
    ///*
    /// A list of non-fungible token (NFT) allowances approved by this account.
    /// &lt;p>
    /// If this is not empty, each allowance permits a specified "spender"
    /// account to transfer _all_ of this account's non-fungible tokens from a
    /// particular collection.&lt;br/>
    /// Allowances for a specific serial number MUST be directly associated with
    /// that specific non-fungible token, rather than the holding account.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Proto.AccountApprovalForAllAllowance> ApproveForAllNftAllowances {
      get { return approveForAllNftAllowances_; }
    }

    /// <summary>Field number for the "token_allowances" field.</summary>
    public const int TokenAllowancesFieldNumber = 30;
    private static readonly pb::FieldCodec<global::Proto.AccountFungibleTokenAllowance> _repeated_tokenAllowances_codec
        = pb::FieldCodec.ForMessage(242, global::Proto.AccountFungibleTokenAllowance.Parser);
    private readonly pbc::RepeatedField<global::Proto.AccountFungibleTokenAllowance> tokenAllowances_ = new pbc::RepeatedField<global::Proto.AccountFungibleTokenAllowance>();
    /// <summary>
    ///*
    /// A list of fungible token allowances approved by this account.
    /// &lt;p>
    /// If this is not empty, each allowance permits a specified "spender" to
    /// spend this account's fungible tokens, of the designated type, up to a
    /// designated limit.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Proto.AccountFungibleTokenAllowance> TokenAllowances {
      get { return tokenAllowances_; }
    }

    /// <summary>Field number for the "number_treasury_titles" field.</summary>
    public const int NumberTreasuryTitlesFieldNumber = 31;
    private uint numberTreasuryTitles_;
    /// <summary>
    ///*
    /// A count of tokens for which this account is the treasury account.
    /// &lt;p>
    /// Each native token is initially created with all tokens held by its
    /// treasury, and the owner of that account (which may be a smart contract)
    /// determines how those tokens are distributed.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint NumberTreasuryTitles {
      get { return numberTreasuryTitles_; }
      set {
        numberTreasuryTitles_ = value;
      }
    }

    /// <summary>Field number for the "expired_and_pending_removal" field.</summary>
    public const int ExpiredAndPendingRemovalFieldNumber = 32;
    private bool expiredAndPendingRemoval_;
    /// <summary>
    ///*
    /// A flag indicating that the account is expired and pending removal.
    /// &lt;p>
    /// When the network checks for entity expiration, it SHALL set this flag if
    /// the account expiration time has past and the account has no HBAR
    /// sufficient to pay current renewal fees.&lt;br/>
    /// If the account has an auto-renew account set with an HBAR balance that
    /// could pay for an auto-renewal, then this flag SHALL NOT be set. This
    /// ensures the account is not encumbered during the time between expiration
    /// and when the auto-renewal processing renews the account.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool ExpiredAndPendingRemoval {
      get { return expiredAndPendingRemoval_; }
      set {
        expiredAndPendingRemoval_ = value;
      }
    }

    /// <summary>Field number for the "first_contract_storage_key" field.</summary>
    public const int FirstContractStorageKeyFieldNumber = 33;
    private pb::ByteString firstContractStorageKey_ = pb::ByteString.Empty;
    /// <summary>
    ///*
    /// A contract storage key.&lt;br/>
    /// This is the first key in the doubly-linked list of this
    /// contract's storage mappings.
    /// &lt;p>
    /// This value SHALL be empty if the account is not a contract or the
    /// contract has no storage mappings.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString FirstContractStorageKey {
      get { return firstContractStorageKey_; }
      set {
        firstContractStorageKey_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "head_pending_airdrop_id" field.</summary>
    public const int HeadPendingAirdropIdFieldNumber = 34;
    private global::Proto.PendingAirdropId headPendingAirdropId_;
    /// <summary>
    ///*
    /// A pending airdrop ID.&lt;br/>
    /// This is the head of the linked list for this account from the
    /// account airdrops map.&lt;br/>
    /// &lt;p>
    /// The account airdrops SHALL be connected by including the "next" and
    /// "previous" `PendingAirdropID` in each `AccountAirdrop` message.&lt;br/>
    /// This value SHALL NOT be empty if this account is "sender" for any
    /// pending airdrop, and SHALL be empty otherwise.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.PendingAirdropId HeadPendingAirdropId {
      get { return headPendingAirdropId_; }
      set {
        headPendingAirdropId_ = value;
      }
    }

    /// <summary>Field number for the "number_pending_airdrops" field.</summary>
    public const int NumberPendingAirdropsFieldNumber = 35;
    private ulong numberPendingAirdrops_;
    /// <summary>
    ///*
    /// A number of pending airdrops.
    /// &lt;p>
    /// This count SHALL be used to calculate rent _without_ walking the linked
    /// list of pending airdrops associated to this account via the
    /// `head_pending_airdrop_id` field.&lt;br/>
    /// This value MUST be updated for every airdrop, clam, or cancel transaction
    /// that designates this account as a receiver.&lt;br/>
    /// This number MUST always match the count of entries in the "list"
    /// identified by `head_pending_airdrop_id`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ulong NumberPendingAirdrops {
      get { return numberPendingAirdrops_; }
      set {
        numberPendingAirdrops_ = value;
      }
    }

    /// <summary>Field number for the "number_hooks_in_use" field.</summary>
    public const int NumberHooksInUseFieldNumber = 36;
    private ulong numberHooksInUse_;
    /// <summary>
    ///*
    /// The number of hooks currently in use on this account.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ulong NumberHooksInUse {
      get { return numberHooksInUse_; }
      set {
        numberHooksInUse_ = value;
      }
    }

    /// <summary>Field number for the "first_hook_id" field.</summary>
    public const int FirstHookIdFieldNumber = 37;
    private long firstHookId_;
    /// <summary>
    ///*
    /// If the account has more than zero hooks in use, the id of the first hook in its
    /// doubly-linked list of hooks.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long FirstHookId {
      get { return firstHookId_; }
      set {
        firstHookId_ = value;
      }
    }

    /// <summary>Field number for the "number_lambda_storage_slots" field.</summary>
    public const int NumberLambdaStorageSlotsFieldNumber = 38;
    private ulong numberLambdaStorageSlots_;
    /// <summary>
    ///*
    /// The number of storage slots in use by this account's lambdas.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ulong NumberLambdaStorageSlots {
      get { return numberLambdaStorageSlots_; }
      set {
        numberLambdaStorageSlots_ = value;
      }
    }

    private object stakedId_;
    /// <summary>Enum of possible cases for the "staked_id" oneof.</summary>
    public enum StakedIdOneofCase {
      None = 0,
      StakedAccountId = 10,
      StakedNodeId = 11,
    }
    private StakedIdOneofCase stakedIdCase_ = StakedIdOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public StakedIdOneofCase StakedIdCase {
      get { return stakedIdCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearStakedId() {
      stakedIdCase_ = StakedIdOneofCase.None;
      stakedId_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Account);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Account other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(AccountId, other.AccountId)) return false;
      if (Alias != other.Alias) return false;
      if (!object.Equals(Key, other.Key)) return false;
      if (ExpirationSecond != other.ExpirationSecond) return false;
      if (TinybarBalance != other.TinybarBalance) return false;
      if (Memo != other.Memo) return false;
      if (Deleted != other.Deleted) return false;
      if (StakedToMe != other.StakedToMe) return false;
      if (StakePeriodStart != other.StakePeriodStart) return false;
      if (!object.Equals(StakedAccountId, other.StakedAccountId)) return false;
      if (StakedNodeId != other.StakedNodeId) return false;
      if (DeclineReward != other.DeclineReward) return false;
      if (ReceiverSigRequired != other.ReceiverSigRequired) return false;
      if (!object.Equals(HeadTokenId, other.HeadTokenId)) return false;
      if (!object.Equals(HeadNftId, other.HeadNftId)) return false;
      if (HeadNftSerialNumber != other.HeadNftSerialNumber) return false;
      if (NumberOwnedNfts != other.NumberOwnedNfts) return false;
      if (MaxAutoAssociations != other.MaxAutoAssociations) return false;
      if (UsedAutoAssociations != other.UsedAutoAssociations) return false;
      if (NumberAssociations != other.NumberAssociations) return false;
      if (SmartContract != other.SmartContract) return false;
      if (NumberPositiveBalances != other.NumberPositiveBalances) return false;
      if (EthereumNonce != other.EthereumNonce) return false;
      if (StakeAtStartOfLastRewardedPeriod != other.StakeAtStartOfLastRewardedPeriod) return false;
      if (!object.Equals(AutoRenewAccountId, other.AutoRenewAccountId)) return false;
      if (AutoRenewSeconds != other.AutoRenewSeconds) return false;
      if (ContractKvPairsNumber != other.ContractKvPairsNumber) return false;
      if(!cryptoAllowances_.Equals(other.cryptoAllowances_)) return false;
      if(!approveForAllNftAllowances_.Equals(other.approveForAllNftAllowances_)) return false;
      if(!tokenAllowances_.Equals(other.tokenAllowances_)) return false;
      if (NumberTreasuryTitles != other.NumberTreasuryTitles) return false;
      if (ExpiredAndPendingRemoval != other.ExpiredAndPendingRemoval) return false;
      if (FirstContractStorageKey != other.FirstContractStorageKey) return false;
      if (!object.Equals(HeadPendingAirdropId, other.HeadPendingAirdropId)) return false;
      if (NumberPendingAirdrops != other.NumberPendingAirdrops) return false;
      if (NumberHooksInUse != other.NumberHooksInUse) return false;
      if (FirstHookId != other.FirstHookId) return false;
      if (NumberLambdaStorageSlots != other.NumberLambdaStorageSlots) return false;
      if (StakedIdCase != other.StakedIdCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (accountId_ != null) hash ^= AccountId.GetHashCode();
      if (Alias.Length != 0) hash ^= Alias.GetHashCode();
      if (key_ != null) hash ^= Key.GetHashCode();
      if (ExpirationSecond != 0L) hash ^= ExpirationSecond.GetHashCode();
      if (TinybarBalance != 0L) hash ^= TinybarBalance.GetHashCode();
      if (Memo.Length != 0) hash ^= Memo.GetHashCode();
      if (Deleted != false) hash ^= Deleted.GetHashCode();
      if (StakedToMe != 0L) hash ^= StakedToMe.GetHashCode();
      if (StakePeriodStart != 0L) hash ^= StakePeriodStart.GetHashCode();
      if (stakedIdCase_ == StakedIdOneofCase.StakedAccountId) hash ^= StakedAccountId.GetHashCode();
      if (HasStakedNodeId) hash ^= StakedNodeId.GetHashCode();
      if (DeclineReward != false) hash ^= DeclineReward.GetHashCode();
      if (ReceiverSigRequired != false) hash ^= ReceiverSigRequired.GetHashCode();
      if (headTokenId_ != null) hash ^= HeadTokenId.GetHashCode();
      if (headNftId_ != null) hash ^= HeadNftId.GetHashCode();
      if (HeadNftSerialNumber != 0L) hash ^= HeadNftSerialNumber.GetHashCode();
      if (NumberOwnedNfts != 0L) hash ^= NumberOwnedNfts.GetHashCode();
      if (MaxAutoAssociations != 0) hash ^= MaxAutoAssociations.GetHashCode();
      if (UsedAutoAssociations != 0) hash ^= UsedAutoAssociations.GetHashCode();
      if (NumberAssociations != 0) hash ^= NumberAssociations.GetHashCode();
      if (SmartContract != false) hash ^= SmartContract.GetHashCode();
      if (NumberPositiveBalances != 0) hash ^= NumberPositiveBalances.GetHashCode();
      if (EthereumNonce != 0L) hash ^= EthereumNonce.GetHashCode();
      if (StakeAtStartOfLastRewardedPeriod != 0L) hash ^= StakeAtStartOfLastRewardedPeriod.GetHashCode();
      if (autoRenewAccountId_ != null) hash ^= AutoRenewAccountId.GetHashCode();
      if (AutoRenewSeconds != 0L) hash ^= AutoRenewSeconds.GetHashCode();
      if (ContractKvPairsNumber != 0) hash ^= ContractKvPairsNumber.GetHashCode();
      hash ^= cryptoAllowances_.GetHashCode();
      hash ^= approveForAllNftAllowances_.GetHashCode();
      hash ^= tokenAllowances_.GetHashCode();
      if (NumberTreasuryTitles != 0) hash ^= NumberTreasuryTitles.GetHashCode();
      if (ExpiredAndPendingRemoval != false) hash ^= ExpiredAndPendingRemoval.GetHashCode();
      if (FirstContractStorageKey.Length != 0) hash ^= FirstContractStorageKey.GetHashCode();
      if (headPendingAirdropId_ != null) hash ^= HeadPendingAirdropId.GetHashCode();
      if (NumberPendingAirdrops != 0UL) hash ^= NumberPendingAirdrops.GetHashCode();
      if (NumberHooksInUse != 0UL) hash ^= NumberHooksInUse.GetHashCode();
      if (FirstHookId != 0L) hash ^= FirstHookId.GetHashCode();
      if (NumberLambdaStorageSlots != 0UL) hash ^= NumberLambdaStorageSlots.GetHashCode();
      hash ^= (int) stakedIdCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (accountId_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(AccountId);
      }
      if (Alias.Length != 0) {
        output.WriteRawTag(18);
        output.WriteBytes(Alias);
      }
      if (key_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Key);
      }
      if (ExpirationSecond != 0L) {
        output.WriteRawTag(32);
        output.WriteInt64(ExpirationSecond);
      }
      if (TinybarBalance != 0L) {
        output.WriteRawTag(40);
        output.WriteInt64(TinybarBalance);
      }
      if (Memo.Length != 0) {
        output.WriteRawTag(50);
        output.WriteString(Memo);
      }
      if (Deleted != false) {
        output.WriteRawTag(56);
        output.WriteBool(Deleted);
      }
      if (StakedToMe != 0L) {
        output.WriteRawTag(64);
        output.WriteInt64(StakedToMe);
      }
      if (StakePeriodStart != 0L) {
        output.WriteRawTag(72);
        output.WriteInt64(StakePeriodStart);
      }
      if (stakedIdCase_ == StakedIdOneofCase.StakedAccountId) {
        output.WriteRawTag(82);
        output.WriteMessage(StakedAccountId);
      }
      if (HasStakedNodeId) {
        output.WriteRawTag(88);
        output.WriteInt64(StakedNodeId);
      }
      if (DeclineReward != false) {
        output.WriteRawTag(96);
        output.WriteBool(DeclineReward);
      }
      if (ReceiverSigRequired != false) {
        output.WriteRawTag(104);
        output.WriteBool(ReceiverSigRequired);
      }
      if (headTokenId_ != null) {
        output.WriteRawTag(114);
        output.WriteMessage(HeadTokenId);
      }
      if (headNftId_ != null) {
        output.WriteRawTag(122);
        output.WriteMessage(HeadNftId);
      }
      if (HeadNftSerialNumber != 0L) {
        output.WriteRawTag(128, 1);
        output.WriteInt64(HeadNftSerialNumber);
      }
      if (NumberOwnedNfts != 0L) {
        output.WriteRawTag(136, 1);
        output.WriteInt64(NumberOwnedNfts);
      }
      if (MaxAutoAssociations != 0) {
        output.WriteRawTag(144, 1);
        output.WriteInt32(MaxAutoAssociations);
      }
      if (UsedAutoAssociations != 0) {
        output.WriteRawTag(152, 1);
        output.WriteInt32(UsedAutoAssociations);
      }
      if (NumberAssociations != 0) {
        output.WriteRawTag(160, 1);
        output.WriteInt32(NumberAssociations);
      }
      if (SmartContract != false) {
        output.WriteRawTag(168, 1);
        output.WriteBool(SmartContract);
      }
      if (NumberPositiveBalances != 0) {
        output.WriteRawTag(176, 1);
        output.WriteInt32(NumberPositiveBalances);
      }
      if (EthereumNonce != 0L) {
        output.WriteRawTag(184, 1);
        output.WriteInt64(EthereumNonce);
      }
      if (StakeAtStartOfLastRewardedPeriod != 0L) {
        output.WriteRawTag(192, 1);
        output.WriteInt64(StakeAtStartOfLastRewardedPeriod);
      }
      if (autoRenewAccountId_ != null) {
        output.WriteRawTag(202, 1);
        output.WriteMessage(AutoRenewAccountId);
      }
      if (AutoRenewSeconds != 0L) {
        output.WriteRawTag(208, 1);
        output.WriteInt64(AutoRenewSeconds);
      }
      if (ContractKvPairsNumber != 0) {
        output.WriteRawTag(216, 1);
        output.WriteInt32(ContractKvPairsNumber);
      }
      cryptoAllowances_.WriteTo(output, _repeated_cryptoAllowances_codec);
      approveForAllNftAllowances_.WriteTo(output, _repeated_approveForAllNftAllowances_codec);
      tokenAllowances_.WriteTo(output, _repeated_tokenAllowances_codec);
      if (NumberTreasuryTitles != 0) {
        output.WriteRawTag(248, 1);
        output.WriteUInt32(NumberTreasuryTitles);
      }
      if (ExpiredAndPendingRemoval != false) {
        output.WriteRawTag(128, 2);
        output.WriteBool(ExpiredAndPendingRemoval);
      }
      if (FirstContractStorageKey.Length != 0) {
        output.WriteRawTag(138, 2);
        output.WriteBytes(FirstContractStorageKey);
      }
      if (headPendingAirdropId_ != null) {
        output.WriteRawTag(146, 2);
        output.WriteMessage(HeadPendingAirdropId);
      }
      if (NumberPendingAirdrops != 0UL) {
        output.WriteRawTag(152, 2);
        output.WriteUInt64(NumberPendingAirdrops);
      }
      if (NumberHooksInUse != 0UL) {
        output.WriteRawTag(160, 2);
        output.WriteUInt64(NumberHooksInUse);
      }
      if (FirstHookId != 0L) {
        output.WriteRawTag(168, 2);
        output.WriteInt64(FirstHookId);
      }
      if (NumberLambdaStorageSlots != 0UL) {
        output.WriteRawTag(176, 2);
        output.WriteUInt64(NumberLambdaStorageSlots);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (accountId_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(AccountId);
      }
      if (Alias.Length != 0) {
        output.WriteRawTag(18);
        output.WriteBytes(Alias);
      }
      if (key_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Key);
      }
      if (ExpirationSecond != 0L) {
        output.WriteRawTag(32);
        output.WriteInt64(ExpirationSecond);
      }
      if (TinybarBalance != 0L) {
        output.WriteRawTag(40);
        output.WriteInt64(TinybarBalance);
      }
      if (Memo.Length != 0) {
        output.WriteRawTag(50);
        output.WriteString(Memo);
      }
      if (Deleted != false) {
        output.WriteRawTag(56);
        output.WriteBool(Deleted);
      }
      if (StakedToMe != 0L) {
        output.WriteRawTag(64);
        output.WriteInt64(StakedToMe);
      }
      if (StakePeriodStart != 0L) {
        output.WriteRawTag(72);
        output.WriteInt64(StakePeriodStart);
      }
      if (stakedIdCase_ == StakedIdOneofCase.StakedAccountId) {
        output.WriteRawTag(82);
        output.WriteMessage(StakedAccountId);
      }
      if (HasStakedNodeId) {
        output.WriteRawTag(88);
        output.WriteInt64(StakedNodeId);
      }
      if (DeclineReward != false) {
        output.WriteRawTag(96);
        output.WriteBool(DeclineReward);
      }
      if (ReceiverSigRequired != false) {
        output.WriteRawTag(104);
        output.WriteBool(ReceiverSigRequired);
      }
      if (headTokenId_ != null) {
        output.WriteRawTag(114);
        output.WriteMessage(HeadTokenId);
      }
      if (headNftId_ != null) {
        output.WriteRawTag(122);
        output.WriteMessage(HeadNftId);
      }
      if (HeadNftSerialNumber != 0L) {
        output.WriteRawTag(128, 1);
        output.WriteInt64(HeadNftSerialNumber);
      }
      if (NumberOwnedNfts != 0L) {
        output.WriteRawTag(136, 1);
        output.WriteInt64(NumberOwnedNfts);
      }
      if (MaxAutoAssociations != 0) {
        output.WriteRawTag(144, 1);
        output.WriteInt32(MaxAutoAssociations);
      }
      if (UsedAutoAssociations != 0) {
        output.WriteRawTag(152, 1);
        output.WriteInt32(UsedAutoAssociations);
      }
      if (NumberAssociations != 0) {
        output.WriteRawTag(160, 1);
        output.WriteInt32(NumberAssociations);
      }
      if (SmartContract != false) {
        output.WriteRawTag(168, 1);
        output.WriteBool(SmartContract);
      }
      if (NumberPositiveBalances != 0) {
        output.WriteRawTag(176, 1);
        output.WriteInt32(NumberPositiveBalances);
      }
      if (EthereumNonce != 0L) {
        output.WriteRawTag(184, 1);
        output.WriteInt64(EthereumNonce);
      }
      if (StakeAtStartOfLastRewardedPeriod != 0L) {
        output.WriteRawTag(192, 1);
        output.WriteInt64(StakeAtStartOfLastRewardedPeriod);
      }
      if (autoRenewAccountId_ != null) {
        output.WriteRawTag(202, 1);
        output.WriteMessage(AutoRenewAccountId);
      }
      if (AutoRenewSeconds != 0L) {
        output.WriteRawTag(208, 1);
        output.WriteInt64(AutoRenewSeconds);
      }
      if (ContractKvPairsNumber != 0) {
        output.WriteRawTag(216, 1);
        output.WriteInt32(ContractKvPairsNumber);
      }
      cryptoAllowances_.WriteTo(ref output, _repeated_cryptoAllowances_codec);
      approveForAllNftAllowances_.WriteTo(ref output, _repeated_approveForAllNftAllowances_codec);
      tokenAllowances_.WriteTo(ref output, _repeated_tokenAllowances_codec);
      if (NumberTreasuryTitles != 0) {
        output.WriteRawTag(248, 1);
        output.WriteUInt32(NumberTreasuryTitles);
      }
      if (ExpiredAndPendingRemoval != false) {
        output.WriteRawTag(128, 2);
        output.WriteBool(ExpiredAndPendingRemoval);
      }
      if (FirstContractStorageKey.Length != 0) {
        output.WriteRawTag(138, 2);
        output.WriteBytes(FirstContractStorageKey);
      }
      if (headPendingAirdropId_ != null) {
        output.WriteRawTag(146, 2);
        output.WriteMessage(HeadPendingAirdropId);
      }
      if (NumberPendingAirdrops != 0UL) {
        output.WriteRawTag(152, 2);
        output.WriteUInt64(NumberPendingAirdrops);
      }
      if (NumberHooksInUse != 0UL) {
        output.WriteRawTag(160, 2);
        output.WriteUInt64(NumberHooksInUse);
      }
      if (FirstHookId != 0L) {
        output.WriteRawTag(168, 2);
        output.WriteInt64(FirstHookId);
      }
      if (NumberLambdaStorageSlots != 0UL) {
        output.WriteRawTag(176, 2);
        output.WriteUInt64(NumberLambdaStorageSlots);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (accountId_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(AccountId);
      }
      if (Alias.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Alias);
      }
      if (key_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Key);
      }
      if (ExpirationSecond != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(ExpirationSecond);
      }
      if (TinybarBalance != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(TinybarBalance);
      }
      if (Memo.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Memo);
      }
      if (Deleted != false) {
        size += 1 + 1;
      }
      if (StakedToMe != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(StakedToMe);
      }
      if (StakePeriodStart != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(StakePeriodStart);
      }
      if (stakedIdCase_ == StakedIdOneofCase.StakedAccountId) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(StakedAccountId);
      }
      if (HasStakedNodeId) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(StakedNodeId);
      }
      if (DeclineReward != false) {
        size += 1 + 1;
      }
      if (ReceiverSigRequired != false) {
        size += 1 + 1;
      }
      if (headTokenId_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(HeadTokenId);
      }
      if (headNftId_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(HeadNftId);
      }
      if (HeadNftSerialNumber != 0L) {
        size += 2 + pb::CodedOutputStream.ComputeInt64Size(HeadNftSerialNumber);
      }
      if (NumberOwnedNfts != 0L) {
        size += 2 + pb::CodedOutputStream.ComputeInt64Size(NumberOwnedNfts);
      }
      if (MaxAutoAssociations != 0) {
        size += 2 + pb::CodedOutputStream.ComputeInt32Size(MaxAutoAssociations);
      }
      if (UsedAutoAssociations != 0) {
        size += 2 + pb::CodedOutputStream.ComputeInt32Size(UsedAutoAssociations);
      }
      if (NumberAssociations != 0) {
        size += 2 + pb::CodedOutputStream.ComputeInt32Size(NumberAssociations);
      }
      if (SmartContract != false) {
        size += 2 + 1;
      }
      if (NumberPositiveBalances != 0) {
        size += 2 + pb::CodedOutputStream.ComputeInt32Size(NumberPositiveBalances);
      }
      if (EthereumNonce != 0L) {
        size += 2 + pb::CodedOutputStream.ComputeInt64Size(EthereumNonce);
      }
      if (StakeAtStartOfLastRewardedPeriod != 0L) {
        size += 2 + pb::CodedOutputStream.ComputeInt64Size(StakeAtStartOfLastRewardedPeriod);
      }
      if (autoRenewAccountId_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(AutoRenewAccountId);
      }
      if (AutoRenewSeconds != 0L) {
        size += 2 + pb::CodedOutputStream.ComputeInt64Size(AutoRenewSeconds);
      }
      if (ContractKvPairsNumber != 0) {
        size += 2 + pb::CodedOutputStream.ComputeInt32Size(ContractKvPairsNumber);
      }
      size += cryptoAllowances_.CalculateSize(_repeated_cryptoAllowances_codec);
      size += approveForAllNftAllowances_.CalculateSize(_repeated_approveForAllNftAllowances_codec);
      size += tokenAllowances_.CalculateSize(_repeated_tokenAllowances_codec);
      if (NumberTreasuryTitles != 0) {
        size += 2 + pb::CodedOutputStream.ComputeUInt32Size(NumberTreasuryTitles);
      }
      if (ExpiredAndPendingRemoval != false) {
        size += 2 + 1;
      }
      if (FirstContractStorageKey.Length != 0) {
        size += 2 + pb::CodedOutputStream.ComputeBytesSize(FirstContractStorageKey);
      }
      if (headPendingAirdropId_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(HeadPendingAirdropId);
      }
      if (NumberPendingAirdrops != 0UL) {
        size += 2 + pb::CodedOutputStream.ComputeUInt64Size(NumberPendingAirdrops);
      }
      if (NumberHooksInUse != 0UL) {
        size += 2 + pb::CodedOutputStream.ComputeUInt64Size(NumberHooksInUse);
      }
      if (FirstHookId != 0L) {
        size += 2 + pb::CodedOutputStream.ComputeInt64Size(FirstHookId);
      }
      if (NumberLambdaStorageSlots != 0UL) {
        size += 2 + pb::CodedOutputStream.ComputeUInt64Size(NumberLambdaStorageSlots);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Account other) {
      if (other == null) {
        return;
      }
      if (other.accountId_ != null) {
        if (accountId_ == null) {
          AccountId = new global::Proto.AccountID();
        }
        AccountId.MergeFrom(other.AccountId);
      }
      if (other.Alias.Length != 0) {
        Alias = other.Alias;
      }
      if (other.key_ != null) {
        if (key_ == null) {
          Key = new global::Proto.Key();
        }
        Key.MergeFrom(other.Key);
      }
      if (other.ExpirationSecond != 0L) {
        ExpirationSecond = other.ExpirationSecond;
      }
      if (other.TinybarBalance != 0L) {
        TinybarBalance = other.TinybarBalance;
      }
      if (other.Memo.Length != 0) {
        Memo = other.Memo;
      }
      if (other.Deleted != false) {
        Deleted = other.Deleted;
      }
      if (other.StakedToMe != 0L) {
        StakedToMe = other.StakedToMe;
      }
      if (other.StakePeriodStart != 0L) {
        StakePeriodStart = other.StakePeriodStart;
      }
      if (other.DeclineReward != false) {
        DeclineReward = other.DeclineReward;
      }
      if (other.ReceiverSigRequired != false) {
        ReceiverSigRequired = other.ReceiverSigRequired;
      }
      if (other.headTokenId_ != null) {
        if (headTokenId_ == null) {
          HeadTokenId = new global::Proto.TokenID();
        }
        HeadTokenId.MergeFrom(other.HeadTokenId);
      }
      if (other.headNftId_ != null) {
        if (headNftId_ == null) {
          HeadNftId = new global::Proto.NftID();
        }
        HeadNftId.MergeFrom(other.HeadNftId);
      }
      if (other.HeadNftSerialNumber != 0L) {
        HeadNftSerialNumber = other.HeadNftSerialNumber;
      }
      if (other.NumberOwnedNfts != 0L) {
        NumberOwnedNfts = other.NumberOwnedNfts;
      }
      if (other.MaxAutoAssociations != 0) {
        MaxAutoAssociations = other.MaxAutoAssociations;
      }
      if (other.UsedAutoAssociations != 0) {
        UsedAutoAssociations = other.UsedAutoAssociations;
      }
      if (other.NumberAssociations != 0) {
        NumberAssociations = other.NumberAssociations;
      }
      if (other.SmartContract != false) {
        SmartContract = other.SmartContract;
      }
      if (other.NumberPositiveBalances != 0) {
        NumberPositiveBalances = other.NumberPositiveBalances;
      }
      if (other.EthereumNonce != 0L) {
        EthereumNonce = other.EthereumNonce;
      }
      if (other.StakeAtStartOfLastRewardedPeriod != 0L) {
        StakeAtStartOfLastRewardedPeriod = other.StakeAtStartOfLastRewardedPeriod;
      }
      if (other.autoRenewAccountId_ != null) {
        if (autoRenewAccountId_ == null) {
          AutoRenewAccountId = new global::Proto.AccountID();
        }
        AutoRenewAccountId.MergeFrom(other.AutoRenewAccountId);
      }
      if (other.AutoRenewSeconds != 0L) {
        AutoRenewSeconds = other.AutoRenewSeconds;
      }
      if (other.ContractKvPairsNumber != 0) {
        ContractKvPairsNumber = other.ContractKvPairsNumber;
      }
      cryptoAllowances_.Add(other.cryptoAllowances_);
      approveForAllNftAllowances_.Add(other.approveForAllNftAllowances_);
      tokenAllowances_.Add(other.tokenAllowances_);
      if (other.NumberTreasuryTitles != 0) {
        NumberTreasuryTitles = other.NumberTreasuryTitles;
      }
      if (other.ExpiredAndPendingRemoval != false) {
        ExpiredAndPendingRemoval = other.ExpiredAndPendingRemoval;
      }
      if (other.FirstContractStorageKey.Length != 0) {
        FirstContractStorageKey = other.FirstContractStorageKey;
      }
      if (other.headPendingAirdropId_ != null) {
        if (headPendingAirdropId_ == null) {
          HeadPendingAirdropId = new global::Proto.PendingAirdropId();
        }
        HeadPendingAirdropId.MergeFrom(other.HeadPendingAirdropId);
      }
      if (other.NumberPendingAirdrops != 0UL) {
        NumberPendingAirdrops = other.NumberPendingAirdrops;
      }
      if (other.NumberHooksInUse != 0UL) {
        NumberHooksInUse = other.NumberHooksInUse;
      }
      if (other.FirstHookId != 0L) {
        FirstHookId = other.FirstHookId;
      }
      if (other.NumberLambdaStorageSlots != 0UL) {
        NumberLambdaStorageSlots = other.NumberLambdaStorageSlots;
      }
      switch (other.StakedIdCase) {
        case StakedIdOneofCase.StakedAccountId:
          if (StakedAccountId == null) {
            StakedAccountId = new global::Proto.AccountID();
          }
          StakedAccountId.MergeFrom(other.StakedAccountId);
          break;
        case StakedIdOneofCase.StakedNodeId:
          StakedNodeId = other.StakedNodeId;
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (accountId_ == null) {
              AccountId = new global::Proto.AccountID();
            }
            input.ReadMessage(AccountId);
            break;
          }
          case 18: {
            Alias = input.ReadBytes();
            break;
          }
          case 26: {
            if (key_ == null) {
              Key = new global::Proto.Key();
            }
            input.ReadMessage(Key);
            break;
          }
          case 32: {
            ExpirationSecond = input.ReadInt64();
            break;
          }
          case 40: {
            TinybarBalance = input.ReadInt64();
            break;
          }
          case 50: {
            Memo = input.ReadString();
            break;
          }
          case 56: {
            Deleted = input.ReadBool();
            break;
          }
          case 64: {
            StakedToMe = input.ReadInt64();
            break;
          }
          case 72: {
            StakePeriodStart = input.ReadInt64();
            break;
          }
          case 82: {
            global::Proto.AccountID subBuilder = new global::Proto.AccountID();
            if (stakedIdCase_ == StakedIdOneofCase.StakedAccountId) {
              subBuilder.MergeFrom(StakedAccountId);
            }
            input.ReadMessage(subBuilder);
            StakedAccountId = subBuilder;
            break;
          }
          case 88: {
            StakedNodeId = input.ReadInt64();
            break;
          }
          case 96: {
            DeclineReward = input.ReadBool();
            break;
          }
          case 104: {
            ReceiverSigRequired = input.ReadBool();
            break;
          }
          case 114: {
            if (headTokenId_ == null) {
              HeadTokenId = new global::Proto.TokenID();
            }
            input.ReadMessage(HeadTokenId);
            break;
          }
          case 122: {
            if (headNftId_ == null) {
              HeadNftId = new global::Proto.NftID();
            }
            input.ReadMessage(HeadNftId);
            break;
          }
          case 128: {
            HeadNftSerialNumber = input.ReadInt64();
            break;
          }
          case 136: {
            NumberOwnedNfts = input.ReadInt64();
            break;
          }
          case 144: {
            MaxAutoAssociations = input.ReadInt32();
            break;
          }
          case 152: {
            UsedAutoAssociations = input.ReadInt32();
            break;
          }
          case 160: {
            NumberAssociations = input.ReadInt32();
            break;
          }
          case 168: {
            SmartContract = input.ReadBool();
            break;
          }
          case 176: {
            NumberPositiveBalances = input.ReadInt32();
            break;
          }
          case 184: {
            EthereumNonce = input.ReadInt64();
            break;
          }
          case 192: {
            StakeAtStartOfLastRewardedPeriod = input.ReadInt64();
            break;
          }
          case 202: {
            if (autoRenewAccountId_ == null) {
              AutoRenewAccountId = new global::Proto.AccountID();
            }
            input.ReadMessage(AutoRenewAccountId);
            break;
          }
          case 208: {
            AutoRenewSeconds = input.ReadInt64();
            break;
          }
          case 216: {
            ContractKvPairsNumber = input.ReadInt32();
            break;
          }
          case 226: {
            cryptoAllowances_.AddEntriesFrom(input, _repeated_cryptoAllowances_codec);
            break;
          }
          case 234: {
            approveForAllNftAllowances_.AddEntriesFrom(input, _repeated_approveForAllNftAllowances_codec);
            break;
          }
          case 242: {
            tokenAllowances_.AddEntriesFrom(input, _repeated_tokenAllowances_codec);
            break;
          }
          case 248: {
            NumberTreasuryTitles = input.ReadUInt32();
            break;
          }
          case 256: {
            ExpiredAndPendingRemoval = input.ReadBool();
            break;
          }
          case 266: {
            FirstContractStorageKey = input.ReadBytes();
            break;
          }
          case 274: {
            if (headPendingAirdropId_ == null) {
              HeadPendingAirdropId = new global::Proto.PendingAirdropId();
            }
            input.ReadMessage(HeadPendingAirdropId);
            break;
          }
          case 280: {
            NumberPendingAirdrops = input.ReadUInt64();
            break;
          }
          case 288: {
            NumberHooksInUse = input.ReadUInt64();
            break;
          }
          case 296: {
            FirstHookId = input.ReadInt64();
            break;
          }
          case 304: {
            NumberLambdaStorageSlots = input.ReadUInt64();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (accountId_ == null) {
              AccountId = new global::Proto.AccountID();
            }
            input.ReadMessage(AccountId);
            break;
          }
          case 18: {
            Alias = input.ReadBytes();
            break;
          }
          case 26: {
            if (key_ == null) {
              Key = new global::Proto.Key();
            }
            input.ReadMessage(Key);
            break;
          }
          case 32: {
            ExpirationSecond = input.ReadInt64();
            break;
          }
          case 40: {
            TinybarBalance = input.ReadInt64();
            break;
          }
          case 50: {
            Memo = input.ReadString();
            break;
          }
          case 56: {
            Deleted = input.ReadBool();
            break;
          }
          case 64: {
            StakedToMe = input.ReadInt64();
            break;
          }
          case 72: {
            StakePeriodStart = input.ReadInt64();
            break;
          }
          case 82: {
            global::Proto.AccountID subBuilder = new global::Proto.AccountID();
            if (stakedIdCase_ == StakedIdOneofCase.StakedAccountId) {
              subBuilder.MergeFrom(StakedAccountId);
            }
            input.ReadMessage(subBuilder);
            StakedAccountId = subBuilder;
            break;
          }
          case 88: {
            StakedNodeId = input.ReadInt64();
            break;
          }
          case 96: {
            DeclineReward = input.ReadBool();
            break;
          }
          case 104: {
            ReceiverSigRequired = input.ReadBool();
            break;
          }
          case 114: {
            if (headTokenId_ == null) {
              HeadTokenId = new global::Proto.TokenID();
            }
            input.ReadMessage(HeadTokenId);
            break;
          }
          case 122: {
            if (headNftId_ == null) {
              HeadNftId = new global::Proto.NftID();
            }
            input.ReadMessage(HeadNftId);
            break;
          }
          case 128: {
            HeadNftSerialNumber = input.ReadInt64();
            break;
          }
          case 136: {
            NumberOwnedNfts = input.ReadInt64();
            break;
          }
          case 144: {
            MaxAutoAssociations = input.ReadInt32();
            break;
          }
          case 152: {
            UsedAutoAssociations = input.ReadInt32();
            break;
          }
          case 160: {
            NumberAssociations = input.ReadInt32();
            break;
          }
          case 168: {
            SmartContract = input.ReadBool();
            break;
          }
          case 176: {
            NumberPositiveBalances = input.ReadInt32();
            break;
          }
          case 184: {
            EthereumNonce = input.ReadInt64();
            break;
          }
          case 192: {
            StakeAtStartOfLastRewardedPeriod = input.ReadInt64();
            break;
          }
          case 202: {
            if (autoRenewAccountId_ == null) {
              AutoRenewAccountId = new global::Proto.AccountID();
            }
            input.ReadMessage(AutoRenewAccountId);
            break;
          }
          case 208: {
            AutoRenewSeconds = input.ReadInt64();
            break;
          }
          case 216: {
            ContractKvPairsNumber = input.ReadInt32();
            break;
          }
          case 226: {
            cryptoAllowances_.AddEntriesFrom(ref input, _repeated_cryptoAllowances_codec);
            break;
          }
          case 234: {
            approveForAllNftAllowances_.AddEntriesFrom(ref input, _repeated_approveForAllNftAllowances_codec);
            break;
          }
          case 242: {
            tokenAllowances_.AddEntriesFrom(ref input, _repeated_tokenAllowances_codec);
            break;
          }
          case 248: {
            NumberTreasuryTitles = input.ReadUInt32();
            break;
          }
          case 256: {
            ExpiredAndPendingRemoval = input.ReadBool();
            break;
          }
          case 266: {
            FirstContractStorageKey = input.ReadBytes();
            break;
          }
          case 274: {
            if (headPendingAirdropId_ == null) {
              HeadPendingAirdropId = new global::Proto.PendingAirdropId();
            }
            input.ReadMessage(HeadPendingAirdropId);
            break;
          }
          case 280: {
            NumberPendingAirdrops = input.ReadUInt64();
            break;
          }
          case 288: {
            NumberHooksInUse = input.ReadUInt64();
            break;
          }
          case 296: {
            FirstHookId = input.ReadInt64();
            break;
          }
          case 304: {
            NumberLambdaStorageSlots = input.ReadUInt64();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// Permission granted by one account (the "funding" account) to another account
  /// (the "spender" account) that allows the spender to transfer all serial
  /// numbers of a specific non-fungible token (NFT) collection owned by the
  /// funding account.&lt;br/>
  /// This is a broad permission, as it does not matter how many NFTs of the
  /// specified collection the funding account owns, the spender MAY dispose of
  /// any or all of them with this allowance.&lt;br/>
  /// Each token type (typically a collection of NFTs) SHALL require a separate
  /// allowance.&lt;br/>
  /// Allowances for a specific serial number MUST be directly associated with
  /// that specific non-fungible token, rather than the holding account.
  ///
  /// An allowance SHALL NOT transfer any tokens directly, it only permits
  /// transactions signed only by the spender account to transfer any non-fungible
  /// tokens of the specified type owned by the funding account.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class AccountApprovalForAllAllowance : pb::IMessage<AccountApprovalForAllAllowance>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<AccountApprovalForAllAllowance> _parser = new pb::MessageParser<AccountApprovalForAllAllowance>(() => new AccountApprovalForAllAllowance());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<AccountApprovalForAllAllowance> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Proto.AccountReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AccountApprovalForAllAllowance() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AccountApprovalForAllAllowance(AccountApprovalForAllAllowance other) : this() {
      tokenId_ = other.tokenId_ != null ? other.tokenId_.Clone() : null;
      spenderId_ = other.spenderId_ != null ? other.spenderId_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AccountApprovalForAllAllowance Clone() {
      return new AccountApprovalForAllAllowance(this);
    }

    /// <summary>Field number for the "token_id" field.</summary>
    public const int TokenIdFieldNumber = 1;
    private global::Proto.TokenID tokenId_;
    /// <summary>
    ///*
    /// The identifier for the token associated with this allowance.
    /// &lt;p>
    /// This token MUST be a non-fungible/unique token.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.TokenID TokenId {
      get { return tokenId_; }
      set {
        tokenId_ = value;
      }
    }

    /// <summary>Field number for the "spender_id" field.</summary>
    public const int SpenderIdFieldNumber = 2;
    private global::Proto.AccountID spenderId_;
    /// <summary>
    ///*
    /// The identifier for the spending account associated with this allowance.
    /// &lt;p>
    /// This account SHALL be permitted to sign transactions to spend tokens of
    /// the associated token type from the funding/allowing account.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.AccountID SpenderId {
      get { return spenderId_; }
      set {
        spenderId_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as AccountApprovalForAllAllowance);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(AccountApprovalForAllAllowance other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(TokenId, other.TokenId)) return false;
      if (!object.Equals(SpenderId, other.SpenderId)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (tokenId_ != null) hash ^= TokenId.GetHashCode();
      if (spenderId_ != null) hash ^= SpenderId.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (tokenId_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(TokenId);
      }
      if (spenderId_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(SpenderId);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (tokenId_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(TokenId);
      }
      if (spenderId_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(SpenderId);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (tokenId_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TokenId);
      }
      if (spenderId_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SpenderId);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(AccountApprovalForAllAllowance other) {
      if (other == null) {
        return;
      }
      if (other.tokenId_ != null) {
        if (tokenId_ == null) {
          TokenId = new global::Proto.TokenID();
        }
        TokenId.MergeFrom(other.TokenId);
      }
      if (other.spenderId_ != null) {
        if (spenderId_ == null) {
          SpenderId = new global::Proto.AccountID();
        }
        SpenderId.MergeFrom(other.SpenderId);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (tokenId_ == null) {
              TokenId = new global::Proto.TokenID();
            }
            input.ReadMessage(TokenId);
            break;
          }
          case 18: {
            if (spenderId_ == null) {
              SpenderId = new global::Proto.AccountID();
            }
            input.ReadMessage(SpenderId);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (tokenId_ == null) {
              TokenId = new global::Proto.TokenID();
            }
            input.ReadMessage(TokenId);
            break;
          }
          case 18: {
            if (spenderId_ == null) {
              SpenderId = new global::Proto.AccountID();
            }
            input.ReadMessage(SpenderId);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// Permission granted by one account (the "funding" account) to another account
  /// (the "spender" account) that allows the spender to spend a specified amount
  /// of a specific non-HBAR fungible token from the balance owned by the funding
  /// account.
  ///
  /// An allowance SHALL NOT transfer any tokens directly, it only permits
  /// transactions signed only by the spender account to transfer tokens of the
  /// specified type, up to the amount specified, from the funding account.
  ///
  /// Once the specified amount is spent, the allowance SHALL be consumed and a
  /// new allowance SHALL be required before that spending account may spend
  /// additional tokens from the funding account.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class AccountFungibleTokenAllowance : pb::IMessage<AccountFungibleTokenAllowance>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<AccountFungibleTokenAllowance> _parser = new pb::MessageParser<AccountFungibleTokenAllowance>(() => new AccountFungibleTokenAllowance());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<AccountFungibleTokenAllowance> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Proto.AccountReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AccountFungibleTokenAllowance() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AccountFungibleTokenAllowance(AccountFungibleTokenAllowance other) : this() {
      tokenId_ = other.tokenId_ != null ? other.tokenId_.Clone() : null;
      spenderId_ = other.spenderId_ != null ? other.spenderId_.Clone() : null;
      amount_ = other.amount_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AccountFungibleTokenAllowance Clone() {
      return new AccountFungibleTokenAllowance(this);
    }

    /// <summary>Field number for the "token_id" field.</summary>
    public const int TokenIdFieldNumber = 1;
    private global::Proto.TokenID tokenId_;
    /// <summary>
    ///*
    /// The identifier for the token associated with this allowance.
    /// &lt;p>
    /// This token MUST be a fungible/common token.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.TokenID TokenId {
      get { return tokenId_; }
      set {
        tokenId_ = value;
      }
    }

    /// <summary>Field number for the "spender_id" field.</summary>
    public const int SpenderIdFieldNumber = 2;
    private global::Proto.AccountID spenderId_;
    /// <summary>
    ///*
    /// The identifier for the spending account associated with this allowance.
    /// &lt;p>
    /// This account SHALL be permitted to sign transactions to spend tokens of
    /// the associated token type from the funding/allowing account.&lt;br/>
    /// This permission SHALL be limited to no more than the specified `amount`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.AccountID SpenderId {
      get { return spenderId_; }
      set {
        spenderId_ = value;
      }
    }

    /// <summary>Field number for the "amount" field.</summary>
    public const int AmountFieldNumber = 3;
    private long amount_;
    /// <summary>
    ///
    /// The maximum amount that the spender account may transfer within the
    /// scope of this allowance.
    /// &lt;p>
    /// This allowance SHALL be consumed if any combination of transfers
    /// authorized via this allowance meet this value in total.&lt;br/>
    /// This value MUST be specified in the smallest units of the relevant token
    /// (i.e. 10&lt;sup>-decimals&lt;/sup> whole tokens).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long Amount {
      get { return amount_; }
      set {
        amount_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as AccountFungibleTokenAllowance);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(AccountFungibleTokenAllowance other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(TokenId, other.TokenId)) return false;
      if (!object.Equals(SpenderId, other.SpenderId)) return false;
      if (Amount != other.Amount) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (tokenId_ != null) hash ^= TokenId.GetHashCode();
      if (spenderId_ != null) hash ^= SpenderId.GetHashCode();
      if (Amount != 0L) hash ^= Amount.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (tokenId_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(TokenId);
      }
      if (spenderId_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(SpenderId);
      }
      if (Amount != 0L) {
        output.WriteRawTag(24);
        output.WriteInt64(Amount);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (tokenId_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(TokenId);
      }
      if (spenderId_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(SpenderId);
      }
      if (Amount != 0L) {
        output.WriteRawTag(24);
        output.WriteInt64(Amount);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (tokenId_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TokenId);
      }
      if (spenderId_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SpenderId);
      }
      if (Amount != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(Amount);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(AccountFungibleTokenAllowance other) {
      if (other == null) {
        return;
      }
      if (other.tokenId_ != null) {
        if (tokenId_ == null) {
          TokenId = new global::Proto.TokenID();
        }
        TokenId.MergeFrom(other.TokenId);
      }
      if (other.spenderId_ != null) {
        if (spenderId_ == null) {
          SpenderId = new global::Proto.AccountID();
        }
        SpenderId.MergeFrom(other.SpenderId);
      }
      if (other.Amount != 0L) {
        Amount = other.Amount;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (tokenId_ == null) {
              TokenId = new global::Proto.TokenID();
            }
            input.ReadMessage(TokenId);
            break;
          }
          case 18: {
            if (spenderId_ == null) {
              SpenderId = new global::Proto.AccountID();
            }
            input.ReadMessage(SpenderId);
            break;
          }
          case 24: {
            Amount = input.ReadInt64();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (tokenId_ == null) {
              TokenId = new global::Proto.TokenID();
            }
            input.ReadMessage(TokenId);
            break;
          }
          case 18: {
            if (spenderId_ == null) {
              SpenderId = new global::Proto.AccountID();
            }
            input.ReadMessage(SpenderId);
            break;
          }
          case 24: {
            Amount = input.ReadInt64();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// Permission granted by one account (the "funding" account) to another account
  /// (the "spender" account) that allows the spender to spend a specified amount
  /// of HBAR owned by the funding account.
  ///
  /// An allowance SHALL NOT transfer any HBAR directly, it only permits
  /// transactions signed only by the spender account to transfer HBAR, up to the
  /// amount specified, from the funding account.
  ///
  /// Once the specified amount is spent, the allowance SHALL be consumed and a
  /// new allowance SHALL be required before that spending account may spend
  /// additional HBAR from the funding account.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class AccountCryptoAllowance : pb::IMessage<AccountCryptoAllowance>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<AccountCryptoAllowance> _parser = new pb::MessageParser<AccountCryptoAllowance>(() => new AccountCryptoAllowance());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<AccountCryptoAllowance> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Proto.AccountReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AccountCryptoAllowance() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AccountCryptoAllowance(AccountCryptoAllowance other) : this() {
      spenderId_ = other.spenderId_ != null ? other.spenderId_.Clone() : null;
      amount_ = other.amount_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AccountCryptoAllowance Clone() {
      return new AccountCryptoAllowance(this);
    }

    /// <summary>Field number for the "spender_id" field.</summary>
    public const int SpenderIdFieldNumber = 1;
    private global::Proto.AccountID spenderId_;
    /// <summary>
    ///*
    /// The identifier for the spending account associated with this allowance.
    /// &lt;p>
    /// This account SHALL be permitted to sign transactions to spend HBAR from
    /// the funding/allowing account.&lt;br/>
    /// This permission SHALL be limited to no more than the specified `amount`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.AccountID SpenderId {
      get { return spenderId_; }
      set {
        spenderId_ = value;
      }
    }

    /// <summary>Field number for the "amount" field.</summary>
    public const int AmountFieldNumber = 2;
    private long amount_;
    /// <summary>
    ///
    /// The maximum amount that the spender account may transfer within the
    /// scope of this allowance.
    /// &lt;p>
    /// This allowance SHALL be consumed if any combination of transfers
    /// authorized via this allowance meet this value in total.&lt;br/>
    /// This value MUST be specified in tinybar (i.e. 10&lt;sup>-8&lt;/sup> HBAR).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long Amount {
      get { return amount_; }
      set {
        amount_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as AccountCryptoAllowance);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(AccountCryptoAllowance other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(SpenderId, other.SpenderId)) return false;
      if (Amount != other.Amount) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (spenderId_ != null) hash ^= SpenderId.GetHashCode();
      if (Amount != 0L) hash ^= Amount.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (spenderId_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(SpenderId);
      }
      if (Amount != 0L) {
        output.WriteRawTag(16);
        output.WriteInt64(Amount);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (spenderId_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(SpenderId);
      }
      if (Amount != 0L) {
        output.WriteRawTag(16);
        output.WriteInt64(Amount);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (spenderId_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SpenderId);
      }
      if (Amount != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(Amount);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(AccountCryptoAllowance other) {
      if (other == null) {
        return;
      }
      if (other.spenderId_ != null) {
        if (spenderId_ == null) {
          SpenderId = new global::Proto.AccountID();
        }
        SpenderId.MergeFrom(other.SpenderId);
      }
      if (other.Amount != 0L) {
        Amount = other.Amount;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (spenderId_ == null) {
              SpenderId = new global::Proto.AccountID();
            }
            input.ReadMessage(SpenderId);
            break;
          }
          case 16: {
            Amount = input.ReadInt64();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (spenderId_ == null) {
              SpenderId = new global::Proto.AccountID();
            }
            input.ReadMessage(SpenderId);
            break;
          }
          case 16: {
            Amount = input.ReadInt64();
            break;
          }
        }
      }
    }
    #endif

  }

  #endregion

}

#endregion Designer generated code
