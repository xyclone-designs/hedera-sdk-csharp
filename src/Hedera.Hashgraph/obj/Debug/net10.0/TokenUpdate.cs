// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: token_update.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021, 8981
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Hedera.Hashgraph.Proto {

  /// <summary>Holder for reflection information generated from token_update.proto</summary>
  public static partial class TokenUpdateReflection {

    #region Descriptor
    /// <summary>File descriptor for token_update.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static TokenUpdateReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "ChJ0b2tlbl91cGRhdGUucHJvdG8SBXByb3RvGhFiYXNpY190eXBlcy5wcm90",
            "bxoOZHVyYXRpb24ucHJvdG8aD3RpbWVzdGFtcC5wcm90bxoeZ29vZ2xlL3By",
            "b3RvYnVmL3dyYXBwZXJzLnByb3RvIoYFChpUb2tlblVwZGF0ZVRyYW5zYWN0",
            "aW9uQm9keRIdCgV0b2tlbhgBIAEoCzIOLnByb3RvLlRva2VuSUQSDgoGc3lt",
            "Ym9sGAIgASgJEgwKBG5hbWUYAyABKAkSIgoIdHJlYXN1cnkYBCABKAsyEC5w",
            "cm90by5BY2NvdW50SUQSHAoIYWRtaW5LZXkYBSABKAsyCi5wcm90by5LZXkS",
            "GgoGa3ljS2V5GAYgASgLMgoucHJvdG8uS2V5Eh0KCWZyZWV6ZUtleRgHIAEo",
            "CzIKLnByb3RvLktleRIbCgd3aXBlS2V5GAggASgLMgoucHJvdG8uS2V5Eh0K",
            "CXN1cHBseUtleRgJIAEoCzIKLnByb3RvLktleRIqChBhdXRvUmVuZXdBY2Nv",
            "dW50GAogASgLMhAucHJvdG8uQWNjb3VudElEEigKD2F1dG9SZW5ld1Blcmlv",
            "ZBgLIAEoCzIPLnByb3RvLkR1cmF0aW9uEiAKBmV4cGlyeRgMIAEoCzIQLnBy",
            "b3RvLlRpbWVzdGFtcBIqCgRtZW1vGA0gASgLMhwuZ29vZ2xlLnByb3RvYnVm",
            "LlN0cmluZ1ZhbHVlEiQKEGZlZV9zY2hlZHVsZV9rZXkYDiABKAsyCi5wcm90",
            "by5LZXkSHQoJcGF1c2Vfa2V5GA8gASgLMgoucHJvdG8uS2V5Ei0KCG1ldGFk",
            "YXRhGBAgASgLMhsuZ29vZ2xlLnByb3RvYnVmLkJ5dGVzVmFsdWUSIAoMbWV0",
            "YWRhdGFfa2V5GBEgASgLMgoucHJvdG8uS2V5EjgKFWtleV92ZXJpZmljYXRp",
            "b25fbW9kZRgSIAEoDjIZLnByb3RvLlRva2VuS2V5VmFsaWRhdGlvbkI5Ch5j",
            "b20uaGVkZXJhLmhhc2hncmFwaC5zZGsucHJvdG+qAhZIZWRlcmEuSGFzaGdy",
            "YXBoLlByb3RvYgZwcm90bzM="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Hedera.Hashgraph.Proto.BasicTypesReflection.Descriptor, global::Hedera.Hashgraph.Proto.DurationReflection.Descriptor, global::Hedera.Hashgraph.Proto.TimestampReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.WrappersReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Hedera.Hashgraph.Proto.TokenUpdateTransactionBody), global::Hedera.Hashgraph.Proto.TokenUpdateTransactionBody.Parser, new[]{ "Token", "Symbol", "Name", "Treasury", "AdminKey", "KycKey", "FreezeKey", "WipeKey", "SupplyKey", "AutoRenewAccount", "AutoRenewPeriod", "Expiry", "Memo", "FeeScheduleKey", "PauseKey", "Metadata", "MetadataKey", "KeyVerificationMode" }, null, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  ///*
  /// Update an existing token.
  ///
  /// This transaction SHALL NOT update any field that is not set.&lt;br/>
  /// Most changes MUST be signed by the current `admin_key` of the token. If the
  /// token does not currently have a valid `admin_key`, then this transaction
  /// MUST NOT set any value other than `expiry` or a non-admin key.&lt;br/>
  /// If the `treasury` is set to a new account, the new account MUST sign this
  /// transaction.&lt;br/>
  /// If the `treasury` is set to a new account for a _non-fungible/unique_ token,
  /// The current treasury MAY hold some tokens.
  ///
  /// #### Requirements for Keys
  /// Any of the key values may be changed, even without an admin key, but the
  /// key to be changed MUST have an existing valid key assigned, and both the
  /// current key and the new key MUST sign the transaction.&lt;br/>
  /// A key value MAY be set to an empty `KeyList`. In this case the existing
  /// key MUST sign this transaction, but the new value is not a valid key, and the
  /// update SHALL effectively remove the existing key.
  ///
  /// ### Block Stream Effects
  /// None
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class TokenUpdateTransactionBody : pb::IMessage<TokenUpdateTransactionBody>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<TokenUpdateTransactionBody> _parser = new pb::MessageParser<TokenUpdateTransactionBody>(() => new TokenUpdateTransactionBody());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<TokenUpdateTransactionBody> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Hedera.Hashgraph.Proto.TokenUpdateReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TokenUpdateTransactionBody() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TokenUpdateTransactionBody(TokenUpdateTransactionBody other) : this() {
      token_ = other.token_ != null ? other.token_.Clone() : null;
      symbol_ = other.symbol_;
      name_ = other.name_;
      treasury_ = other.treasury_ != null ? other.treasury_.Clone() : null;
      adminKey_ = other.adminKey_ != null ? other.adminKey_.Clone() : null;
      kycKey_ = other.kycKey_ != null ? other.kycKey_.Clone() : null;
      freezeKey_ = other.freezeKey_ != null ? other.freezeKey_.Clone() : null;
      wipeKey_ = other.wipeKey_ != null ? other.wipeKey_.Clone() : null;
      supplyKey_ = other.supplyKey_ != null ? other.supplyKey_.Clone() : null;
      autoRenewAccount_ = other.autoRenewAccount_ != null ? other.autoRenewAccount_.Clone() : null;
      autoRenewPeriod_ = other.autoRenewPeriod_ != null ? other.autoRenewPeriod_.Clone() : null;
      expiry_ = other.expiry_ != null ? other.expiry_.Clone() : null;
      Memo = other.Memo;
      feeScheduleKey_ = other.feeScheduleKey_ != null ? other.feeScheduleKey_.Clone() : null;
      pauseKey_ = other.pauseKey_ != null ? other.pauseKey_.Clone() : null;
      Metadata = other.Metadata;
      metadataKey_ = other.metadataKey_ != null ? other.metadataKey_.Clone() : null;
      keyVerificationMode_ = other.keyVerificationMode_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TokenUpdateTransactionBody Clone() {
      return new TokenUpdateTransactionBody(this);
    }

    /// <summary>Field number for the "token" field.</summary>
    public const int TokenFieldNumber = 1;
    private global::Hedera.Hashgraph.Proto.TokenID token_;
    /// <summary>
    ///*
    /// A token identifier.
    /// &lt;p>
    /// This SHALL identify the token type to delete.&lt;br/>
    /// The identified token MUST exist, and MUST NOT be deleted.&lt;br/>
    /// If any field other than `expiry` is set, the identified token MUST
    /// have a valid `admin_key`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Hedera.Hashgraph.Proto.TokenID Token {
      get { return token_; }
      set {
        token_ = value;
      }
    }

    /// <summary>Field number for the "symbol" field.</summary>
    public const int SymbolFieldNumber = 2;
    private string symbol_ = "";
    /// <summary>
    ///*
    /// A new symbol to use for the token.
    /// &lt;p>
    /// This value, if set, MUST NOT exceed 100 bytes when encoded as UTF-8.&lt;br/>
    /// This value, if set, MUST NOT contain the Unicode NUL codepoint.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Symbol {
      get { return symbol_; }
      set {
        symbol_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 3;
    private string name_ = "";
    /// <summary>
    ///*
    /// A new name for the token.&lt;br/>
    /// This is generally the "full name" displayed in wallet software.
    /// &lt;p>
    /// This value, if set, MUST NOT exceed 100 bytes when encoded as UTF-8.&lt;br/>
    /// This value, if set, MUST NOT contain the Unicode NUL codepoint.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "treasury" field.</summary>
    public const int TreasuryFieldNumber = 4;
    private global::Hedera.Hashgraph.Proto.AccountID treasury_;
    /// <summary>
    ///*
    /// A new treasury account identifier.
    /// &lt;p>
    /// If set,
    /// - The identified account SHALL be designated the "treasury" for the
    ///   token, and all tokens "minted" SHALL be delivered to that account
    ///   following this transaction.&lt;br/>
    /// - The identified account MUST exist, MUST NOT be expired, MUST NOT be
    ///   deleted, and SHOULD have a non-zero HBAR balance.&lt;br/>
    /// - The identified account SHALL be associated to this token.
    /// - The full balance of this token held by the prior treasury account
    ///   SHALL be transferred to the new treasury account, if the token type
    ///   is fungible/common.
    /// - If the token type is non-fungible/unique, the previous treasury
    ///   account MUST NOT hold any tokens of this type.
    /// - The new treasury account key MUST sign this transaction.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Hedera.Hashgraph.Proto.AccountID Treasury {
      get { return treasury_; }
      set {
        treasury_ = value;
      }
    }

    /// <summary>Field number for the "adminKey" field.</summary>
    public const int AdminKeyFieldNumber = 5;
    private global::Hedera.Hashgraph.Proto.Key adminKey_;
    /// <summary>
    ///*
    /// An Hedera key for token administration.
    /// &lt;p>
    /// This key, if set, SHALL have administrative authority for this token and
    /// MAY authorize token update and/or token delete transactions.&lt;br/>
    /// If this key is set to an empty `KeyList`, this token SHALL be
    /// immutable thereafter, except for expiration and renewal.&lt;br/>
    /// If set, this key MUST be a valid key or an empty `KeyList`.&lt;br/>
    /// If set to a valid key, the previous key and new key MUST both
    /// sign this transaction.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Hedera.Hashgraph.Proto.Key AdminKey {
      get { return adminKey_; }
      set {
        adminKey_ = value;
      }
    }

    /// <summary>Field number for the "kycKey" field.</summary>
    public const int KycKeyFieldNumber = 6;
    private global::Hedera.Hashgraph.Proto.Key kycKey_;
    /// <summary>
    ///*
    /// An Hedera key for managing account KYC.
    /// &lt;p>
    /// This key, if set, SHALL have KYC authority for this token and
    /// MAY authorize transactions to grant or revoke KYC for accounts.&lt;br/>
    /// If this key is not set, or is an empty `KeyList`, KYC status for this
    /// token SHALL NOT be granted or revoked for any account.&lt;br/>
    /// If this key is removed after granting KYC, those grants SHALL remain
    /// and cannot be revoked.&lt;br/>
    /// If set, this key MUST be a valid key or an empty `KeyList`.&lt;br/>
    /// If set to a valid key, the previous key and new key MUST both
    /// sign this transaction.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Hedera.Hashgraph.Proto.Key KycKey {
      get { return kycKey_; }
      set {
        kycKey_ = value;
      }
    }

    /// <summary>Field number for the "freezeKey" field.</summary>
    public const int FreezeKeyFieldNumber = 7;
    private global::Hedera.Hashgraph.Proto.Key freezeKey_;
    /// <summary>
    ///*
    /// An Hedera key for managing asset "freeze".
    /// &lt;p>
    /// This key, if set, SHALL have "freeze" authority for this token and
    /// MAY authorize transactions to freeze or unfreeze accounts
    /// with respect to this token.&lt;br/>
    /// If this key is set to an empty `KeyList`, this token
    /// SHALL NOT be frozen or unfrozen for any account.&lt;br/>
    /// If this key is removed after freezing accounts, those accounts
    /// SHALL remain frozen and cannot be unfrozen.&lt;br/>
    /// If set, this key MUST be a valid key or an empty `KeyList`.&lt;br/>
    /// If set to a valid key, the previous key and new key MUST both
    /// sign this transaction.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Hedera.Hashgraph.Proto.Key FreezeKey {
      get { return freezeKey_; }
      set {
        freezeKey_ = value;
      }
    }

    /// <summary>Field number for the "wipeKey" field.</summary>
    public const int WipeKeyFieldNumber = 8;
    private global::Hedera.Hashgraph.Proto.Key wipeKey_;
    /// <summary>
    ///*
    /// An Hedera key for wiping tokens from accounts.
    /// &lt;p>
    /// This key, if set, SHALL have "wipe" authority for this token and
    /// MAY authorize transactions to "wipe" any amount of this token from
    /// any account, effectively burning the tokens "wiped".&lt;br/>
    /// If this key is set to an empty `KeyList`, it SHALL NOT be
    /// possible to "wipe" this token from an account.&lt;br/>
    /// If set, this key MUST be a valid key or an empty `KeyList`.&lt;br/>
    /// If set to a valid key, the previous key and new key MUST both
    /// sign this transaction.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Hedera.Hashgraph.Proto.Key WipeKey {
      get { return wipeKey_; }
      set {
        wipeKey_ = value;
      }
    }

    /// <summary>Field number for the "supplyKey" field.</summary>
    public const int SupplyKeyFieldNumber = 9;
    private global::Hedera.Hashgraph.Proto.Key supplyKey_;
    /// <summary>
    ///*
    /// An Hedera key for "minting" and "burning" tokens.
    /// &lt;p>
    /// This key, if set, MAY authorize transactions to "mint" new tokens to
    /// be delivered to the token treasury or "burn" tokens held by the
    /// token treasury.&lt;br/>
    /// If this key is set to an empty `KeyList`, it SHALL NOT be
    /// possible to change the supply of tokens and neither "mint" nor "burn"
    /// transactions SHALL be permitted.&lt;br/>
    /// If set, this key MUST be a valid key or an empty `KeyList`.&lt;br/>
    /// If set to a valid key, the previous key and new key MUST both
    /// sign this transaction.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Hedera.Hashgraph.Proto.Key SupplyKey {
      get { return supplyKey_; }
      set {
        supplyKey_ = value;
      }
    }

    /// <summary>Field number for the "autoRenewAccount" field.</summary>
    public const int AutoRenewAccountFieldNumber = 10;
    private global::Hedera.Hashgraph.Proto.AccountID autoRenewAccount_;
    /// <summary>
    ///*
    /// An identifier for the account to be charged renewal fees at the token's
    /// expiry to extend the lifetime of the token.
    /// &lt;p>
    /// If this value is set for the identified token, the token lifetime SHALL
    /// be extended by the _smallest_ of the following at expiration:
    /// &lt;ul>
    ///   &lt;li>The current `autoRenewPeriod` duration.&lt;/li>
    ///   &lt;li>The maximum duration that this account has funds to purchase.&lt;/li>
    ///   &lt;li>The configured MAX_AUTORENEW_PERIOD at the time of automatic
    ///       renewal.&lt;/li>
    /// &lt;/ul>
    /// If this account's HBAR balance is `0` when the token must be
    /// renewed, then the token SHALL be expired, and MAY be subsequently
    /// removed from state.&lt;br/>
    /// If this value is set, the referenced account MUST sign this
    /// transaction.
    /// &lt;p>
    /// &lt;blockquote>Note&lt;blockquote>
    /// It is not currently possible to remove an automatic renewal account.
    /// Once set, it can only be replaced by a valid account.
    /// &lt;/blockquote>&lt;/blockquote>
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Hedera.Hashgraph.Proto.AccountID AutoRenewAccount {
      get { return autoRenewAccount_; }
      set {
        autoRenewAccount_ = value;
      }
    }

    /// <summary>Field number for the "autoRenewPeriod" field.</summary>
    public const int AutoRenewPeriodFieldNumber = 11;
    private global::Hedera.Hashgraph.Proto.Duration autoRenewPeriod_;
    /// <summary>
    ///*
    /// A duration between token automatic renewals.&lt;br/>
    /// All entities in state may be charged "rent" occasionally (typically
    /// every 90 days) to prevent unnecessary growth of the ledger. This value
    /// sets the interval between such events for this token.
    /// &lt;p>
    /// If set, this value MUST be greater than the configured
    /// `MIN_AUTORENEW_PERIOD`.&lt;br/>
    /// If set, this value MUST be less than the configured
    /// `MAX_AUTORENEW_PERIOD`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Hedera.Hashgraph.Proto.Duration AutoRenewPeriod {
      get { return autoRenewPeriod_; }
      set {
        autoRenewPeriod_ = value;
      }
    }

    /// <summary>Field number for the "expiry" field.</summary>
    public const int ExpiryFieldNumber = 12;
    private global::Hedera.Hashgraph.Proto.Timestamp expiry_;
    /// <summary>
    ///*
    /// An expiration timestamp.
    /// &lt;p>
    /// If this value is set, the automatic renewal account is not set for the
    /// identified token, and token expiration is enabled in network
    /// configuration, this token SHALL expire when the consensus time exceeds
    /// this value, and MAY be subsequently removed from the network state.&lt;br/>
    /// If `autoRenewAccount` is set or the `auto_renew_account_id` is set for
    /// the identified token, the token SHALL be subject to automatic renewal
    /// when the consensus time exceeds this value.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Hedera.Hashgraph.Proto.Timestamp Expiry {
      get { return expiry_; }
      set {
        expiry_ = value;
      }
    }

    /// <summary>Field number for the "memo" field.</summary>
    public const int MemoFieldNumber = 13;
    private static readonly pb::FieldCodec<string> _single_memo_codec = pb::FieldCodec.ForClassWrapper<string>(106);
    private string memo_;
    /// <summary>
    ///*
    /// A short description for this token.
    /// &lt;p>
    /// This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
    /// (default 100) bytes when encoded as UTF-8.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Memo {
      get { return memo_; }
      set {
        memo_ = value;
      }
    }


    /// <summary>Field number for the "fee_schedule_key" field.</summary>
    public const int FeeScheduleKeyFieldNumber = 14;
    private global::Hedera.Hashgraph.Proto.Key feeScheduleKey_;
    /// <summary>
    ///*
    /// An Hedera key for managing the token custom fee schedule.
    /// &lt;p>
    /// This key, if set, MAY authorize transactions to modify the
    /// `custom_fees` for this token.&lt;br/>
    /// If this key is set to an empty `KeyList`, the `custom_fees`
    /// for this token SHALL NOT be modified.&lt;br/>
    /// If set, this key MUST be a valid key or an empty `KeyList`.&lt;br/>
    /// If set to a valid key, the previous key and new key MUST both
    /// sign this transaction.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Hedera.Hashgraph.Proto.Key FeeScheduleKey {
      get { return feeScheduleKey_; }
      set {
        feeScheduleKey_ = value;
      }
    }

    /// <summary>Field number for the "pause_key" field.</summary>
    public const int PauseKeyFieldNumber = 15;
    private global::Hedera.Hashgraph.Proto.Key pauseKey_;
    /// <summary>
    ///*
    /// An Hedera key for managing token "pause".
    /// &lt;p>
    /// This key, if set, SHALL have "pause" authority for this token and
    /// MAY authorize transactions to pause or unpause this token.&lt;br/>
    /// If this key is set to an empty `KeyList`, this token
    /// SHALL NOT be paused or unpaused.&lt;br/>
    /// If this key is removed while the token is paused, the token cannot
    /// be unpaused and SHALL remain paused.&lt;br/>
    /// If set, this key MUST be a valid key or an empty `KeyList`.&lt;br/>
    /// If set to a valid key, the previous key and new key MUST both
    /// sign this transaction.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Hedera.Hashgraph.Proto.Key PauseKey {
      get { return pauseKey_; }
      set {
        pauseKey_ = value;
      }
    }

    /// <summary>Field number for the "metadata" field.</summary>
    public const int MetadataFieldNumber = 16;
    private static readonly pb::FieldCodec<pb::ByteString> _single_metadata_codec = pb::FieldCodec.ForClassWrapper<pb::ByteString>(130);
    private pb::ByteString metadata_;
    /// <summary>
    ///*
    /// Token "Metadata".
    /// &lt;p>
    /// The value, if set, MUST NOT exceed 100 bytes.&lt;br/>
    /// &lt;dl>&lt;dt>Examples&lt;/dt>
    ///   &lt;dd>hcs://1/0.0.4896575&lt;/dd>
    ///   &lt;dd>ipfs://bafkreifd7tcjjuwxxf4qkaibkj62pj4mhfuud7plwrc3pfoygt55al6syi&lt;/dd>
    /// &lt;/dl>
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString Metadata {
      get { return metadata_; }
      set {
        metadata_ = value;
      }
    }


    /// <summary>Field number for the "metadata_key" field.</summary>
    public const int MetadataKeyFieldNumber = 17;
    private global::Hedera.Hashgraph.Proto.Key metadataKey_;
    /// <summary>
    ///*
    /// An Hedera key for managing the token `metadata`.
    /// &lt;p>
    /// This key, if set, MAY authorize transactions to modify the
    /// `metadata` for this token.&lt;br/>
    /// If this key is set to an empty `KeyList`, the `metadata`
    /// for this token SHALL NOT be modified.&lt;br/>
    /// If set, this key MUST be a valid key or an empty `KeyList`.&lt;br/>
    /// If set to a valid key, the previous key and new key MUST both
    /// sign this transaction.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Hedera.Hashgraph.Proto.Key MetadataKey {
      get { return metadataKey_; }
      set {
        metadataKey_ = value;
      }
    }

    /// <summary>Field number for the "key_verification_mode" field.</summary>
    public const int KeyVerificationModeFieldNumber = 18;
    private global::Hedera.Hashgraph.Proto.TokenKeyValidation keyVerificationMode_ = global::Hedera.Hashgraph.Proto.TokenKeyValidation.FullValidation;
    /// <summary>
    ///*
    /// Set a key validation mode.&lt;br/>
    /// Any key may be updated by a transaction signed by the token `admin_key`.
    /// Each role key may _also_ sign a transaction to update that key.
    /// If a role key signs an update to change that role key both old
    /// and new key must sign the transaction, _unless_ this field is set
    /// to `NO_VALIDATION`, in which case the _new_ key is not required to
    /// sign the transaction (the existing key is still required).&lt;br/>
    /// The primary intent for this field is to allow a role key (e.g. a
    /// `pause_key`) holder to "remove" that key from the token by signing
    /// a transaction to set that role key to an empty `KeyList`.
    /// &lt;p>
    /// If set to `FULL_VALIDATION`, either the `admin_key` or _both_ current
    /// and new key MUST sign this transaction to update a "key" field for the
    /// identified token.&lt;br/>
    /// If set to `NO_VALIDATION`, either the `admin_key` or the current
    /// key MUST sign this transaction to update a "key" field for the
    /// identified token.&lt;br/>
    /// This field SHALL be treated as `FULL_VALIDATION` if not set.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Hedera.Hashgraph.Proto.TokenKeyValidation KeyVerificationMode {
      get { return keyVerificationMode_; }
      set {
        keyVerificationMode_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as TokenUpdateTransactionBody);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(TokenUpdateTransactionBody other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Token, other.Token)) return false;
      if (Symbol != other.Symbol) return false;
      if (Name != other.Name) return false;
      if (!object.Equals(Treasury, other.Treasury)) return false;
      if (!object.Equals(AdminKey, other.AdminKey)) return false;
      if (!object.Equals(KycKey, other.KycKey)) return false;
      if (!object.Equals(FreezeKey, other.FreezeKey)) return false;
      if (!object.Equals(WipeKey, other.WipeKey)) return false;
      if (!object.Equals(SupplyKey, other.SupplyKey)) return false;
      if (!object.Equals(AutoRenewAccount, other.AutoRenewAccount)) return false;
      if (!object.Equals(AutoRenewPeriod, other.AutoRenewPeriod)) return false;
      if (!object.Equals(Expiry, other.Expiry)) return false;
      if (Memo != other.Memo) return false;
      if (!object.Equals(FeeScheduleKey, other.FeeScheduleKey)) return false;
      if (!object.Equals(PauseKey, other.PauseKey)) return false;
      if (Metadata != other.Metadata) return false;
      if (!object.Equals(MetadataKey, other.MetadataKey)) return false;
      if (KeyVerificationMode != other.KeyVerificationMode) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (token_ != null) hash ^= Token.GetHashCode();
      if (Symbol.Length != 0) hash ^= Symbol.GetHashCode();
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (treasury_ != null) hash ^= Treasury.GetHashCode();
      if (adminKey_ != null) hash ^= AdminKey.GetHashCode();
      if (kycKey_ != null) hash ^= KycKey.GetHashCode();
      if (freezeKey_ != null) hash ^= FreezeKey.GetHashCode();
      if (wipeKey_ != null) hash ^= WipeKey.GetHashCode();
      if (supplyKey_ != null) hash ^= SupplyKey.GetHashCode();
      if (autoRenewAccount_ != null) hash ^= AutoRenewAccount.GetHashCode();
      if (autoRenewPeriod_ != null) hash ^= AutoRenewPeriod.GetHashCode();
      if (expiry_ != null) hash ^= Expiry.GetHashCode();
      if (memo_ != null) hash ^= Memo.GetHashCode();
      if (feeScheduleKey_ != null) hash ^= FeeScheduleKey.GetHashCode();
      if (pauseKey_ != null) hash ^= PauseKey.GetHashCode();
      if (metadata_ != null) hash ^= Metadata.GetHashCode();
      if (metadataKey_ != null) hash ^= MetadataKey.GetHashCode();
      if (KeyVerificationMode != global::Hedera.Hashgraph.Proto.TokenKeyValidation.FullValidation) hash ^= KeyVerificationMode.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (token_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Token);
      }
      if (Symbol.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Symbol);
      }
      if (Name.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(Name);
      }
      if (treasury_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(Treasury);
      }
      if (adminKey_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(AdminKey);
      }
      if (kycKey_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(KycKey);
      }
      if (freezeKey_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(FreezeKey);
      }
      if (wipeKey_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(WipeKey);
      }
      if (supplyKey_ != null) {
        output.WriteRawTag(74);
        output.WriteMessage(SupplyKey);
      }
      if (autoRenewAccount_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(AutoRenewAccount);
      }
      if (autoRenewPeriod_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(AutoRenewPeriod);
      }
      if (expiry_ != null) {
        output.WriteRawTag(98);
        output.WriteMessage(Expiry);
      }
      if (memo_ != null) {
        _single_memo_codec.WriteTagAndValue(output, Memo);
      }
      if (feeScheduleKey_ != null) {
        output.WriteRawTag(114);
        output.WriteMessage(FeeScheduleKey);
      }
      if (pauseKey_ != null) {
        output.WriteRawTag(122);
        output.WriteMessage(PauseKey);
      }
      if (metadata_ != null) {
        _single_metadata_codec.WriteTagAndValue(output, Metadata);
      }
      if (metadataKey_ != null) {
        output.WriteRawTag(138, 1);
        output.WriteMessage(MetadataKey);
      }
      if (KeyVerificationMode != global::Hedera.Hashgraph.Proto.TokenKeyValidation.FullValidation) {
        output.WriteRawTag(144, 1);
        output.WriteEnum((int) KeyVerificationMode);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (token_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Token);
      }
      if (Symbol.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Symbol);
      }
      if (Name.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(Name);
      }
      if (treasury_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(Treasury);
      }
      if (adminKey_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(AdminKey);
      }
      if (kycKey_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(KycKey);
      }
      if (freezeKey_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(FreezeKey);
      }
      if (wipeKey_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(WipeKey);
      }
      if (supplyKey_ != null) {
        output.WriteRawTag(74);
        output.WriteMessage(SupplyKey);
      }
      if (autoRenewAccount_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(AutoRenewAccount);
      }
      if (autoRenewPeriod_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(AutoRenewPeriod);
      }
      if (expiry_ != null) {
        output.WriteRawTag(98);
        output.WriteMessage(Expiry);
      }
      if (memo_ != null) {
        _single_memo_codec.WriteTagAndValue(ref output, Memo);
      }
      if (feeScheduleKey_ != null) {
        output.WriteRawTag(114);
        output.WriteMessage(FeeScheduleKey);
      }
      if (pauseKey_ != null) {
        output.WriteRawTag(122);
        output.WriteMessage(PauseKey);
      }
      if (metadata_ != null) {
        _single_metadata_codec.WriteTagAndValue(ref output, Metadata);
      }
      if (metadataKey_ != null) {
        output.WriteRawTag(138, 1);
        output.WriteMessage(MetadataKey);
      }
      if (KeyVerificationMode != global::Hedera.Hashgraph.Proto.TokenKeyValidation.FullValidation) {
        output.WriteRawTag(144, 1);
        output.WriteEnum((int) KeyVerificationMode);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (token_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Token);
      }
      if (Symbol.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Symbol);
      }
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (treasury_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Treasury);
      }
      if (adminKey_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(AdminKey);
      }
      if (kycKey_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(KycKey);
      }
      if (freezeKey_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(FreezeKey);
      }
      if (wipeKey_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(WipeKey);
      }
      if (supplyKey_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SupplyKey);
      }
      if (autoRenewAccount_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(AutoRenewAccount);
      }
      if (autoRenewPeriod_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(AutoRenewPeriod);
      }
      if (expiry_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Expiry);
      }
      if (memo_ != null) {
        size += _single_memo_codec.CalculateSizeWithTag(Memo);
      }
      if (feeScheduleKey_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(FeeScheduleKey);
      }
      if (pauseKey_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(PauseKey);
      }
      if (metadata_ != null) {
        size += _single_metadata_codec.CalculateSizeWithTag(Metadata);
      }
      if (metadataKey_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(MetadataKey);
      }
      if (KeyVerificationMode != global::Hedera.Hashgraph.Proto.TokenKeyValidation.FullValidation) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) KeyVerificationMode);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(TokenUpdateTransactionBody other) {
      if (other == null) {
        return;
      }
      if (other.token_ != null) {
        if (token_ == null) {
          Token = new global::Hedera.Hashgraph.Proto.TokenID();
        }
        Token.MergeFrom(other.Token);
      }
      if (other.Symbol.Length != 0) {
        Symbol = other.Symbol;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.treasury_ != null) {
        if (treasury_ == null) {
          Treasury = new global::Hedera.Hashgraph.Proto.AccountID();
        }
        Treasury.MergeFrom(other.Treasury);
      }
      if (other.adminKey_ != null) {
        if (adminKey_ == null) {
          AdminKey = new global::Hedera.Hashgraph.Proto.Key();
        }
        AdminKey.MergeFrom(other.AdminKey);
      }
      if (other.kycKey_ != null) {
        if (kycKey_ == null) {
          KycKey = new global::Hedera.Hashgraph.Proto.Key();
        }
        KycKey.MergeFrom(other.KycKey);
      }
      if (other.freezeKey_ != null) {
        if (freezeKey_ == null) {
          FreezeKey = new global::Hedera.Hashgraph.Proto.Key();
        }
        FreezeKey.MergeFrom(other.FreezeKey);
      }
      if (other.wipeKey_ != null) {
        if (wipeKey_ == null) {
          WipeKey = new global::Hedera.Hashgraph.Proto.Key();
        }
        WipeKey.MergeFrom(other.WipeKey);
      }
      if (other.supplyKey_ != null) {
        if (supplyKey_ == null) {
          SupplyKey = new global::Hedera.Hashgraph.Proto.Key();
        }
        SupplyKey.MergeFrom(other.SupplyKey);
      }
      if (other.autoRenewAccount_ != null) {
        if (autoRenewAccount_ == null) {
          AutoRenewAccount = new global::Hedera.Hashgraph.Proto.AccountID();
        }
        AutoRenewAccount.MergeFrom(other.AutoRenewAccount);
      }
      if (other.autoRenewPeriod_ != null) {
        if (autoRenewPeriod_ == null) {
          AutoRenewPeriod = new global::Hedera.Hashgraph.Proto.Duration();
        }
        AutoRenewPeriod.MergeFrom(other.AutoRenewPeriod);
      }
      if (other.expiry_ != null) {
        if (expiry_ == null) {
          Expiry = new global::Hedera.Hashgraph.Proto.Timestamp();
        }
        Expiry.MergeFrom(other.Expiry);
      }
      if (other.memo_ != null) {
        if (memo_ == null || other.Memo != "") {
          Memo = other.Memo;
        }
      }
      if (other.feeScheduleKey_ != null) {
        if (feeScheduleKey_ == null) {
          FeeScheduleKey = new global::Hedera.Hashgraph.Proto.Key();
        }
        FeeScheduleKey.MergeFrom(other.FeeScheduleKey);
      }
      if (other.pauseKey_ != null) {
        if (pauseKey_ == null) {
          PauseKey = new global::Hedera.Hashgraph.Proto.Key();
        }
        PauseKey.MergeFrom(other.PauseKey);
      }
      if (other.metadata_ != null) {
        if (metadata_ == null || other.Metadata != pb::ByteString.Empty) {
          Metadata = other.Metadata;
        }
      }
      if (other.metadataKey_ != null) {
        if (metadataKey_ == null) {
          MetadataKey = new global::Hedera.Hashgraph.Proto.Key();
        }
        MetadataKey.MergeFrom(other.MetadataKey);
      }
      if (other.KeyVerificationMode != global::Hedera.Hashgraph.Proto.TokenKeyValidation.FullValidation) {
        KeyVerificationMode = other.KeyVerificationMode;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (token_ == null) {
              Token = new global::Hedera.Hashgraph.Proto.TokenID();
            }
            input.ReadMessage(Token);
            break;
          }
          case 18: {
            Symbol = input.ReadString();
            break;
          }
          case 26: {
            Name = input.ReadString();
            break;
          }
          case 34: {
            if (treasury_ == null) {
              Treasury = new global::Hedera.Hashgraph.Proto.AccountID();
            }
            input.ReadMessage(Treasury);
            break;
          }
          case 42: {
            if (adminKey_ == null) {
              AdminKey = new global::Hedera.Hashgraph.Proto.Key();
            }
            input.ReadMessage(AdminKey);
            break;
          }
          case 50: {
            if (kycKey_ == null) {
              KycKey = new global::Hedera.Hashgraph.Proto.Key();
            }
            input.ReadMessage(KycKey);
            break;
          }
          case 58: {
            if (freezeKey_ == null) {
              FreezeKey = new global::Hedera.Hashgraph.Proto.Key();
            }
            input.ReadMessage(FreezeKey);
            break;
          }
          case 66: {
            if (wipeKey_ == null) {
              WipeKey = new global::Hedera.Hashgraph.Proto.Key();
            }
            input.ReadMessage(WipeKey);
            break;
          }
          case 74: {
            if (supplyKey_ == null) {
              SupplyKey = new global::Hedera.Hashgraph.Proto.Key();
            }
            input.ReadMessage(SupplyKey);
            break;
          }
          case 82: {
            if (autoRenewAccount_ == null) {
              AutoRenewAccount = new global::Hedera.Hashgraph.Proto.AccountID();
            }
            input.ReadMessage(AutoRenewAccount);
            break;
          }
          case 90: {
            if (autoRenewPeriod_ == null) {
              AutoRenewPeriod = new global::Hedera.Hashgraph.Proto.Duration();
            }
            input.ReadMessage(AutoRenewPeriod);
            break;
          }
          case 98: {
            if (expiry_ == null) {
              Expiry = new global::Hedera.Hashgraph.Proto.Timestamp();
            }
            input.ReadMessage(Expiry);
            break;
          }
          case 106: {
            string value = _single_memo_codec.Read(input);
            if (memo_ == null || value != "") {
              Memo = value;
            }
            break;
          }
          case 114: {
            if (feeScheduleKey_ == null) {
              FeeScheduleKey = new global::Hedera.Hashgraph.Proto.Key();
            }
            input.ReadMessage(FeeScheduleKey);
            break;
          }
          case 122: {
            if (pauseKey_ == null) {
              PauseKey = new global::Hedera.Hashgraph.Proto.Key();
            }
            input.ReadMessage(PauseKey);
            break;
          }
          case 130: {
            pb::ByteString value = _single_metadata_codec.Read(input);
            if (metadata_ == null || value != pb::ByteString.Empty) {
              Metadata = value;
            }
            break;
          }
          case 138: {
            if (metadataKey_ == null) {
              MetadataKey = new global::Hedera.Hashgraph.Proto.Key();
            }
            input.ReadMessage(MetadataKey);
            break;
          }
          case 144: {
            KeyVerificationMode = (global::Hedera.Hashgraph.Proto.TokenKeyValidation) input.ReadEnum();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (token_ == null) {
              Token = new global::Hedera.Hashgraph.Proto.TokenID();
            }
            input.ReadMessage(Token);
            break;
          }
          case 18: {
            Symbol = input.ReadString();
            break;
          }
          case 26: {
            Name = input.ReadString();
            break;
          }
          case 34: {
            if (treasury_ == null) {
              Treasury = new global::Hedera.Hashgraph.Proto.AccountID();
            }
            input.ReadMessage(Treasury);
            break;
          }
          case 42: {
            if (adminKey_ == null) {
              AdminKey = new global::Hedera.Hashgraph.Proto.Key();
            }
            input.ReadMessage(AdminKey);
            break;
          }
          case 50: {
            if (kycKey_ == null) {
              KycKey = new global::Hedera.Hashgraph.Proto.Key();
            }
            input.ReadMessage(KycKey);
            break;
          }
          case 58: {
            if (freezeKey_ == null) {
              FreezeKey = new global::Hedera.Hashgraph.Proto.Key();
            }
            input.ReadMessage(FreezeKey);
            break;
          }
          case 66: {
            if (wipeKey_ == null) {
              WipeKey = new global::Hedera.Hashgraph.Proto.Key();
            }
            input.ReadMessage(WipeKey);
            break;
          }
          case 74: {
            if (supplyKey_ == null) {
              SupplyKey = new global::Hedera.Hashgraph.Proto.Key();
            }
            input.ReadMessage(SupplyKey);
            break;
          }
          case 82: {
            if (autoRenewAccount_ == null) {
              AutoRenewAccount = new global::Hedera.Hashgraph.Proto.AccountID();
            }
            input.ReadMessage(AutoRenewAccount);
            break;
          }
          case 90: {
            if (autoRenewPeriod_ == null) {
              AutoRenewPeriod = new global::Hedera.Hashgraph.Proto.Duration();
            }
            input.ReadMessage(AutoRenewPeriod);
            break;
          }
          case 98: {
            if (expiry_ == null) {
              Expiry = new global::Hedera.Hashgraph.Proto.Timestamp();
            }
            input.ReadMessage(Expiry);
            break;
          }
          case 106: {
            string value = _single_memo_codec.Read(ref input);
            if (memo_ == null || value != "") {
              Memo = value;
            }
            break;
          }
          case 114: {
            if (feeScheduleKey_ == null) {
              FeeScheduleKey = new global::Hedera.Hashgraph.Proto.Key();
            }
            input.ReadMessage(FeeScheduleKey);
            break;
          }
          case 122: {
            if (pauseKey_ == null) {
              PauseKey = new global::Hedera.Hashgraph.Proto.Key();
            }
            input.ReadMessage(PauseKey);
            break;
          }
          case 130: {
            pb::ByteString value = _single_metadata_codec.Read(ref input);
            if (metadata_ == null || value != pb::ByteString.Empty) {
              Metadata = value;
            }
            break;
          }
          case 138: {
            if (metadataKey_ == null) {
              MetadataKey = new global::Hedera.Hashgraph.Proto.Key();
            }
            input.ReadMessage(MetadataKey);
            break;
          }
          case 144: {
            KeyVerificationMode = (global::Hedera.Hashgraph.Proto.TokenKeyValidation) input.ReadEnum();
            break;
          }
        }
      }
    }
    #endif

  }

  #endregion

}

#endregion Designer generated code
