// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: crypto_create.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021, 8981
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Proto {

  /// <summary>Holder for reflection information generated from crypto_create.proto</summary>
  public static partial class CryptoCreateReflection {

    #region Descriptor
    /// <summary>File descriptor for crypto_create.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static CryptoCreateReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "ChNjcnlwdG9fY3JlYXRlLnByb3RvEgVwcm90bxoRYmFzaWNfdHlwZXMucHJv",
            "dG8aDmR1cmF0aW9uLnByb3RvGhBob29rX3R5cGVzLnByb3RvIoUFChtDcnlw",
            "dG9DcmVhdGVUcmFuc2FjdGlvbkJvZHkSFwoDa2V5GAEgASgLMgoucHJvdG8u",
            "S2V5EhYKDmluaXRpYWxCYWxhbmNlGAIgASgEEiwKDnByb3h5QWNjb3VudElE",
            "GAMgASgLMhAucHJvdG8uQWNjb3VudElEQgIYARIfChNzZW5kUmVjb3JkVGhy",
            "ZXNob2xkGAYgASgEQgIYARIiChZyZWNlaXZlUmVjb3JkVGhyZXNob2xkGAcg",
            "ASgEQgIYARIbChNyZWNlaXZlclNpZ1JlcXVpcmVkGAggASgIEigKD2F1dG9S",
            "ZW5ld1BlcmlvZBgJIAEoCzIPLnByb3RvLkR1cmF0aW9uEh8KB3NoYXJkSUQY",
            "CiABKAsyDi5wcm90by5TaGFyZElEEh8KB3JlYWxtSUQYCyABKAsyDi5wcm90",
            "by5SZWFsbUlEEigKEG5ld1JlYWxtQWRtaW5LZXkYDCABKAsyCi5wcm90by5L",
            "ZXlCAhgBEgwKBG1lbW8YDSABKAkSKAogbWF4X2F1dG9tYXRpY190b2tlbl9h",
            "c3NvY2lhdGlvbnMYDiABKAUSLQoRc3Rha2VkX2FjY291bnRfaWQYDyABKAsy",
            "EC5wcm90by5BY2NvdW50SURIABIYCg5zdGFrZWRfbm9kZV9pZBgQIAEoA0gA",
            "EhYKDmRlY2xpbmVfcmV3YXJkGBEgASgIEg0KBWFsaWFzGBIgASgMEk4KFWhv",
            "b2tfY3JlYXRpb25fZGV0YWlscxgTIAMoCzIvLmNvbS5oZWRlcmEuaGFwaS5u",
            "b2RlLmhvb2tzLkhvb2tDcmVhdGlvbkRldGFpbHNCCwoJc3Rha2VkX2lkSgQI",
            "BBAFSgQIBRAGQiIKHmNvbS5oZWRlcmEuaGFzaGdyYXBoLnNkay5wcm90b1AB",
            "YgZwcm90bzM="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Proto.BasicTypesReflection.Descriptor, global::Proto.DurationReflection.Descriptor, global::Com.Hedera.Hapi.Node.Hooks.HookTypesReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Proto.CryptoCreateTransactionBody), global::Proto.CryptoCreateTransactionBody.Parser, new[]{ "Key", "InitialBalance", "ProxyAccountID", "SendRecordThreshold", "ReceiveRecordThreshold", "ReceiverSigRequired", "AutoRenewPeriod", "ShardID", "RealmID", "NewRealmAdminKey", "Memo", "MaxAutomaticTokenAssociations", "StakedAccountId", "StakedNodeId", "DeclineReward", "Alias", "HookCreationDetails" }, new[]{ "StakedId" }, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  ///
  /// Create a new account.
  ///
  /// If the auto_renew_account field is set, the key of the referenced account
  /// MUST sign this transaction.&lt;br/>
  /// Current limitations REQUIRE that `shardID` and `realmID` both MUST be `0`.
  /// This is expected to change in the future.
  ///
  /// ### Block Stream Effects
  /// The newly created account SHALL be included in State Changes.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class CryptoCreateTransactionBody : pb::IMessage<CryptoCreateTransactionBody>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<CryptoCreateTransactionBody> _parser = new pb::MessageParser<CryptoCreateTransactionBody>(() => new CryptoCreateTransactionBody());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<CryptoCreateTransactionBody> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Proto.CryptoCreateReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public CryptoCreateTransactionBody() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public CryptoCreateTransactionBody(CryptoCreateTransactionBody other) : this() {
      key_ = other.key_ != null ? other.key_.Clone() : null;
      initialBalance_ = other.initialBalance_;
      proxyAccountID_ = other.proxyAccountID_ != null ? other.proxyAccountID_.Clone() : null;
      sendRecordThreshold_ = other.sendRecordThreshold_;
      receiveRecordThreshold_ = other.receiveRecordThreshold_;
      receiverSigRequired_ = other.receiverSigRequired_;
      autoRenewPeriod_ = other.autoRenewPeriod_ != null ? other.autoRenewPeriod_.Clone() : null;
      shardID_ = other.shardID_ != null ? other.shardID_.Clone() : null;
      realmID_ = other.realmID_ != null ? other.realmID_.Clone() : null;
      newRealmAdminKey_ = other.newRealmAdminKey_ != null ? other.newRealmAdminKey_.Clone() : null;
      memo_ = other.memo_;
      maxAutomaticTokenAssociations_ = other.maxAutomaticTokenAssociations_;
      declineReward_ = other.declineReward_;
      alias_ = other.alias_;
      hookCreationDetails_ = other.hookCreationDetails_.Clone();
      switch (other.StakedIdCase) {
        case StakedIdOneofCase.StakedAccountId:
          StakedAccountId = other.StakedAccountId.Clone();
          break;
        case StakedIdOneofCase.StakedNodeId:
          StakedNodeId = other.StakedNodeId;
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public CryptoCreateTransactionBody Clone() {
      return new CryptoCreateTransactionBody(this);
    }

    /// <summary>Field number for the "key" field.</summary>
    public const int KeyFieldNumber = 1;
    private global::Proto.Key key_;
    /// <summary>
    ///*
    /// The identifying key for this account.
    /// This key represents the account owner, and is required for most actions
    /// involving this account that do not modify the account itself. This key
    /// may also identify the account for smart contracts.
    /// &lt;p>
    /// This field is REQUIRED.
    /// This `Key` MUST NOT be an empty `KeyList` and MUST contain at least one
    /// "primitive" (i.e. cryptographic) key value.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.Key Key {
      get { return key_; }
      set {
        key_ = value;
      }
    }

    /// <summary>Field number for the "initialBalance" field.</summary>
    public const int InitialBalanceFieldNumber = 2;
    private ulong initialBalance_;
    /// <summary>
    ///*
    /// An amount, in tinybar, to deposit to the newly created account.
    /// &lt;p>
    /// The deposited amount SHALL be debited to the "payer" account for this
    /// transaction.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ulong InitialBalance {
      get { return initialBalance_; }
      set {
        initialBalance_ = value;
      }
    }

    /// <summary>Field number for the "proxyAccountID" field.</summary>
    public const int ProxyAccountIDFieldNumber = 3;
    private global::Proto.AccountID proxyAccountID_;
    /// <summary>
    ///*
    /// Use `staked_id` instead.&lt;br/>
    /// An account identifier for a staking proxy.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.AccountID ProxyAccountID {
      get { return proxyAccountID_; }
      set {
        proxyAccountID_ = value;
      }
    }

    /// <summary>Field number for the "sendRecordThreshold" field.</summary>
    public const int SendRecordThresholdFieldNumber = 6;
    private ulong sendRecordThreshold_;
    /// <summary>
    ///*
    /// Removed prior to the first available history, and may be related to an
    /// early design dead-end.&lt;br/>
    /// An amount below which record stream records would not be created for
    /// a transaction that reduces this account balance.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ulong SendRecordThreshold {
      get { return sendRecordThreshold_; }
      set {
        sendRecordThreshold_ = value;
      }
    }

    /// <summary>Field number for the "receiveRecordThreshold" field.</summary>
    public const int ReceiveRecordThresholdFieldNumber = 7;
    private ulong receiveRecordThreshold_;
    /// <summary>
    ///*
    /// Removed prior to the first available history, and may be related to an
    /// early design dead-end.&lt;br/>
    /// An amount below which record stream records would not be created for
    /// a transaction that increases this account balance.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ulong ReceiveRecordThreshold {
      get { return receiveRecordThreshold_; }
      set {
        receiveRecordThreshold_ = value;
      }
    }

    /// <summary>Field number for the "receiverSigRequired" field.</summary>
    public const int ReceiverSigRequiredFieldNumber = 8;
    private bool receiverSigRequired_;
    /// <summary>
    ///*
    /// A flag indicating the account holder must authorize all incoming
    /// token transfers.
    /// &lt;p>
    /// If this flag is set then any transaction that would result in adding
    /// hbar or other tokens to this account balance MUST be signed by the
    /// identifying key of this account (that is, the `key` field).&lt;br/>
    /// If this flag is set, then the account key (`key` field) MUST sign
    /// this create transaction, in addition to the transaction payer.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool ReceiverSigRequired {
      get { return receiverSigRequired_; }
      set {
        receiverSigRequired_ = value;
      }
    }

    /// <summary>Field number for the "autoRenewPeriod" field.</summary>
    public const int AutoRenewPeriodFieldNumber = 9;
    private global::Proto.Duration autoRenewPeriod_;
    /// <summary>
    ///*
    /// The duration between account automatic renewals.&lt;br/>
    /// All entities in state may be charged "rent" occasionally (typically
    /// every 90 days) to prevent unnecessary growth of the ledger. This value
    /// sets the interval between such events for this account.
    /// &lt;p>
    /// If the account balance (in HBAR) is insufficient to pay the full renewal
    /// fee, the entire HBAR balance SHALL be consumed and the expiration for
    /// the account SHALL be extended as far as the available balance can
    /// support.&lt;br/>
    /// If the account HBAR balance is `0` when the account must be renewed, then
    /// the account SHALL be deleted, and subsequently removed from state.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.Duration AutoRenewPeriod {
      get { return autoRenewPeriod_; }
      set {
        autoRenewPeriod_ = value;
      }
    }

    /// <summary>Field number for the "shardID" field.</summary>
    public const int ShardIDFieldNumber = 10;
    private global::Proto.ShardID shardID_;
    /// <summary>
    ///*
    /// The shard in which this account is created
    /// &lt;p>
    /// Currently, this MUST be `0`.&lt;br/>
    /// If the desired shard is `0`, this SHOULD NOT be set.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.ShardID ShardID {
      get { return shardID_; }
      set {
        shardID_ = value;
      }
    }

    /// <summary>Field number for the "realmID" field.</summary>
    public const int RealmIDFieldNumber = 11;
    private global::Proto.RealmID realmID_;
    /// <summary>
    ///*
    /// The realm in which this account is created.
    /// &lt;p>
    /// The shard number for this realm MUST match the value in `shardID`.&lt;br/>
    /// Currently, this MUST be `0` for both fields.&lt;br/>
    /// If the desired realm is `0`, this SHOULD NOT be set.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.RealmID RealmID {
      get { return realmID_; }
      set {
        realmID_ = value;
      }
    }

    /// <summary>Field number for the "newRealmAdminKey" field.</summary>
    public const int NewRealmAdminKeyFieldNumber = 12;
    private global::Proto.Key newRealmAdminKey_;
    /// <summary>
    ///*
    /// This field was never actually used or enabled, and is not expected to
    /// ever be used in the future.&lt;br/>
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.Key NewRealmAdminKey {
      get { return newRealmAdminKey_; }
      set {
        newRealmAdminKey_ = value;
      }
    }

    /// <summary>Field number for the "memo" field.</summary>
    public const int MemoFieldNumber = 13;
    private string memo_ = "";
    /// <summary>
    ///*
    /// A short description of this Account.
    /// &lt;p>
    /// This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
    /// (default 100) bytes when encoded as UTF-8.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Memo {
      get { return memo_; }
      set {
        memo_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "max_automatic_token_associations" field.</summary>
    public const int MaxAutomaticTokenAssociationsFieldNumber = 14;
    private int maxAutomaticTokenAssociations_;
    /// <summary>
    ///*
    /// A maximum number of tokens that can be auto-associated
    /// with this account.&lt;br/>
    /// By default this value is 0 for all accounts except for automatically
    /// created accounts (e.g. smart contracts), which default to -1.
    /// &lt;p>
    /// If this value is `0`, then this account MUST manually associate to
    /// a token before holding or transacting in that token.&lt;br/>
    /// This value MAY also be `-1` to indicate no limit.&lt;br/>
    /// This value MUST NOT be less than `-1`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int MaxAutomaticTokenAssociations {
      get { return maxAutomaticTokenAssociations_; }
      set {
        maxAutomaticTokenAssociations_ = value;
      }
    }

    /// <summary>Field number for the "staked_account_id" field.</summary>
    public const int StakedAccountIdFieldNumber = 15;
    /// <summary>
    ///*
    /// ID of the account to which this account is staking its balances.
    /// &lt;p>
    /// If this account is not currently staking its balances, then this
    /// field, if set, MUST be the sentinel value of `0.0.0`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.AccountID StakedAccountId {
      get { return stakedIdCase_ == StakedIdOneofCase.StakedAccountId ? (global::Proto.AccountID) stakedId_ : null; }
      set {
        stakedId_ = value;
        stakedIdCase_ = value == null ? StakedIdOneofCase.None : StakedIdOneofCase.StakedAccountId;
      }
    }

    /// <summary>Field number for the "staked_node_id" field.</summary>
    public const int StakedNodeIdFieldNumber = 16;
    /// <summary>
    ///*
    /// ID of the node this account is staked to.
    /// &lt;p>
    /// If this account is not currently staking its balances, then this
    /// field, if set, SHALL be the sentinel value of `-1`.&lt;br/>
    /// Wallet software SHOULD surface staking issues to users and provide a
    /// simple mechanism to update staking to a new node ID in the event the
    /// prior staked node ID ceases to be valid.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long StakedNodeId {
      get { return HasStakedNodeId ? (long) stakedId_ : 0L; }
      set {
        stakedId_ = value;
        stakedIdCase_ = StakedIdOneofCase.StakedNodeId;
      }
    }
    /// <summary>Gets whether the "staked_node_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasStakedNodeId {
      get { return stakedIdCase_ == StakedIdOneofCase.StakedNodeId; }
    }
    /// <summary> Clears the value of the oneof if it's currently set to "staked_node_id" </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearStakedNodeId() {
      if (HasStakedNodeId) {
        ClearStakedId();
      }
    }

    /// <summary>Field number for the "decline_reward" field.</summary>
    public const int DeclineRewardFieldNumber = 17;
    private bool declineReward_;
    /// <summary>
    ///*
    /// A bool indicating that this account has chosen to decline rewards for
    /// staking its balances.
    /// &lt;p>
    /// This account MAY still stake its balances, but SHALL NOT receive reward
    /// payments for doing so, if this value is set.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool DeclineReward {
      get { return declineReward_; }
      set {
        declineReward_ = value;
      }
    }

    /// <summary>Field number for the "alias" field.</summary>
    public const int AliasFieldNumber = 18;
    private pb::ByteString alias_ = pb::ByteString.Empty;
    /// <summary>
    ///*
    /// Bytes to be used as the account's alias.
    /// &lt;p>
    /// This value, if set, MUST be one of the following values&lt;br/>
    /// &lt;ul>
    ///   &lt;li>The 32-byte serialized form of the ED25519 account key.&lt;/li>
    ///   &lt;li>The 33-byte _compressed_ serialized form of the ECDSA(secp256k1)
    ///       account key.&lt;/li>
    ///   &lt;li>The 20-byte EVM address derived from a keccak-256 hash of the
    ///       ECDSA(secp256k1) account key&lt;/li>
    /// &lt;/ul>
    /// All aliases within the network MUST be unique. If this value matches an
    /// existing account alias, this `create` transaction SHALL fail.&lt;br/>
    /// If an account exists with a particular alias value, any transaction to
    /// transfer value _to_ that alias SHALL deposit the transferred value in
    /// the existing account, and SHALL NOT assess an account creation fee.&lt;br/>
    /// Once set, an account alias is immutable and MUST NOT be changed.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString Alias {
      get { return alias_; }
      set {
        alias_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "hook_creation_details" field.</summary>
    public const int HookCreationDetailsFieldNumber = 19;
    private static readonly pb::FieldCodec<global::Com.Hedera.Hapi.Node.Hooks.HookCreationDetails> _repeated_hookCreationDetails_codec
        = pb::FieldCodec.ForMessage(154, global::Com.Hedera.Hapi.Node.Hooks.HookCreationDetails.Parser);
    private readonly pbc::RepeatedField<global::Com.Hedera.Hapi.Node.Hooks.HookCreationDetails> hookCreationDetails_ = new pbc::RepeatedField<global::Com.Hedera.Hapi.Node.Hooks.HookCreationDetails>();
    /// <summary>
    ///*
    /// Details of hooks to add immediately after creating this account.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Com.Hedera.Hapi.Node.Hooks.HookCreationDetails> HookCreationDetails {
      get { return hookCreationDetails_; }
    }

    private object stakedId_;
    /// <summary>Enum of possible cases for the "staked_id" oneof.</summary>
    public enum StakedIdOneofCase {
      None = 0,
      StakedAccountId = 15,
      StakedNodeId = 16,
    }
    private StakedIdOneofCase stakedIdCase_ = StakedIdOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public StakedIdOneofCase StakedIdCase {
      get { return stakedIdCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearStakedId() {
      stakedIdCase_ = StakedIdOneofCase.None;
      stakedId_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as CryptoCreateTransactionBody);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(CryptoCreateTransactionBody other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Key, other.Key)) return false;
      if (InitialBalance != other.InitialBalance) return false;
      if (!object.Equals(ProxyAccountID, other.ProxyAccountID)) return false;
      if (SendRecordThreshold != other.SendRecordThreshold) return false;
      if (ReceiveRecordThreshold != other.ReceiveRecordThreshold) return false;
      if (ReceiverSigRequired != other.ReceiverSigRequired) return false;
      if (!object.Equals(AutoRenewPeriod, other.AutoRenewPeriod)) return false;
      if (!object.Equals(ShardID, other.ShardID)) return false;
      if (!object.Equals(RealmID, other.RealmID)) return false;
      if (!object.Equals(NewRealmAdminKey, other.NewRealmAdminKey)) return false;
      if (Memo != other.Memo) return false;
      if (MaxAutomaticTokenAssociations != other.MaxAutomaticTokenAssociations) return false;
      if (!object.Equals(StakedAccountId, other.StakedAccountId)) return false;
      if (StakedNodeId != other.StakedNodeId) return false;
      if (DeclineReward != other.DeclineReward) return false;
      if (Alias != other.Alias) return false;
      if(!hookCreationDetails_.Equals(other.hookCreationDetails_)) return false;
      if (StakedIdCase != other.StakedIdCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (key_ != null) hash ^= Key.GetHashCode();
      if (InitialBalance != 0UL) hash ^= InitialBalance.GetHashCode();
      if (proxyAccountID_ != null) hash ^= ProxyAccountID.GetHashCode();
      if (SendRecordThreshold != 0UL) hash ^= SendRecordThreshold.GetHashCode();
      if (ReceiveRecordThreshold != 0UL) hash ^= ReceiveRecordThreshold.GetHashCode();
      if (ReceiverSigRequired != false) hash ^= ReceiverSigRequired.GetHashCode();
      if (autoRenewPeriod_ != null) hash ^= AutoRenewPeriod.GetHashCode();
      if (shardID_ != null) hash ^= ShardID.GetHashCode();
      if (realmID_ != null) hash ^= RealmID.GetHashCode();
      if (newRealmAdminKey_ != null) hash ^= NewRealmAdminKey.GetHashCode();
      if (Memo.Length != 0) hash ^= Memo.GetHashCode();
      if (MaxAutomaticTokenAssociations != 0) hash ^= MaxAutomaticTokenAssociations.GetHashCode();
      if (stakedIdCase_ == StakedIdOneofCase.StakedAccountId) hash ^= StakedAccountId.GetHashCode();
      if (HasStakedNodeId) hash ^= StakedNodeId.GetHashCode();
      if (DeclineReward != false) hash ^= DeclineReward.GetHashCode();
      if (Alias.Length != 0) hash ^= Alias.GetHashCode();
      hash ^= hookCreationDetails_.GetHashCode();
      hash ^= (int) stakedIdCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (key_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Key);
      }
      if (InitialBalance != 0UL) {
        output.WriteRawTag(16);
        output.WriteUInt64(InitialBalance);
      }
      if (proxyAccountID_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(ProxyAccountID);
      }
      if (SendRecordThreshold != 0UL) {
        output.WriteRawTag(48);
        output.WriteUInt64(SendRecordThreshold);
      }
      if (ReceiveRecordThreshold != 0UL) {
        output.WriteRawTag(56);
        output.WriteUInt64(ReceiveRecordThreshold);
      }
      if (ReceiverSigRequired != false) {
        output.WriteRawTag(64);
        output.WriteBool(ReceiverSigRequired);
      }
      if (autoRenewPeriod_ != null) {
        output.WriteRawTag(74);
        output.WriteMessage(AutoRenewPeriod);
      }
      if (shardID_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(ShardID);
      }
      if (realmID_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(RealmID);
      }
      if (newRealmAdminKey_ != null) {
        output.WriteRawTag(98);
        output.WriteMessage(NewRealmAdminKey);
      }
      if (Memo.Length != 0) {
        output.WriteRawTag(106);
        output.WriteString(Memo);
      }
      if (MaxAutomaticTokenAssociations != 0) {
        output.WriteRawTag(112);
        output.WriteInt32(MaxAutomaticTokenAssociations);
      }
      if (stakedIdCase_ == StakedIdOneofCase.StakedAccountId) {
        output.WriteRawTag(122);
        output.WriteMessage(StakedAccountId);
      }
      if (HasStakedNodeId) {
        output.WriteRawTag(128, 1);
        output.WriteInt64(StakedNodeId);
      }
      if (DeclineReward != false) {
        output.WriteRawTag(136, 1);
        output.WriteBool(DeclineReward);
      }
      if (Alias.Length != 0) {
        output.WriteRawTag(146, 1);
        output.WriteBytes(Alias);
      }
      hookCreationDetails_.WriteTo(output, _repeated_hookCreationDetails_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (key_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Key);
      }
      if (InitialBalance != 0UL) {
        output.WriteRawTag(16);
        output.WriteUInt64(InitialBalance);
      }
      if (proxyAccountID_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(ProxyAccountID);
      }
      if (SendRecordThreshold != 0UL) {
        output.WriteRawTag(48);
        output.WriteUInt64(SendRecordThreshold);
      }
      if (ReceiveRecordThreshold != 0UL) {
        output.WriteRawTag(56);
        output.WriteUInt64(ReceiveRecordThreshold);
      }
      if (ReceiverSigRequired != false) {
        output.WriteRawTag(64);
        output.WriteBool(ReceiverSigRequired);
      }
      if (autoRenewPeriod_ != null) {
        output.WriteRawTag(74);
        output.WriteMessage(AutoRenewPeriod);
      }
      if (shardID_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(ShardID);
      }
      if (realmID_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(RealmID);
      }
      if (newRealmAdminKey_ != null) {
        output.WriteRawTag(98);
        output.WriteMessage(NewRealmAdminKey);
      }
      if (Memo.Length != 0) {
        output.WriteRawTag(106);
        output.WriteString(Memo);
      }
      if (MaxAutomaticTokenAssociations != 0) {
        output.WriteRawTag(112);
        output.WriteInt32(MaxAutomaticTokenAssociations);
      }
      if (stakedIdCase_ == StakedIdOneofCase.StakedAccountId) {
        output.WriteRawTag(122);
        output.WriteMessage(StakedAccountId);
      }
      if (HasStakedNodeId) {
        output.WriteRawTag(128, 1);
        output.WriteInt64(StakedNodeId);
      }
      if (DeclineReward != false) {
        output.WriteRawTag(136, 1);
        output.WriteBool(DeclineReward);
      }
      if (Alias.Length != 0) {
        output.WriteRawTag(146, 1);
        output.WriteBytes(Alias);
      }
      hookCreationDetails_.WriteTo(ref output, _repeated_hookCreationDetails_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (key_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Key);
      }
      if (InitialBalance != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(InitialBalance);
      }
      if (proxyAccountID_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ProxyAccountID);
      }
      if (SendRecordThreshold != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(SendRecordThreshold);
      }
      if (ReceiveRecordThreshold != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(ReceiveRecordThreshold);
      }
      if (ReceiverSigRequired != false) {
        size += 1 + 1;
      }
      if (autoRenewPeriod_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(AutoRenewPeriod);
      }
      if (shardID_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ShardID);
      }
      if (realmID_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RealmID);
      }
      if (newRealmAdminKey_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(NewRealmAdminKey);
      }
      if (Memo.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Memo);
      }
      if (MaxAutomaticTokenAssociations != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(MaxAutomaticTokenAssociations);
      }
      if (stakedIdCase_ == StakedIdOneofCase.StakedAccountId) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(StakedAccountId);
      }
      if (HasStakedNodeId) {
        size += 2 + pb::CodedOutputStream.ComputeInt64Size(StakedNodeId);
      }
      if (DeclineReward != false) {
        size += 2 + 1;
      }
      if (Alias.Length != 0) {
        size += 2 + pb::CodedOutputStream.ComputeBytesSize(Alias);
      }
      size += hookCreationDetails_.CalculateSize(_repeated_hookCreationDetails_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(CryptoCreateTransactionBody other) {
      if (other == null) {
        return;
      }
      if (other.key_ != null) {
        if (key_ == null) {
          Key = new global::Proto.Key();
        }
        Key.MergeFrom(other.Key);
      }
      if (other.InitialBalance != 0UL) {
        InitialBalance = other.InitialBalance;
      }
      if (other.proxyAccountID_ != null) {
        if (proxyAccountID_ == null) {
          ProxyAccountID = new global::Proto.AccountID();
        }
        ProxyAccountID.MergeFrom(other.ProxyAccountID);
      }
      if (other.SendRecordThreshold != 0UL) {
        SendRecordThreshold = other.SendRecordThreshold;
      }
      if (other.ReceiveRecordThreshold != 0UL) {
        ReceiveRecordThreshold = other.ReceiveRecordThreshold;
      }
      if (other.ReceiverSigRequired != false) {
        ReceiverSigRequired = other.ReceiverSigRequired;
      }
      if (other.autoRenewPeriod_ != null) {
        if (autoRenewPeriod_ == null) {
          AutoRenewPeriod = new global::Proto.Duration();
        }
        AutoRenewPeriod.MergeFrom(other.AutoRenewPeriod);
      }
      if (other.shardID_ != null) {
        if (shardID_ == null) {
          ShardID = new global::Proto.ShardID();
        }
        ShardID.MergeFrom(other.ShardID);
      }
      if (other.realmID_ != null) {
        if (realmID_ == null) {
          RealmID = new global::Proto.RealmID();
        }
        RealmID.MergeFrom(other.RealmID);
      }
      if (other.newRealmAdminKey_ != null) {
        if (newRealmAdminKey_ == null) {
          NewRealmAdminKey = new global::Proto.Key();
        }
        NewRealmAdminKey.MergeFrom(other.NewRealmAdminKey);
      }
      if (other.Memo.Length != 0) {
        Memo = other.Memo;
      }
      if (other.MaxAutomaticTokenAssociations != 0) {
        MaxAutomaticTokenAssociations = other.MaxAutomaticTokenAssociations;
      }
      if (other.DeclineReward != false) {
        DeclineReward = other.DeclineReward;
      }
      if (other.Alias.Length != 0) {
        Alias = other.Alias;
      }
      hookCreationDetails_.Add(other.hookCreationDetails_);
      switch (other.StakedIdCase) {
        case StakedIdOneofCase.StakedAccountId:
          if (StakedAccountId == null) {
            StakedAccountId = new global::Proto.AccountID();
          }
          StakedAccountId.MergeFrom(other.StakedAccountId);
          break;
        case StakedIdOneofCase.StakedNodeId:
          StakedNodeId = other.StakedNodeId;
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (key_ == null) {
              Key = new global::Proto.Key();
            }
            input.ReadMessage(Key);
            break;
          }
          case 16: {
            InitialBalance = input.ReadUInt64();
            break;
          }
          case 26: {
            if (proxyAccountID_ == null) {
              ProxyAccountID = new global::Proto.AccountID();
            }
            input.ReadMessage(ProxyAccountID);
            break;
          }
          case 48: {
            SendRecordThreshold = input.ReadUInt64();
            break;
          }
          case 56: {
            ReceiveRecordThreshold = input.ReadUInt64();
            break;
          }
          case 64: {
            ReceiverSigRequired = input.ReadBool();
            break;
          }
          case 74: {
            if (autoRenewPeriod_ == null) {
              AutoRenewPeriod = new global::Proto.Duration();
            }
            input.ReadMessage(AutoRenewPeriod);
            break;
          }
          case 82: {
            if (shardID_ == null) {
              ShardID = new global::Proto.ShardID();
            }
            input.ReadMessage(ShardID);
            break;
          }
          case 90: {
            if (realmID_ == null) {
              RealmID = new global::Proto.RealmID();
            }
            input.ReadMessage(RealmID);
            break;
          }
          case 98: {
            if (newRealmAdminKey_ == null) {
              NewRealmAdminKey = new global::Proto.Key();
            }
            input.ReadMessage(NewRealmAdminKey);
            break;
          }
          case 106: {
            Memo = input.ReadString();
            break;
          }
          case 112: {
            MaxAutomaticTokenAssociations = input.ReadInt32();
            break;
          }
          case 122: {
            global::Proto.AccountID subBuilder = new global::Proto.AccountID();
            if (stakedIdCase_ == StakedIdOneofCase.StakedAccountId) {
              subBuilder.MergeFrom(StakedAccountId);
            }
            input.ReadMessage(subBuilder);
            StakedAccountId = subBuilder;
            break;
          }
          case 128: {
            StakedNodeId = input.ReadInt64();
            break;
          }
          case 136: {
            DeclineReward = input.ReadBool();
            break;
          }
          case 146: {
            Alias = input.ReadBytes();
            break;
          }
          case 154: {
            hookCreationDetails_.AddEntriesFrom(input, _repeated_hookCreationDetails_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (key_ == null) {
              Key = new global::Proto.Key();
            }
            input.ReadMessage(Key);
            break;
          }
          case 16: {
            InitialBalance = input.ReadUInt64();
            break;
          }
          case 26: {
            if (proxyAccountID_ == null) {
              ProxyAccountID = new global::Proto.AccountID();
            }
            input.ReadMessage(ProxyAccountID);
            break;
          }
          case 48: {
            SendRecordThreshold = input.ReadUInt64();
            break;
          }
          case 56: {
            ReceiveRecordThreshold = input.ReadUInt64();
            break;
          }
          case 64: {
            ReceiverSigRequired = input.ReadBool();
            break;
          }
          case 74: {
            if (autoRenewPeriod_ == null) {
              AutoRenewPeriod = new global::Proto.Duration();
            }
            input.ReadMessage(AutoRenewPeriod);
            break;
          }
          case 82: {
            if (shardID_ == null) {
              ShardID = new global::Proto.ShardID();
            }
            input.ReadMessage(ShardID);
            break;
          }
          case 90: {
            if (realmID_ == null) {
              RealmID = new global::Proto.RealmID();
            }
            input.ReadMessage(RealmID);
            break;
          }
          case 98: {
            if (newRealmAdminKey_ == null) {
              NewRealmAdminKey = new global::Proto.Key();
            }
            input.ReadMessage(NewRealmAdminKey);
            break;
          }
          case 106: {
            Memo = input.ReadString();
            break;
          }
          case 112: {
            MaxAutomaticTokenAssociations = input.ReadInt32();
            break;
          }
          case 122: {
            global::Proto.AccountID subBuilder = new global::Proto.AccountID();
            if (stakedIdCase_ == StakedIdOneofCase.StakedAccountId) {
              subBuilder.MergeFrom(StakedAccountId);
            }
            input.ReadMessage(subBuilder);
            StakedAccountId = subBuilder;
            break;
          }
          case 128: {
            StakedNodeId = input.ReadInt64();
            break;
          }
          case 136: {
            DeclineReward = input.ReadBool();
            break;
          }
          case 146: {
            Alias = input.ReadBytes();
            break;
          }
          case 154: {
            hookCreationDetails_.AddEntriesFrom(ref input, _repeated_hookCreationDetails_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  #endregion

}

#endregion Designer generated code
