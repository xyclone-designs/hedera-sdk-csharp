// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: crypto_update.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021, 8981
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Proto {

  /// <summary>Holder for reflection information generated from crypto_update.proto</summary>
  public static partial class CryptoUpdateReflection {

    #region Descriptor
    /// <summary>File descriptor for crypto_update.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static CryptoUpdateReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "ChNjcnlwdG9fdXBkYXRlLnByb3RvEgVwcm90bxoRYmFzaWNfdHlwZXMucHJv",
            "dG8aDmR1cmF0aW9uLnByb3RvGhBob29rX3R5cGVzLnByb3RvGg90aW1lc3Rh",
            "bXAucHJvdG8aHmdvb2dsZS9wcm90b2J1Zi93cmFwcGVycy5wcm90byKBCAob",
            "Q3J5cHRvVXBkYXRlVHJhbnNhY3Rpb25Cb2R5EisKEWFjY291bnRJRFRvVXBk",
            "YXRlGAIgASgLMhAucHJvdG8uQWNjb3VudElEEhcKA2tleRgDIAEoCzIKLnBy",
            "b3RvLktleRIsCg5wcm94eUFjY291bnRJRBgEIAEoCzIQLnByb3RvLkFjY291",
            "bnRJREICGAESGQoNcHJveHlGcmFjdGlvbhgFIAEoBUICGAESIQoTc2VuZFJl",
            "Y29yZFRocmVzaG9sZBgGIAEoBEICGAFIABJGChpzZW5kUmVjb3JkVGhyZXNo",
            "b2xkV3JhcHBlchgLIAEoCzIcLmdvb2dsZS5wcm90b2J1Zi5VSW50NjRWYWx1",
            "ZUICGAFIABIkChZyZWNlaXZlUmVjb3JkVGhyZXNob2xkGAcgASgEQgIYAUgB",
            "EkkKHXJlY2VpdmVSZWNvcmRUaHJlc2hvbGRXcmFwcGVyGAwgASgLMhwuZ29v",
            "Z2xlLnByb3RvYnVmLlVJbnQ2NFZhbHVlQgIYAUgBEigKD2F1dG9SZW5ld1Bl",
            "cmlvZBgIIAEoCzIPLnByb3RvLkR1cmF0aW9uEigKDmV4cGlyYXRpb25UaW1l",
            "GAkgASgLMhAucHJvdG8uVGltZXN0YW1wEiEKE3JlY2VpdmVyU2lnUmVxdWly",
            "ZWQYCiABKAhCAhgBSAISQAoacmVjZWl2ZXJTaWdSZXF1aXJlZFdyYXBwZXIY",
            "DSABKAsyGi5nb29nbGUucHJvdG9idWYuQm9vbFZhbHVlSAISKgoEbWVtbxgO",
            "IAEoCzIcLmdvb2dsZS5wcm90b2J1Zi5TdHJpbmdWYWx1ZRJFCiBtYXhfYXV0",
            "b21hdGljX3Rva2VuX2Fzc29jaWF0aW9ucxgPIAEoCzIbLmdvb2dsZS5wcm90",
            "b2J1Zi5JbnQzMlZhbHVlEi0KEXN0YWtlZF9hY2NvdW50X2lkGBAgASgLMhAu",
            "cHJvdG8uQWNjb3VudElESAMSGAoOc3Rha2VkX25vZGVfaWQYESABKANIAxIy",
            "Cg5kZWNsaW5lX3Jld2FyZBgSIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5Cb29s",
            "VmFsdWUSGgoSaG9va19pZHNfdG9fZGVsZXRlGBMgAygDEk4KFWhvb2tfY3Jl",
            "YXRpb25fZGV0YWlscxgUIAMoCzIvLmNvbS5oZWRlcmEuaGFwaS5ub2RlLmhv",
            "b2tzLkhvb2tDcmVhdGlvbkRldGFpbHNCGgoYc2VuZFJlY29yZFRocmVzaG9s",
            "ZEZpZWxkQh0KG3JlY2VpdmVSZWNvcmRUaHJlc2hvbGRGaWVsZEIaChhyZWNl",
            "aXZlclNpZ1JlcXVpcmVkRmllbGRCCwoJc3Rha2VkX2lkQiIKHmNvbS5oZWRl",
            "cmEuaGFzaGdyYXBoLnNkay5wcm90b1ABYgZwcm90bzM="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Proto.BasicTypesReflection.Descriptor, global::Proto.DurationReflection.Descriptor, global::Com.Hedera.Hapi.Node.Hooks.HookTypesReflection.Descriptor, global::Proto.TimestampReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.WrappersReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Proto.CryptoUpdateTransactionBody), global::Proto.CryptoUpdateTransactionBody.Parser, new[]{ "AccountIDToUpdate", "Key", "ProxyAccountID", "ProxyFraction", "SendRecordThreshold", "SendRecordThresholdWrapper", "ReceiveRecordThreshold", "ReceiveRecordThresholdWrapper", "AutoRenewPeriod", "ExpirationTime", "ReceiverSigRequired", "ReceiverSigRequiredWrapper", "Memo", "MaxAutomaticTokenAssociations", "StakedAccountId", "StakedNodeId", "DeclineReward", "HookIdsToDelete", "HookCreationDetails" }, new[]{ "SendRecordThresholdField", "ReceiveRecordThresholdField", "ReceiverSigRequiredField", "StakedId" }, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  ///*
  /// Modify the current state of an account.
  ///
  /// ### Requirements
  /// - The `key` for this account MUST sign all account update transactions.
  /// - If the `key` field is set for this transaction, then _both_ the current
  ///   `key` and the new `key` MUST sign this transaction, for security and to
  ///   prevent setting the `key` field to an invalid value.
  /// - If the `auto_renew_account` field is set for this transaction, the account
  ///   identified in that field MUST sign this transaction.
  /// - Fields set to non-default values in this transaction SHALL be updated on
  ///   success. Fields not set to non-default values SHALL NOT be
  ///   updated on success.
  /// - All fields that may be modified in this transaction SHALL have a
  ///   default value of unset (a.k.a. `null`).
  ///
  /// ### Block Stream Effects
  /// None
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class CryptoUpdateTransactionBody : pb::IMessage<CryptoUpdateTransactionBody>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<CryptoUpdateTransactionBody> _parser = new pb::MessageParser<CryptoUpdateTransactionBody>(() => new CryptoUpdateTransactionBody());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<CryptoUpdateTransactionBody> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Proto.CryptoUpdateReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public CryptoUpdateTransactionBody() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public CryptoUpdateTransactionBody(CryptoUpdateTransactionBody other) : this() {
      accountIDToUpdate_ = other.accountIDToUpdate_ != null ? other.accountIDToUpdate_.Clone() : null;
      key_ = other.key_ != null ? other.key_.Clone() : null;
      proxyAccountID_ = other.proxyAccountID_ != null ? other.proxyAccountID_.Clone() : null;
      proxyFraction_ = other.proxyFraction_;
      autoRenewPeriod_ = other.autoRenewPeriod_ != null ? other.autoRenewPeriod_.Clone() : null;
      expirationTime_ = other.expirationTime_ != null ? other.expirationTime_.Clone() : null;
      Memo = other.Memo;
      MaxAutomaticTokenAssociations = other.MaxAutomaticTokenAssociations;
      DeclineReward = other.DeclineReward;
      hookIdsToDelete_ = other.hookIdsToDelete_.Clone();
      hookCreationDetails_ = other.hookCreationDetails_.Clone();
      switch (other.SendRecordThresholdFieldCase) {
        case SendRecordThresholdFieldOneofCase.SendRecordThreshold:
          SendRecordThreshold = other.SendRecordThreshold;
          break;
        case SendRecordThresholdFieldOneofCase.SendRecordThresholdWrapper:
          SendRecordThresholdWrapper = other.SendRecordThresholdWrapper;
          break;
      }

      switch (other.ReceiveRecordThresholdFieldCase) {
        case ReceiveRecordThresholdFieldOneofCase.ReceiveRecordThreshold:
          ReceiveRecordThreshold = other.ReceiveRecordThreshold;
          break;
        case ReceiveRecordThresholdFieldOneofCase.ReceiveRecordThresholdWrapper:
          ReceiveRecordThresholdWrapper = other.ReceiveRecordThresholdWrapper;
          break;
      }

      switch (other.ReceiverSigRequiredFieldCase) {
        case ReceiverSigRequiredFieldOneofCase.ReceiverSigRequired:
          ReceiverSigRequired = other.ReceiverSigRequired;
          break;
        case ReceiverSigRequiredFieldOneofCase.ReceiverSigRequiredWrapper:
          ReceiverSigRequiredWrapper = other.ReceiverSigRequiredWrapper;
          break;
      }

      switch (other.StakedIdCase) {
        case StakedIdOneofCase.StakedAccountId:
          StakedAccountId = other.StakedAccountId.Clone();
          break;
        case StakedIdOneofCase.StakedNodeId:
          StakedNodeId = other.StakedNodeId;
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public CryptoUpdateTransactionBody Clone() {
      return new CryptoUpdateTransactionBody(this);
    }

    /// <summary>Field number for the "accountIDToUpdate" field.</summary>
    public const int AccountIDToUpdateFieldNumber = 2;
    private global::Proto.AccountID accountIDToUpdate_;
    /// <summary>
    ///*
    /// An account identifier.&lt;br/>
    /// This identifies the account which is to be modified in this transaction.
    /// &lt;p>
    /// This field is REQUIRED.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.AccountID AccountIDToUpdate {
      get { return accountIDToUpdate_; }
      set {
        accountIDToUpdate_ = value;
      }
    }

    /// <summary>Field number for the "key" field.</summary>
    public const int KeyFieldNumber = 3;
    private global::Proto.Key key_;
    /// <summary>
    ///*
    /// An account key.&lt;br/>
    /// This may be a "primitive" key (a singly cryptographic key), or a
    /// composite key.
    /// &lt;p>
    /// If set, this key MUST be a valid key.&lt;br/>
    /// If set, the previous key and new key MUST both sign this transaction.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.Key Key {
      get { return key_; }
      set {
        key_ = value;
      }
    }

    /// <summary>Field number for the "proxyAccountID" field.</summary>
    public const int ProxyAccountIDFieldNumber = 4;
    private global::Proto.AccountID proxyAccountID_;
    /// <summary>
    ///*
    /// Removed in favor of the `staked_id` oneOf.&lt;br/>
    /// An account identifier for a "proxy" account. This account's HBAR are
    /// staked to a node selected by the proxy account.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.AccountID ProxyAccountID {
      get { return proxyAccountID_; }
      set {
        proxyAccountID_ = value;
      }
    }

    /// <summary>Field number for the "proxyFraction" field.</summary>
    public const int ProxyFractionFieldNumber = 5;
    private int proxyFraction_;
    /// <summary>
    ///*
    /// Removed prior to the first available history.&lt;br/>
    /// A fraction to split staking rewards between this account and the proxy
    /// account.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int ProxyFraction {
      get { return proxyFraction_; }
      set {
        proxyFraction_ = value;
      }
    }

    /// <summary>Field number for the "sendRecordThreshold" field.</summary>
    public const int SendRecordThresholdFieldNumber = 6;
    /// <summary>
    ///*
    /// Removed prior to the first available history, and may be related
    /// to an early design dead-end.&lt;br/>
    /// The new threshold amount (in tinybars) for which an account record is
    /// created for any send/withdraw transaction
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ulong SendRecordThreshold {
      get { return HasSendRecordThreshold ? (ulong) sendRecordThresholdField_ : 0UL; }
      set {
        sendRecordThresholdField_ = value;
        sendRecordThresholdFieldCase_ = SendRecordThresholdFieldOneofCase.SendRecordThreshold;
      }
    }
    /// <summary>Gets whether the "sendRecordThreshold" field is set</summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSendRecordThreshold {
      get { return sendRecordThresholdFieldCase_ == SendRecordThresholdFieldOneofCase.SendRecordThreshold; }
    }
    /// <summary> Clears the value of the oneof if it's currently set to "sendRecordThreshold" </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSendRecordThreshold() {
      if (HasSendRecordThreshold) {
        ClearSendRecordThresholdField();
      }
    }

    /// <summary>Field number for the "sendRecordThresholdWrapper" field.</summary>
    public const int SendRecordThresholdWrapperFieldNumber = 11;
    private static readonly pb::FieldCodec<ulong?> _oneof_sendRecordThresholdWrapper_codec = pb::FieldCodec.ForStructWrapper<ulong>(90);
    /// <summary>
    ///*
    /// Removed prior to the first available history, and may be related
    /// to an early design dead-end.&lt;br/>
    /// The new threshold amount (in tinybars) for which an account record is
    /// created for any send/withdraw transaction
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ulong? SendRecordThresholdWrapper {
      get { return sendRecordThresholdFieldCase_ == SendRecordThresholdFieldOneofCase.SendRecordThresholdWrapper ? (ulong?) sendRecordThresholdField_ : (ulong?) null; }
      set {
        sendRecordThresholdField_ = value;
        sendRecordThresholdFieldCase_ = value == null ? SendRecordThresholdFieldOneofCase.None : SendRecordThresholdFieldOneofCase.SendRecordThresholdWrapper;
      }
    }

    /// <summary>Field number for the "receiveRecordThreshold" field.</summary>
    public const int ReceiveRecordThresholdFieldNumber = 7;
    /// <summary>
    ///*
    /// Removed prior to the first available history, and may be related
    /// to an early design dead-end.&lt;br/>
    /// The new threshold amount (in tinybars) for which an account record is
    /// created for any receive/deposit transaction.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ulong ReceiveRecordThreshold {
      get { return HasReceiveRecordThreshold ? (ulong) receiveRecordThresholdField_ : 0UL; }
      set {
        receiveRecordThresholdField_ = value;
        receiveRecordThresholdFieldCase_ = ReceiveRecordThresholdFieldOneofCase.ReceiveRecordThreshold;
      }
    }
    /// <summary>Gets whether the "receiveRecordThreshold" field is set</summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasReceiveRecordThreshold {
      get { return receiveRecordThresholdFieldCase_ == ReceiveRecordThresholdFieldOneofCase.ReceiveRecordThreshold; }
    }
    /// <summary> Clears the value of the oneof if it's currently set to "receiveRecordThreshold" </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearReceiveRecordThreshold() {
      if (HasReceiveRecordThreshold) {
        ClearReceiveRecordThresholdField();
      }
    }

    /// <summary>Field number for the "receiveRecordThresholdWrapper" field.</summary>
    public const int ReceiveRecordThresholdWrapperFieldNumber = 12;
    private static readonly pb::FieldCodec<ulong?> _oneof_receiveRecordThresholdWrapper_codec = pb::FieldCodec.ForStructWrapper<ulong>(98);
    /// <summary>
    ///*
    /// Removed prior to the first available history, and may be related
    /// to an early design dead-end.&lt;br/>
    /// The new threshold amount (in tinybars) for which an account record is
    /// created for any receive/deposit transaction.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ulong? ReceiveRecordThresholdWrapper {
      get { return receiveRecordThresholdFieldCase_ == ReceiveRecordThresholdFieldOneofCase.ReceiveRecordThresholdWrapper ? (ulong?) receiveRecordThresholdField_ : (ulong?) null; }
      set {
        receiveRecordThresholdField_ = value;
        receiveRecordThresholdFieldCase_ = value == null ? ReceiveRecordThresholdFieldOneofCase.None : ReceiveRecordThresholdFieldOneofCase.ReceiveRecordThresholdWrapper;
      }
    }

    /// <summary>Field number for the "autoRenewPeriod" field.</summary>
    public const int AutoRenewPeriodFieldNumber = 8;
    private global::Proto.Duration autoRenewPeriod_;
    /// <summary>
    ///*
    /// A duration to extend account expiration.&lt;br/>
    /// An amount of time, in seconds, to extend the expiration date for this
    /// account when _automatically_ renewed.
    /// &lt;p>
    /// This duration MUST be between the current configured minimum and maximum
    /// values defined for the network.&lt;br/>
    /// This duration SHALL be applied only when _automatically_ extending the
    /// account expiration.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.Duration AutoRenewPeriod {
      get { return autoRenewPeriod_; }
      set {
        autoRenewPeriod_ = value;
      }
    }

    /// <summary>Field number for the "expirationTime" field.</summary>
    public const int ExpirationTimeFieldNumber = 9;
    private global::Proto.Timestamp expirationTime_;
    /// <summary>
    ///*
    /// A new account expiration time, in seconds since the epoch.
    /// &lt;p>
    /// For this purpose, `epoch` SHALL be the UNIX epoch with 0
    /// at `1970-01-01T00:00:00.000Z`.&lt;br/>
    /// If set, this value MUST be later than the current consensus time.&lt;br/>
    /// If set, this value MUST be earlier than the current consensus time
    /// extended by the current maximum expiration time configured for the
    /// network.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.Timestamp ExpirationTime {
      get { return expirationTime_; }
      set {
        expirationTime_ = value;
      }
    }

    /// <summary>Field number for the "receiverSigRequired" field.</summary>
    public const int ReceiverSigRequiredFieldNumber = 10;
    /// <summary>
    ///*
    /// Removed to distinguish between unset and a default value.&lt;br/>
    /// Do NOT use this field to set a false value because the server cannot
    /// distinguish from the default value. Use receiverSigRequiredWrapper
    /// field for this purpose.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool ReceiverSigRequired {
      get { return HasReceiverSigRequired ? (bool) receiverSigRequiredField_ : false; }
      set {
        receiverSigRequiredField_ = value;
        receiverSigRequiredFieldCase_ = ReceiverSigRequiredFieldOneofCase.ReceiverSigRequired;
      }
    }
    /// <summary>Gets whether the "receiverSigRequired" field is set</summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasReceiverSigRequired {
      get { return receiverSigRequiredFieldCase_ == ReceiverSigRequiredFieldOneofCase.ReceiverSigRequired; }
    }
    /// <summary> Clears the value of the oneof if it's currently set to "receiverSigRequired" </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearReceiverSigRequired() {
      if (HasReceiverSigRequired) {
        ClearReceiverSigRequiredField();
      }
    }

    /// <summary>Field number for the "receiverSigRequiredWrapper" field.</summary>
    public const int ReceiverSigRequiredWrapperFieldNumber = 13;
    private static readonly pb::FieldCodec<bool?> _oneof_receiverSigRequiredWrapper_codec = pb::FieldCodec.ForStructWrapper<bool>(106);
    /// <summary>
    ///*
    /// A flag indicating the account holder must authorize all incoming
    /// token transfers.
    /// &lt;p>
    /// If this flag is set then any transaction that would result in adding
    /// hbar or other tokens to this account balance MUST be signed by the
    /// identifying key of this account (that is, the `key` field).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool? ReceiverSigRequiredWrapper {
      get { return receiverSigRequiredFieldCase_ == ReceiverSigRequiredFieldOneofCase.ReceiverSigRequiredWrapper ? (bool?) receiverSigRequiredField_ : (bool?) null; }
      set {
        receiverSigRequiredField_ = value;
        receiverSigRequiredFieldCase_ = value == null ? ReceiverSigRequiredFieldOneofCase.None : ReceiverSigRequiredFieldOneofCase.ReceiverSigRequiredWrapper;
      }
    }

    /// <summary>Field number for the "memo" field.</summary>
    public const int MemoFieldNumber = 14;
    private static readonly pb::FieldCodec<string> _single_memo_codec = pb::FieldCodec.ForClassWrapper<string>(114);
    private string memo_;
    /// <summary>
    ///*
    /// A short description of this Account.
    /// &lt;p>
    /// This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
    /// (default 100) bytes when encoded as UTF-8.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Memo {
      get { return memo_; }
      set {
        memo_ = value;
      }
    }


    /// <summary>Field number for the "max_automatic_token_associations" field.</summary>
    public const int MaxAutomaticTokenAssociationsFieldNumber = 15;
    private static readonly pb::FieldCodec<int?> _single_maxAutomaticTokenAssociations_codec = pb::FieldCodec.ForStructWrapper<int>(122);
    private int? maxAutomaticTokenAssociations_;
    /// <summary>
    ///*
    /// A maximum number of tokens that can be auto-associated
    /// with this account.&lt;br/>
    /// By default this value is 0 for all accounts except for automatically
    /// created accounts (i.e smart contracts) which default to -1.
    /// &lt;p>
    /// If this value is `0`, then this account MUST manually associate to
    /// a token before holding or transacting in that token.&lt;br/>
    /// This value MAY also be `-1` to indicate no limit.&lt;br/>
    /// If set, this value MUST NOT be less than `-1`.&lt;br/>
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int? MaxAutomaticTokenAssociations {
      get { return maxAutomaticTokenAssociations_; }
      set {
        maxAutomaticTokenAssociations_ = value;
      }
    }


    /// <summary>Field number for the "staked_account_id" field.</summary>
    public const int StakedAccountIdFieldNumber = 16;
    /// <summary>
    ///*
    /// ID of the account to which this account is staking its balances.
    /// &lt;p>
    /// If this account is not currently staking its balances, then this
    /// field, if set, MUST be the sentinel value of `0.0.0`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.AccountID StakedAccountId {
      get { return stakedIdCase_ == StakedIdOneofCase.StakedAccountId ? (global::Proto.AccountID) stakedId_ : null; }
      set {
        stakedId_ = value;
        stakedIdCase_ = value == null ? StakedIdOneofCase.None : StakedIdOneofCase.StakedAccountId;
      }
    }

    /// <summary>Field number for the "staked_node_id" field.</summary>
    public const int StakedNodeIdFieldNumber = 17;
    /// <summary>
    ///*
    /// ID of the node this account is staked to.
    /// &lt;p>
    /// If this account is not currently staking its balances, then this
    /// field, if set, SHALL be the sentinel value of `-1`.&lt;br/>
    /// Wallet software SHOULD surface staking issues to users and provide a
    /// simple mechanism to update staking to a new node ID in the event the
    /// prior staked node ID ceases to be valid.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long StakedNodeId {
      get { return HasStakedNodeId ? (long) stakedId_ : 0L; }
      set {
        stakedId_ = value;
        stakedIdCase_ = StakedIdOneofCase.StakedNodeId;
      }
    }
    /// <summary>Gets whether the "staked_node_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasStakedNodeId {
      get { return stakedIdCase_ == StakedIdOneofCase.StakedNodeId; }
    }
    /// <summary> Clears the value of the oneof if it's currently set to "staked_node_id" </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearStakedNodeId() {
      if (HasStakedNodeId) {
        ClearStakedId();
      }
    }

    /// <summary>Field number for the "decline_reward" field.</summary>
    public const int DeclineRewardFieldNumber = 18;
    private static readonly pb::FieldCodec<bool?> _single_declineReward_codec = pb::FieldCodec.ForStructWrapper<bool>(146);
    private bool? declineReward_;
    /// <summary>
    ///*
    /// A bool indicating that this account has chosen to decline rewards for
    /// staking its balances.
    /// &lt;p>
    /// This account MAY still stake its balances, but SHALL NOT receive reward
    /// payments for doing so, if this value is set, and `true`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool? DeclineReward {
      get { return declineReward_; }
      set {
        declineReward_ = value;
      }
    }


    /// <summary>Field number for the "hook_ids_to_delete" field.</summary>
    public const int HookIdsToDeleteFieldNumber = 19;
    private static readonly pb::FieldCodec<long> _repeated_hookIdsToDelete_codec
        = pb::FieldCodec.ForInt64(154);
    private readonly pbc::RepeatedField<long> hookIdsToDelete_ = new pbc::RepeatedField<long>();
    /// <summary>
    ///*
    /// The ids the hooks to delete from the account.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<long> HookIdsToDelete {
      get { return hookIdsToDelete_; }
    }

    /// <summary>Field number for the "hook_creation_details" field.</summary>
    public const int HookCreationDetailsFieldNumber = 20;
    private static readonly pb::FieldCodec<global::Com.Hedera.Hapi.Node.Hooks.HookCreationDetails> _repeated_hookCreationDetails_codec
        = pb::FieldCodec.ForMessage(162, global::Com.Hedera.Hapi.Node.Hooks.HookCreationDetails.Parser);
    private readonly pbc::RepeatedField<global::Com.Hedera.Hapi.Node.Hooks.HookCreationDetails> hookCreationDetails_ = new pbc::RepeatedField<global::Com.Hedera.Hapi.Node.Hooks.HookCreationDetails>();
    /// <summary>
    ///*
    /// The hooks to create for the account.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Com.Hedera.Hapi.Node.Hooks.HookCreationDetails> HookCreationDetails {
      get { return hookCreationDetails_; }
    }

    private object sendRecordThresholdField_;
    /// <summary>Enum of possible cases for the "sendRecordThresholdField" oneof.</summary>
    public enum SendRecordThresholdFieldOneofCase {
      None = 0,
      SendRecordThreshold = 6,
      SendRecordThresholdWrapper = 11,
    }
    private SendRecordThresholdFieldOneofCase sendRecordThresholdFieldCase_ = SendRecordThresholdFieldOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SendRecordThresholdFieldOneofCase SendRecordThresholdFieldCase {
      get { return sendRecordThresholdFieldCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSendRecordThresholdField() {
      sendRecordThresholdFieldCase_ = SendRecordThresholdFieldOneofCase.None;
      sendRecordThresholdField_ = null;
    }

    private object receiveRecordThresholdField_;
    /// <summary>Enum of possible cases for the "receiveRecordThresholdField" oneof.</summary>
    public enum ReceiveRecordThresholdFieldOneofCase {
      None = 0,
      ReceiveRecordThreshold = 7,
      ReceiveRecordThresholdWrapper = 12,
    }
    private ReceiveRecordThresholdFieldOneofCase receiveRecordThresholdFieldCase_ = ReceiveRecordThresholdFieldOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ReceiveRecordThresholdFieldOneofCase ReceiveRecordThresholdFieldCase {
      get { return receiveRecordThresholdFieldCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearReceiveRecordThresholdField() {
      receiveRecordThresholdFieldCase_ = ReceiveRecordThresholdFieldOneofCase.None;
      receiveRecordThresholdField_ = null;
    }

    private object receiverSigRequiredField_;
    /// <summary>Enum of possible cases for the "receiverSigRequiredField" oneof.</summary>
    public enum ReceiverSigRequiredFieldOneofCase {
      None = 0,
      ReceiverSigRequired = 10,
      ReceiverSigRequiredWrapper = 13,
    }
    private ReceiverSigRequiredFieldOneofCase receiverSigRequiredFieldCase_ = ReceiverSigRequiredFieldOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ReceiverSigRequiredFieldOneofCase ReceiverSigRequiredFieldCase {
      get { return receiverSigRequiredFieldCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearReceiverSigRequiredField() {
      receiverSigRequiredFieldCase_ = ReceiverSigRequiredFieldOneofCase.None;
      receiverSigRequiredField_ = null;
    }

    private object stakedId_;
    /// <summary>Enum of possible cases for the "staked_id" oneof.</summary>
    public enum StakedIdOneofCase {
      None = 0,
      StakedAccountId = 16,
      StakedNodeId = 17,
    }
    private StakedIdOneofCase stakedIdCase_ = StakedIdOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public StakedIdOneofCase StakedIdCase {
      get { return stakedIdCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearStakedId() {
      stakedIdCase_ = StakedIdOneofCase.None;
      stakedId_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as CryptoUpdateTransactionBody);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(CryptoUpdateTransactionBody other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(AccountIDToUpdate, other.AccountIDToUpdate)) return false;
      if (!object.Equals(Key, other.Key)) return false;
      if (!object.Equals(ProxyAccountID, other.ProxyAccountID)) return false;
      if (ProxyFraction != other.ProxyFraction) return false;
      if (SendRecordThreshold != other.SendRecordThreshold) return false;
      if (SendRecordThresholdWrapper != other.SendRecordThresholdWrapper) return false;
      if (ReceiveRecordThreshold != other.ReceiveRecordThreshold) return false;
      if (ReceiveRecordThresholdWrapper != other.ReceiveRecordThresholdWrapper) return false;
      if (!object.Equals(AutoRenewPeriod, other.AutoRenewPeriod)) return false;
      if (!object.Equals(ExpirationTime, other.ExpirationTime)) return false;
      if (ReceiverSigRequired != other.ReceiverSigRequired) return false;
      if (ReceiverSigRequiredWrapper != other.ReceiverSigRequiredWrapper) return false;
      if (Memo != other.Memo) return false;
      if (MaxAutomaticTokenAssociations != other.MaxAutomaticTokenAssociations) return false;
      if (!object.Equals(StakedAccountId, other.StakedAccountId)) return false;
      if (StakedNodeId != other.StakedNodeId) return false;
      if (DeclineReward != other.DeclineReward) return false;
      if(!hookIdsToDelete_.Equals(other.hookIdsToDelete_)) return false;
      if(!hookCreationDetails_.Equals(other.hookCreationDetails_)) return false;
      if (SendRecordThresholdFieldCase != other.SendRecordThresholdFieldCase) return false;
      if (ReceiveRecordThresholdFieldCase != other.ReceiveRecordThresholdFieldCase) return false;
      if (ReceiverSigRequiredFieldCase != other.ReceiverSigRequiredFieldCase) return false;
      if (StakedIdCase != other.StakedIdCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (accountIDToUpdate_ != null) hash ^= AccountIDToUpdate.GetHashCode();
      if (key_ != null) hash ^= Key.GetHashCode();
      if (proxyAccountID_ != null) hash ^= ProxyAccountID.GetHashCode();
      if (ProxyFraction != 0) hash ^= ProxyFraction.GetHashCode();
      if (HasSendRecordThreshold) hash ^= SendRecordThreshold.GetHashCode();
      if (sendRecordThresholdFieldCase_ == SendRecordThresholdFieldOneofCase.SendRecordThresholdWrapper) hash ^= SendRecordThresholdWrapper.GetHashCode();
      if (HasReceiveRecordThreshold) hash ^= ReceiveRecordThreshold.GetHashCode();
      if (receiveRecordThresholdFieldCase_ == ReceiveRecordThresholdFieldOneofCase.ReceiveRecordThresholdWrapper) hash ^= ReceiveRecordThresholdWrapper.GetHashCode();
      if (autoRenewPeriod_ != null) hash ^= AutoRenewPeriod.GetHashCode();
      if (expirationTime_ != null) hash ^= ExpirationTime.GetHashCode();
      if (HasReceiverSigRequired) hash ^= ReceiverSigRequired.GetHashCode();
      if (receiverSigRequiredFieldCase_ == ReceiverSigRequiredFieldOneofCase.ReceiverSigRequiredWrapper) hash ^= ReceiverSigRequiredWrapper.GetHashCode();
      if (memo_ != null) hash ^= Memo.GetHashCode();
      if (maxAutomaticTokenAssociations_ != null) hash ^= MaxAutomaticTokenAssociations.GetHashCode();
      if (stakedIdCase_ == StakedIdOneofCase.StakedAccountId) hash ^= StakedAccountId.GetHashCode();
      if (HasStakedNodeId) hash ^= StakedNodeId.GetHashCode();
      if (declineReward_ != null) hash ^= DeclineReward.GetHashCode();
      hash ^= hookIdsToDelete_.GetHashCode();
      hash ^= hookCreationDetails_.GetHashCode();
      hash ^= (int) sendRecordThresholdFieldCase_;
      hash ^= (int) receiveRecordThresholdFieldCase_;
      hash ^= (int) receiverSigRequiredFieldCase_;
      hash ^= (int) stakedIdCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (accountIDToUpdate_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(AccountIDToUpdate);
      }
      if (key_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Key);
      }
      if (proxyAccountID_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(ProxyAccountID);
      }
      if (ProxyFraction != 0) {
        output.WriteRawTag(40);
        output.WriteInt32(ProxyFraction);
      }
      if (HasSendRecordThreshold) {
        output.WriteRawTag(48);
        output.WriteUInt64(SendRecordThreshold);
      }
      if (HasReceiveRecordThreshold) {
        output.WriteRawTag(56);
        output.WriteUInt64(ReceiveRecordThreshold);
      }
      if (autoRenewPeriod_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(AutoRenewPeriod);
      }
      if (expirationTime_ != null) {
        output.WriteRawTag(74);
        output.WriteMessage(ExpirationTime);
      }
      if (HasReceiverSigRequired) {
        output.WriteRawTag(80);
        output.WriteBool(ReceiverSigRequired);
      }
      if (sendRecordThresholdFieldCase_ == SendRecordThresholdFieldOneofCase.SendRecordThresholdWrapper) {
        _oneof_sendRecordThresholdWrapper_codec.WriteTagAndValue(output, (ulong?) sendRecordThresholdField_);
      }
      if (receiveRecordThresholdFieldCase_ == ReceiveRecordThresholdFieldOneofCase.ReceiveRecordThresholdWrapper) {
        _oneof_receiveRecordThresholdWrapper_codec.WriteTagAndValue(output, (ulong?) receiveRecordThresholdField_);
      }
      if (receiverSigRequiredFieldCase_ == ReceiverSigRequiredFieldOneofCase.ReceiverSigRequiredWrapper) {
        _oneof_receiverSigRequiredWrapper_codec.WriteTagAndValue(output, (bool?) receiverSigRequiredField_);
      }
      if (memo_ != null) {
        _single_memo_codec.WriteTagAndValue(output, Memo);
      }
      if (maxAutomaticTokenAssociations_ != null) {
        _single_maxAutomaticTokenAssociations_codec.WriteTagAndValue(output, MaxAutomaticTokenAssociations);
      }
      if (stakedIdCase_ == StakedIdOneofCase.StakedAccountId) {
        output.WriteRawTag(130, 1);
        output.WriteMessage(StakedAccountId);
      }
      if (HasStakedNodeId) {
        output.WriteRawTag(136, 1);
        output.WriteInt64(StakedNodeId);
      }
      if (declineReward_ != null) {
        _single_declineReward_codec.WriteTagAndValue(output, DeclineReward);
      }
      hookIdsToDelete_.WriteTo(output, _repeated_hookIdsToDelete_codec);
      hookCreationDetails_.WriteTo(output, _repeated_hookCreationDetails_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (accountIDToUpdate_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(AccountIDToUpdate);
      }
      if (key_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Key);
      }
      if (proxyAccountID_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(ProxyAccountID);
      }
      if (ProxyFraction != 0) {
        output.WriteRawTag(40);
        output.WriteInt32(ProxyFraction);
      }
      if (HasSendRecordThreshold) {
        output.WriteRawTag(48);
        output.WriteUInt64(SendRecordThreshold);
      }
      if (HasReceiveRecordThreshold) {
        output.WriteRawTag(56);
        output.WriteUInt64(ReceiveRecordThreshold);
      }
      if (autoRenewPeriod_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(AutoRenewPeriod);
      }
      if (expirationTime_ != null) {
        output.WriteRawTag(74);
        output.WriteMessage(ExpirationTime);
      }
      if (HasReceiverSigRequired) {
        output.WriteRawTag(80);
        output.WriteBool(ReceiverSigRequired);
      }
      if (sendRecordThresholdFieldCase_ == SendRecordThresholdFieldOneofCase.SendRecordThresholdWrapper) {
        _oneof_sendRecordThresholdWrapper_codec.WriteTagAndValue(ref output, (ulong?) sendRecordThresholdField_);
      }
      if (receiveRecordThresholdFieldCase_ == ReceiveRecordThresholdFieldOneofCase.ReceiveRecordThresholdWrapper) {
        _oneof_receiveRecordThresholdWrapper_codec.WriteTagAndValue(ref output, (ulong?) receiveRecordThresholdField_);
      }
      if (receiverSigRequiredFieldCase_ == ReceiverSigRequiredFieldOneofCase.ReceiverSigRequiredWrapper) {
        _oneof_receiverSigRequiredWrapper_codec.WriteTagAndValue(ref output, (bool?) receiverSigRequiredField_);
      }
      if (memo_ != null) {
        _single_memo_codec.WriteTagAndValue(ref output, Memo);
      }
      if (maxAutomaticTokenAssociations_ != null) {
        _single_maxAutomaticTokenAssociations_codec.WriteTagAndValue(ref output, MaxAutomaticTokenAssociations);
      }
      if (stakedIdCase_ == StakedIdOneofCase.StakedAccountId) {
        output.WriteRawTag(130, 1);
        output.WriteMessage(StakedAccountId);
      }
      if (HasStakedNodeId) {
        output.WriteRawTag(136, 1);
        output.WriteInt64(StakedNodeId);
      }
      if (declineReward_ != null) {
        _single_declineReward_codec.WriteTagAndValue(ref output, DeclineReward);
      }
      hookIdsToDelete_.WriteTo(ref output, _repeated_hookIdsToDelete_codec);
      hookCreationDetails_.WriteTo(ref output, _repeated_hookCreationDetails_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (accountIDToUpdate_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(AccountIDToUpdate);
      }
      if (key_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Key);
      }
      if (proxyAccountID_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ProxyAccountID);
      }
      if (ProxyFraction != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(ProxyFraction);
      }
      if (HasSendRecordThreshold) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(SendRecordThreshold);
      }
      if (sendRecordThresholdFieldCase_ == SendRecordThresholdFieldOneofCase.SendRecordThresholdWrapper) {
        size += _oneof_sendRecordThresholdWrapper_codec.CalculateSizeWithTag(SendRecordThresholdWrapper);
      }
      if (HasReceiveRecordThreshold) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(ReceiveRecordThreshold);
      }
      if (receiveRecordThresholdFieldCase_ == ReceiveRecordThresholdFieldOneofCase.ReceiveRecordThresholdWrapper) {
        size += _oneof_receiveRecordThresholdWrapper_codec.CalculateSizeWithTag(ReceiveRecordThresholdWrapper);
      }
      if (autoRenewPeriod_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(AutoRenewPeriod);
      }
      if (expirationTime_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ExpirationTime);
      }
      if (HasReceiverSigRequired) {
        size += 1 + 1;
      }
      if (receiverSigRequiredFieldCase_ == ReceiverSigRequiredFieldOneofCase.ReceiverSigRequiredWrapper) {
        size += _oneof_receiverSigRequiredWrapper_codec.CalculateSizeWithTag(ReceiverSigRequiredWrapper);
      }
      if (memo_ != null) {
        size += _single_memo_codec.CalculateSizeWithTag(Memo);
      }
      if (maxAutomaticTokenAssociations_ != null) {
        size += _single_maxAutomaticTokenAssociations_codec.CalculateSizeWithTag(MaxAutomaticTokenAssociations);
      }
      if (stakedIdCase_ == StakedIdOneofCase.StakedAccountId) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(StakedAccountId);
      }
      if (HasStakedNodeId) {
        size += 2 + pb::CodedOutputStream.ComputeInt64Size(StakedNodeId);
      }
      if (declineReward_ != null) {
        size += _single_declineReward_codec.CalculateSizeWithTag(DeclineReward);
      }
      size += hookIdsToDelete_.CalculateSize(_repeated_hookIdsToDelete_codec);
      size += hookCreationDetails_.CalculateSize(_repeated_hookCreationDetails_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(CryptoUpdateTransactionBody other) {
      if (other == null) {
        return;
      }
      if (other.accountIDToUpdate_ != null) {
        if (accountIDToUpdate_ == null) {
          AccountIDToUpdate = new global::Proto.AccountID();
        }
        AccountIDToUpdate.MergeFrom(other.AccountIDToUpdate);
      }
      if (other.key_ != null) {
        if (key_ == null) {
          Key = new global::Proto.Key();
        }
        Key.MergeFrom(other.Key);
      }
      if (other.proxyAccountID_ != null) {
        if (proxyAccountID_ == null) {
          ProxyAccountID = new global::Proto.AccountID();
        }
        ProxyAccountID.MergeFrom(other.ProxyAccountID);
      }
      if (other.ProxyFraction != 0) {
        ProxyFraction = other.ProxyFraction;
      }
      if (other.autoRenewPeriod_ != null) {
        if (autoRenewPeriod_ == null) {
          AutoRenewPeriod = new global::Proto.Duration();
        }
        AutoRenewPeriod.MergeFrom(other.AutoRenewPeriod);
      }
      if (other.expirationTime_ != null) {
        if (expirationTime_ == null) {
          ExpirationTime = new global::Proto.Timestamp();
        }
        ExpirationTime.MergeFrom(other.ExpirationTime);
      }
      if (other.memo_ != null) {
        if (memo_ == null || other.Memo != "") {
          Memo = other.Memo;
        }
      }
      if (other.maxAutomaticTokenAssociations_ != null) {
        if (maxAutomaticTokenAssociations_ == null || other.MaxAutomaticTokenAssociations != 0) {
          MaxAutomaticTokenAssociations = other.MaxAutomaticTokenAssociations;
        }
      }
      if (other.declineReward_ != null) {
        if (declineReward_ == null || other.DeclineReward != false) {
          DeclineReward = other.DeclineReward;
        }
      }
      hookIdsToDelete_.Add(other.hookIdsToDelete_);
      hookCreationDetails_.Add(other.hookCreationDetails_);
      switch (other.SendRecordThresholdFieldCase) {
        case SendRecordThresholdFieldOneofCase.SendRecordThreshold:
          SendRecordThreshold = other.SendRecordThreshold;
          break;
        case SendRecordThresholdFieldOneofCase.SendRecordThresholdWrapper:
          SendRecordThresholdWrapper = other.SendRecordThresholdWrapper;
          break;
      }

      switch (other.ReceiveRecordThresholdFieldCase) {
        case ReceiveRecordThresholdFieldOneofCase.ReceiveRecordThreshold:
          ReceiveRecordThreshold = other.ReceiveRecordThreshold;
          break;
        case ReceiveRecordThresholdFieldOneofCase.ReceiveRecordThresholdWrapper:
          ReceiveRecordThresholdWrapper = other.ReceiveRecordThresholdWrapper;
          break;
      }

      switch (other.ReceiverSigRequiredFieldCase) {
        case ReceiverSigRequiredFieldOneofCase.ReceiverSigRequired:
          ReceiverSigRequired = other.ReceiverSigRequired;
          break;
        case ReceiverSigRequiredFieldOneofCase.ReceiverSigRequiredWrapper:
          ReceiverSigRequiredWrapper = other.ReceiverSigRequiredWrapper;
          break;
      }

      switch (other.StakedIdCase) {
        case StakedIdOneofCase.StakedAccountId:
          if (StakedAccountId == null) {
            StakedAccountId = new global::Proto.AccountID();
          }
          StakedAccountId.MergeFrom(other.StakedAccountId);
          break;
        case StakedIdOneofCase.StakedNodeId:
          StakedNodeId = other.StakedNodeId;
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 18: {
            if (accountIDToUpdate_ == null) {
              AccountIDToUpdate = new global::Proto.AccountID();
            }
            input.ReadMessage(AccountIDToUpdate);
            break;
          }
          case 26: {
            if (key_ == null) {
              Key = new global::Proto.Key();
            }
            input.ReadMessage(Key);
            break;
          }
          case 34: {
            if (proxyAccountID_ == null) {
              ProxyAccountID = new global::Proto.AccountID();
            }
            input.ReadMessage(ProxyAccountID);
            break;
          }
          case 40: {
            ProxyFraction = input.ReadInt32();
            break;
          }
          case 48: {
            SendRecordThreshold = input.ReadUInt64();
            break;
          }
          case 56: {
            ReceiveRecordThreshold = input.ReadUInt64();
            break;
          }
          case 66: {
            if (autoRenewPeriod_ == null) {
              AutoRenewPeriod = new global::Proto.Duration();
            }
            input.ReadMessage(AutoRenewPeriod);
            break;
          }
          case 74: {
            if (expirationTime_ == null) {
              ExpirationTime = new global::Proto.Timestamp();
            }
            input.ReadMessage(ExpirationTime);
            break;
          }
          case 80: {
            ReceiverSigRequired = input.ReadBool();
            break;
          }
          case 90: {
            SendRecordThresholdWrapper = _oneof_sendRecordThresholdWrapper_codec.Read(input);
            break;
          }
          case 98: {
            ReceiveRecordThresholdWrapper = _oneof_receiveRecordThresholdWrapper_codec.Read(input);
            break;
          }
          case 106: {
            ReceiverSigRequiredWrapper = _oneof_receiverSigRequiredWrapper_codec.Read(input);
            break;
          }
          case 114: {
            string value = _single_memo_codec.Read(input);
            if (memo_ == null || value != "") {
              Memo = value;
            }
            break;
          }
          case 122: {
            int? value = _single_maxAutomaticTokenAssociations_codec.Read(input);
            if (maxAutomaticTokenAssociations_ == null || value != 0) {
              MaxAutomaticTokenAssociations = value;
            }
            break;
          }
          case 130: {
            global::Proto.AccountID subBuilder = new global::Proto.AccountID();
            if (stakedIdCase_ == StakedIdOneofCase.StakedAccountId) {
              subBuilder.MergeFrom(StakedAccountId);
            }
            input.ReadMessage(subBuilder);
            StakedAccountId = subBuilder;
            break;
          }
          case 136: {
            StakedNodeId = input.ReadInt64();
            break;
          }
          case 146: {
            bool? value = _single_declineReward_codec.Read(input);
            if (declineReward_ == null || value != false) {
              DeclineReward = value;
            }
            break;
          }
          case 154:
          case 152: {
            hookIdsToDelete_.AddEntriesFrom(input, _repeated_hookIdsToDelete_codec);
            break;
          }
          case 162: {
            hookCreationDetails_.AddEntriesFrom(input, _repeated_hookCreationDetails_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 18: {
            if (accountIDToUpdate_ == null) {
              AccountIDToUpdate = new global::Proto.AccountID();
            }
            input.ReadMessage(AccountIDToUpdate);
            break;
          }
          case 26: {
            if (key_ == null) {
              Key = new global::Proto.Key();
            }
            input.ReadMessage(Key);
            break;
          }
          case 34: {
            if (proxyAccountID_ == null) {
              ProxyAccountID = new global::Proto.AccountID();
            }
            input.ReadMessage(ProxyAccountID);
            break;
          }
          case 40: {
            ProxyFraction = input.ReadInt32();
            break;
          }
          case 48: {
            SendRecordThreshold = input.ReadUInt64();
            break;
          }
          case 56: {
            ReceiveRecordThreshold = input.ReadUInt64();
            break;
          }
          case 66: {
            if (autoRenewPeriod_ == null) {
              AutoRenewPeriod = new global::Proto.Duration();
            }
            input.ReadMessage(AutoRenewPeriod);
            break;
          }
          case 74: {
            if (expirationTime_ == null) {
              ExpirationTime = new global::Proto.Timestamp();
            }
            input.ReadMessage(ExpirationTime);
            break;
          }
          case 80: {
            ReceiverSigRequired = input.ReadBool();
            break;
          }
          case 90: {
            SendRecordThresholdWrapper = _oneof_sendRecordThresholdWrapper_codec.Read(ref input);
            break;
          }
          case 98: {
            ReceiveRecordThresholdWrapper = _oneof_receiveRecordThresholdWrapper_codec.Read(ref input);
            break;
          }
          case 106: {
            ReceiverSigRequiredWrapper = _oneof_receiverSigRequiredWrapper_codec.Read(ref input);
            break;
          }
          case 114: {
            string value = _single_memo_codec.Read(ref input);
            if (memo_ == null || value != "") {
              Memo = value;
            }
            break;
          }
          case 122: {
            int? value = _single_maxAutomaticTokenAssociations_codec.Read(ref input);
            if (maxAutomaticTokenAssociations_ == null || value != 0) {
              MaxAutomaticTokenAssociations = value;
            }
            break;
          }
          case 130: {
            global::Proto.AccountID subBuilder = new global::Proto.AccountID();
            if (stakedIdCase_ == StakedIdOneofCase.StakedAccountId) {
              subBuilder.MergeFrom(StakedAccountId);
            }
            input.ReadMessage(subBuilder);
            StakedAccountId = subBuilder;
            break;
          }
          case 136: {
            StakedNodeId = input.ReadInt64();
            break;
          }
          case 146: {
            bool? value = _single_declineReward_codec.Read(ref input);
            if (declineReward_ == null || value != false) {
              DeclineReward = value;
            }
            break;
          }
          case 154:
          case 152: {
            hookIdsToDelete_.AddEntriesFrom(ref input, _repeated_hookIdsToDelete_codec);
            break;
          }
          case 162: {
            hookCreationDetails_.AddEntriesFrom(ref input, _repeated_hookCreationDetails_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  #endregion

}

#endregion Designer generated code
