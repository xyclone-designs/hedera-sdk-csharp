// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: token_create.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021, 8981
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Proto {

  /// <summary>Holder for reflection information generated from token_create.proto</summary>
  public static partial class TokenCreateReflection {

    #region Descriptor
    /// <summary>File descriptor for token_create.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static TokenCreateReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "ChJ0b2tlbl9jcmVhdGUucHJvdG8SBXByb3RvGg5kdXJhdGlvbi5wcm90bxoR",
            "YmFzaWNfdHlwZXMucHJvdG8aEWN1c3RvbV9mZWVzLnByb3RvGg90aW1lc3Rh",
            "bXAucHJvdG8ivQUKGlRva2VuQ3JlYXRlVHJhbnNhY3Rpb25Cb2R5EgwKBG5h",
            "bWUYASABKAkSDgoGc3ltYm9sGAIgASgJEhAKCGRlY2ltYWxzGAMgASgNEhUK",
            "DWluaXRpYWxTdXBwbHkYBCABKAQSIgoIdHJlYXN1cnkYBSABKAsyEC5wcm90",
            "by5BY2NvdW50SUQSHAoIYWRtaW5LZXkYBiABKAsyCi5wcm90by5LZXkSGgoG",
            "a3ljS2V5GAcgASgLMgoucHJvdG8uS2V5Eh0KCWZyZWV6ZUtleRgIIAEoCzIK",
            "LnByb3RvLktleRIbCgd3aXBlS2V5GAkgASgLMgoucHJvdG8uS2V5Eh0KCXN1",
            "cHBseUtleRgKIAEoCzIKLnByb3RvLktleRIVCg1mcmVlemVEZWZhdWx0GAsg",
            "ASgIEiAKBmV4cGlyeRgNIAEoCzIQLnByb3RvLlRpbWVzdGFtcBIqChBhdXRv",
            "UmVuZXdBY2NvdW50GA4gASgLMhAucHJvdG8uQWNjb3VudElEEigKD2F1dG9S",
            "ZW5ld1BlcmlvZBgPIAEoCzIPLnByb3RvLkR1cmF0aW9uEgwKBG1lbW8YECAB",
            "KAkSIwoJdG9rZW5UeXBlGBEgASgOMhAucHJvdG8uVG9rZW5UeXBlEioKCnN1",
            "cHBseVR5cGUYEiABKA4yFi5wcm90by5Ub2tlblN1cHBseVR5cGUSEQoJbWF4",
            "U3VwcGx5GBMgASgDEiQKEGZlZV9zY2hlZHVsZV9rZXkYFCABKAsyCi5wcm90",
            "by5LZXkSJQoLY3VzdG9tX2ZlZXMYFSADKAsyEC5wcm90by5DdXN0b21GZWUS",
            "HQoJcGF1c2Vfa2V5GBYgASgLMgoucHJvdG8uS2V5EhAKCG1ldGFkYXRhGBcg",
            "ASgMEiAKDG1ldGFkYXRhX2tleRgYIAEoCzIKLnByb3RvLktleUIiCh5jb20u",
            "aGVkZXJhLmhhc2hncmFwaC5zZGsucHJvdG9QAWIGcHJvdG8z"));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Proto.DurationReflection.Descriptor, global::Proto.BasicTypesReflection.Descriptor, global::Proto.CustomFeesReflection.Descriptor, global::Proto.TimestampReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Proto.TokenCreateTransactionBody), global::Proto.TokenCreateTransactionBody.Parser, new[]{ "Name", "Symbol", "Decimals", "InitialSupply", "Treasury", "AdminKey", "KycKey", "FreezeKey", "WipeKey", "SupplyKey", "FreezeDefault", "Expiry", "AutoRenewAccount", "AutoRenewPeriod", "Memo", "TokenType", "SupplyType", "MaxSupply", "FeeScheduleKey", "CustomFees", "PauseKey", "Metadata", "MetadataKey" }, null, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  ///*
  /// Create an HTS token.
  ///
  /// #### Keys
  /// Each token has several keys that, separately, control different functions
  /// for that token. It is *_strongly_* recommended that each key assigned to
  /// a token be unique, or disabled by assigning an empty `KeyList`.
  /// Keys and purpose
  /// - `adminKey` is a general access and may authorize a token update
  ///   transaction as well as _update the other keys_. Even the admin key
  ///   cannot authorize _adding_ a key that is not present, however.&lt;br/>
  ///   The admin key may also delete the token entirely.
  /// - `fee_schedule` may authorize updating the token custom fees. If this
  ///   key is not present, the custom fees for the token are fixed and immutable.
  /// - `freeze` may authorize a token freeze or unfreeze transaction.
  ///   If this key is not present, accounts holding this token cannot have
  ///   their tokens frozen or unfrozen.
  /// - `kyc` may authorize a token grant KYC or revoke KYC transaction.
  ///   If this key is not present, accounts holding this token cannot have
  ///   KYC status granted or revoked.
  /// - `metadata` may authorize token update nfts transactions.
  ///   If this key is not present, the token metadata values for that
  ///   non-fungible/unique token _type_ will be immutable.
  /// - `pause` may authorize a token pause or token unpause transaction.
  ///   If this key is not present, the token cannot be paused (preventing any
  ///   account from transacting in that token) or resumed.
  /// - `supply` may authorize a token mint or burn transaction.
  ///   If this key is not present, the token cannot mint additional supply and
  ///   existing tokens cannot be "burned" from the treasury (but _might_ still be
  ///   "burned" from individual accounts, c.f. `wipeKey` and `tokenWipe`).
  /// - `wipe` may authorize a token wipe account transaction.
  ///   If this key is not present, accounts holding this token cannot have
  ///   their balance or NFTs wiped (effectively burned).
  ///
  /// #### Requirements
  /// If `tokenType` is fungible/common, the `initialSupply` MUST be strictly
  /// greater than zero(`0`).&lt;br/>
  /// If `tokenType` is non-fungible/unique, the `initialSupply` MUST
  /// be zero(`0`).&lt;br/>
  /// If `tokenSupplyType` is "infinite", the `maxSupply` MUST be zero(`0`).&lt;br/>
  /// If `tokenSupplyType` is "finite", the `maxSupply` MUST be strictly
  /// greater than zero(`0`).&lt;br/>
  ///
  /// ### Block Stream Effects
  /// If the token is created, the Token Identifier SHALL be in the receipt.&lt;br/>
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class TokenCreateTransactionBody : pb::IMessage<TokenCreateTransactionBody>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<TokenCreateTransactionBody> _parser = new pb::MessageParser<TokenCreateTransactionBody>(() => new TokenCreateTransactionBody());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<TokenCreateTransactionBody> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Proto.TokenCreateReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TokenCreateTransactionBody() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TokenCreateTransactionBody(TokenCreateTransactionBody other) : this() {
      name_ = other.name_;
      symbol_ = other.symbol_;
      decimals_ = other.decimals_;
      initialSupply_ = other.initialSupply_;
      treasury_ = other.treasury_ != null ? other.treasury_.Clone() : null;
      adminKey_ = other.adminKey_ != null ? other.adminKey_.Clone() : null;
      kycKey_ = other.kycKey_ != null ? other.kycKey_.Clone() : null;
      freezeKey_ = other.freezeKey_ != null ? other.freezeKey_.Clone() : null;
      wipeKey_ = other.wipeKey_ != null ? other.wipeKey_.Clone() : null;
      supplyKey_ = other.supplyKey_ != null ? other.supplyKey_.Clone() : null;
      freezeDefault_ = other.freezeDefault_;
      expiry_ = other.expiry_ != null ? other.expiry_.Clone() : null;
      autoRenewAccount_ = other.autoRenewAccount_ != null ? other.autoRenewAccount_.Clone() : null;
      autoRenewPeriod_ = other.autoRenewPeriod_ != null ? other.autoRenewPeriod_.Clone() : null;
      memo_ = other.memo_;
      tokenType_ = other.tokenType_;
      supplyType_ = other.supplyType_;
      maxSupply_ = other.maxSupply_;
      feeScheduleKey_ = other.feeScheduleKey_ != null ? other.feeScheduleKey_.Clone() : null;
      customFees_ = other.customFees_.Clone();
      pauseKey_ = other.pauseKey_ != null ? other.pauseKey_.Clone() : null;
      metadata_ = other.metadata_;
      metadataKey_ = other.metadataKey_ != null ? other.metadataKey_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TokenCreateTransactionBody Clone() {
      return new TokenCreateTransactionBody(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    ///*
    /// A name for the token.&lt;br/>
    /// This is generally the "full name" displayed in wallet software.
    /// &lt;p>
    /// This field is REQUIRED.&lt;br/>
    /// This value MUST NOT exceed 100 bytes when encoded as UTF-8.&lt;br/>
    /// This value MUST NOT contain the Unicode NUL codepoint.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "symbol" field.</summary>
    public const int SymbolFieldNumber = 2;
    private string symbol_ = "";
    /// <summary>
    ///*
    /// A symbol to use for the token.
    /// &lt;p>
    /// This field is REQUIRED.&lt;br/>
    /// This value MUST NOT exceed 100 bytes when encoded as UTF-8.&lt;br/>
    /// This value MUST NOT contain the Unicode NUL codepoint.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Symbol {
      get { return symbol_; }
      set {
        symbol_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "decimals" field.</summary>
    public const int DecimalsFieldNumber = 3;
    private uint decimals_;
    /// <summary>
    ///*
    /// A decimal precision of the token's smallest denomination.&lt;br/>
    /// Most values are described in terms of this smallest denomination,
    /// so the token initial supply, for instance, must be divided by
    /// &lt;tt>10&lt;sup>decimals&lt;/sup>&lt;/tt> to get whole tokens.
    /// &lt;p>
    /// This MUST be zero(`0`) for non-fungible/unique tokens.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint Decimals {
      get { return decimals_; }
      set {
        decimals_ = value;
      }
    }

    /// <summary>Field number for the "initialSupply" field.</summary>
    public const int InitialSupplyFieldNumber = 4;
    private ulong initialSupply_;
    /// <summary>
    ///*
    /// An initial supply, in the smallest denomination for the token.
    /// &lt;p>
    /// This amount SHALL be transferred to the treasury account as part
    /// of this transaction.&lt;br/>
    /// This amount MUST be specified in the smallest denomination for the
    /// token (i.e. &lt;tt>10&lt;sup>-decimals&lt;/sup>&lt;/tt> whole tokens).&lt;br/>
    /// This MUST be zero(`0`) for a non-fungible/unique token.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ulong InitialSupply {
      get { return initialSupply_; }
      set {
        initialSupply_ = value;
      }
    }

    /// <summary>Field number for the "treasury" field.</summary>
    public const int TreasuryFieldNumber = 5;
    private global::Proto.AccountID treasury_;
    /// <summary>
    ///*
    /// A treasury account identifier.
    /// &lt;p>
    /// This field is REQUIRED.&lt;br/>
    /// The identified account SHALL be designated the "treasury" for the
    /// new token, and all tokens "minted" SHALL be delivered to that account,
    /// including the initial supply, if any.&lt;br/>
    /// The identified account MUST exist, MUST NOT be expired, and SHOULD
    /// have a non-zero HBAR balance.&lt;br/>
    /// The identified account SHALL be associated to the new token.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.AccountID Treasury {
      get { return treasury_; }
      set {
        treasury_ = value;
      }
    }

    /// <summary>Field number for the "adminKey" field.</summary>
    public const int AdminKeyFieldNumber = 6;
    private global::Proto.Key adminKey_;
    /// <summary>
    ///*
    /// An Hedera key for token administration.
    /// &lt;p>
    /// This key, if set, SHALL have administrative authority for this token and
    /// MAY authorize token update and/or token delete transactions.&lt;br/>
    /// If this key is not set, or is an empty `KeyList`, this token SHALL be
    /// immutable, except for expiration and renewal.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.Key AdminKey {
      get { return adminKey_; }
      set {
        adminKey_ = value;
      }
    }

    /// <summary>Field number for the "kycKey" field.</summary>
    public const int KycKeyFieldNumber = 7;
    private global::Proto.Key kycKey_;
    /// <summary>
    ///*
    /// An Hedera key for managing account KYC.
    /// &lt;p>
    /// This key, if set, SHALL have KYC authority for this token and
    /// MAY authorize transactions to grant or revoke KYC for accounts.&lt;br/>
    /// If this key is not set, or is an empty `KeyList`, KYC status for this
    /// token SHALL NOT be granted or revoked for any account.&lt;br/>
    /// If this key is removed after granting KYC, those grants SHALL remain
    /// and cannot be revoked.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.Key KycKey {
      get { return kycKey_; }
      set {
        kycKey_ = value;
      }
    }

    /// <summary>Field number for the "freezeKey" field.</summary>
    public const int FreezeKeyFieldNumber = 8;
    private global::Proto.Key freezeKey_;
    /// <summary>
    ///*
    /// An Hedera key for managing asset "freeze".
    /// &lt;p>
    /// This key, if set, SHALL have "freeze" authority for this token and
    /// MAY authorize transactions to freeze or unfreeze accounts
    /// with respect to this token.&lt;br/>
    /// If this key is not set, or is an empty `KeyList`, this token
    /// SHALL NOT be frozen or unfrozen for any account.&lt;br/>
    /// If this key is removed after freezing accounts, those accounts
    /// SHALL remain frozen and cannot be unfrozen.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.Key FreezeKey {
      get { return freezeKey_; }
      set {
        freezeKey_ = value;
      }
    }

    /// <summary>Field number for the "wipeKey" field.</summary>
    public const int WipeKeyFieldNumber = 9;
    private global::Proto.Key wipeKey_;
    /// <summary>
    ///*
    /// An Hedera key for wiping tokens from accounts.
    /// &lt;p>
    /// This key, if set, SHALL have "wipe" authority for this token and
    /// MAY authorize transactions to "wipe" any amount of this token from
    /// any account, effectively burning the tokens "wiped".&lt;br/>
    /// If this key is not set, or is an empty `KeyList`, it SHALL NOT be
    /// possible to "wipe" this token from an account.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.Key WipeKey {
      get { return wipeKey_; }
      set {
        wipeKey_ = value;
      }
    }

    /// <summary>Field number for the "supplyKey" field.</summary>
    public const int SupplyKeyFieldNumber = 10;
    private global::Proto.Key supplyKey_;
    /// <summary>
    ///*
    /// An Hedera key for "minting" and "burning" tokens.
    /// &lt;p>
    /// This key, if set, MAY authorize transactions to "mint" new tokens to
    /// be delivered to the token treasury or "burn" tokens held by the
    /// token treasury.&lt;br/>
    /// If this key is not set, or is an empty `KeyList`, it SHALL NOT be
    /// possible to change the supply of tokens and neither "mint" nor "burn"
    /// transactions SHALL be permitted.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.Key SupplyKey {
      get { return supplyKey_; }
      set {
        supplyKey_ = value;
      }
    }

    /// <summary>Field number for the "freezeDefault" field.</summary>
    public const int FreezeDefaultFieldNumber = 11;
    private bool freezeDefault_;
    /// <summary>
    ///*
    /// An initial Freeze status for accounts associated to this token.
    /// &lt;p>
    /// If this value is set, an account MUST be the subject of a
    /// `tokenUnfreeze` transaction after associating to the token before
    /// that account can send or receive this token.&lt;br/>
    /// If this value is set, the `freezeKey` SHOULD be set.&lt;br/>
    /// If the `freezeKey` is not set, any account associated to this token
    /// while this value is set SHALL be permanently frozen.
    /// &lt;p>
    /// &lt;blockquote>REVIEW NOTE&lt;blockquote>
    /// Should we prevent setting this value true for tokens with no freeze
    /// key?&lt;br/>
    /// Should we set this value to false if a freeze key is removed?
    /// &lt;/blockquote>&lt;/blockquote>
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool FreezeDefault {
      get { return freezeDefault_; }
      set {
        freezeDefault_ = value;
      }
    }

    /// <summary>Field number for the "expiry" field.</summary>
    public const int ExpiryFieldNumber = 13;
    private global::Proto.Timestamp expiry_;
    /// <summary>
    ///*
    /// An expiration timestamp.
    /// &lt;p>
    /// If the `autoRenewAccount` and `autoRenewPeriod` fields are set, this
    /// value SHALL be replaced with the current consensus time extended
    /// by the `autoRenewPeriod` duration.&lt;br/>
    /// If this value is set and token expiration is enabled in network
    /// configuration, this token SHALL expire when consensus time exceeds
    /// this value, and MAY be subsequently removed from the network state.&lt;br/>
    /// If this value is not set, and the automatic renewal account is also not
    /// set, then this value SHALL default to the current consensus time
    /// extended by the "default" expiration period from network configuration.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.Timestamp Expiry {
      get { return expiry_; }
      set {
        expiry_ = value;
      }
    }

    /// <summary>Field number for the "autoRenewAccount" field.</summary>
    public const int AutoRenewAccountFieldNumber = 14;
    private global::Proto.AccountID autoRenewAccount_;
    /// <summary>
    ///*
    /// An identifier for the account to be charged renewal fees at the token's
    /// expiry to extend the lifetime of the token.
    /// &lt;p>
    /// If this value is set, the token lifetime SHALL be extended by the
    /// _smallest_ of the following:
    /// &lt;ul>
    ///   &lt;li>The current `autoRenewPeriod` duration.&lt;/li>
    ///   &lt;li>The maximum duration that this account has funds to purchase.&lt;/li>
    ///   &lt;li>The configured MAX_AUTORENEW_PERIOD at the time of automatic
    ///       renewal.&lt;/li>
    /// &lt;/ul>
    /// If this account's HBAR balance is `0` when the token must be
    /// renewed, then the token SHALL be expired, and MAY be subsequently
    /// removed from state.&lt;br/>
    /// If this value is set, the referenced account MUST sign this
    /// transaction.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.AccountID AutoRenewAccount {
      get { return autoRenewAccount_; }
      set {
        autoRenewAccount_ = value;
      }
    }

    /// <summary>Field number for the "autoRenewPeriod" field.</summary>
    public const int AutoRenewPeriodFieldNumber = 15;
    private global::Proto.Duration autoRenewPeriod_;
    /// <summary>
    ///*
    /// A duration between token automatic renewals.&lt;br/>
    /// All entities in state may be charged "rent" occasionally (typically
    /// every 90 days) to prevent unnecessary growth of the ledger. This value
    /// sets the interval between such events for this token.
    /// &lt;p>
    /// This value MUST be set.&lt;br/>
    /// This value MUST be greater than the configured
    /// MIN_AUTORENEW_PERIOD.&lt;br/>
    /// This value MUST be less than the configured MAX_AUTORENEW_PERIOD.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.Duration AutoRenewPeriod {
      get { return autoRenewPeriod_; }
      set {
        autoRenewPeriod_ = value;
      }
    }

    /// <summary>Field number for the "memo" field.</summary>
    public const int MemoFieldNumber = 16;
    private string memo_ = "";
    /// <summary>
    ///*
    /// A short description for this token.
    /// &lt;p>
    /// This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
    /// (default 100) bytes when encoded as UTF-8.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Memo {
      get { return memo_; }
      set {
        memo_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "tokenType" field.</summary>
    public const int TokenTypeFieldNumber = 17;
    private global::Proto.TokenType tokenType_ = global::Proto.TokenType.FungibleCommon;
    /// <summary>
    ///*
    /// A type for this token, according to IWA classification.
    /// &lt;p>
    /// If this value is not set, the token SHALL have the default type of
    /// fungible/common.&lt;br/>
    /// This field SHALL be immutable.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.TokenType TokenType {
      get { return tokenType_; }
      set {
        tokenType_ = value;
      }
    }

    /// <summary>Field number for the "supplyType" field.</summary>
    public const int SupplyTypeFieldNumber = 18;
    private global::Proto.TokenSupplyType supplyType_ = global::Proto.TokenSupplyType.Infinite;
    /// <summary>
    ///*
    /// A supply type for this token, according to IWA classification.
    /// &lt;p>
    /// If this value is not set, the token SHALL have the default supply
    /// type of "infinite" (which is, as a practical matter,
    /// (2&lt;sup>&lt;i>63&lt;/i>&lt;/sup>-1)/10&lt;sup>&lt;i>decimals&lt;/i>&lt;/sup>).&lt;br/>
    /// This field SHALL be immutable.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.TokenSupplyType SupplyType {
      get { return supplyType_; }
      set {
        supplyType_ = value;
      }
    }

    /// <summary>Field number for the "maxSupply" field.</summary>
    public const int MaxSupplyFieldNumber = 19;
    private long maxSupply_;
    /// <summary>
    ///*
    /// A maximum supply for this token.
    /// &lt;p>
    /// This SHALL be interpreted in terms of the smallest fractional unit for
    /// this token.&lt;br/>
    /// If `supplyType` is "infinite", this MUST be `0`.&lt;br/>
    /// This field SHALL be immutable.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long MaxSupply {
      get { return maxSupply_; }
      set {
        maxSupply_ = value;
      }
    }

    /// <summary>Field number for the "fee_schedule_key" field.</summary>
    public const int FeeScheduleKeyFieldNumber = 20;
    private global::Proto.Key feeScheduleKey_;
    /// <summary>
    ///*
    /// An Hedera key for managing the token custom fee schedule.
    /// &lt;p>
    /// This key, if set, MAY authorize transactions to modify the
    /// `custom_fees` for this token.&lt;br/>
    /// If this key is not set, or is an empty `KeyList`, the `custom_fees`
    /// for this token SHALL NOT be modified.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.Key FeeScheduleKey {
      get { return feeScheduleKey_; }
      set {
        feeScheduleKey_ = value;
      }
    }

    /// <summary>Field number for the "custom_fees" field.</summary>
    public const int CustomFeesFieldNumber = 21;
    private static readonly pb::FieldCodec<global::Proto.CustomFee> _repeated_customFees_codec
        = pb::FieldCodec.ForMessage(170, global::Proto.CustomFee.Parser);
    private readonly pbc::RepeatedField<global::Proto.CustomFee> customFees_ = new pbc::RepeatedField<global::Proto.CustomFee>();
    /// <summary>
    ///*
    /// A list of custom fees representing a fee schedule.
    /// &lt;p>
    /// This list MAY be empty, which SHALL mean that there
    /// are no custom fees for this token.&lt;br/>
    /// If this token is a non-fungible/unique type, the entries
    /// in this list MUST NOT declare a `fractional_fee`.&lt;br/>
    /// If this token is a fungible/common type, the entries in this
    /// list MUST NOT declare a `royalty_fee`.&lt;br/>
    /// Any token type MAY include entries that declare a `fixed_fee`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Proto.CustomFee> CustomFees {
      get { return customFees_; }
    }

    /// <summary>Field number for the "pause_key" field.</summary>
    public const int PauseKeyFieldNumber = 22;
    private global::Proto.Key pauseKey_;
    /// <summary>
    ///*
    /// An Hedera key for managing token "pause".
    /// &lt;p>
    /// This key, if set, SHALL have "pause" authority for this token and
    /// MAY authorize transactions to pause or unpause this token.&lt;br/>
    /// If this key is not set, or is an empty `KeyList`, this token
    /// SHALL NOT be paused or unpaused.&lt;br/>
    /// If this key is removed while the token is paused, the token cannot
    /// be unpaused and SHALL remain paused.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.Key PauseKey {
      get { return pauseKey_; }
      set {
        pauseKey_ = value;
      }
    }

    /// <summary>Field number for the "metadata" field.</summary>
    public const int MetadataFieldNumber = 23;
    private pb::ByteString metadata_ = pb::ByteString.Empty;
    /// <summary>
    ///*
    /// Token "Metadata".
    /// &lt;p>
    /// The value, if set, MUST NOT exceed 100 bytes.&lt;br/>
    /// &lt;dl>&lt;dt>Examples&lt;/dt>
    ///   &lt;dd>hcs://1/0.0.4896575&lt;/dd>
    ///   &lt;dd>ipfs://bafkreifd7tcjjuwxxf4qkaibkj62pj4mhfuud7plwrc3pfoygt55al6syi&lt;/dd>
    /// &lt;/dl>
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString Metadata {
      get { return metadata_; }
      set {
        metadata_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "metadata_key" field.</summary>
    public const int MetadataKeyFieldNumber = 24;
    private global::Proto.Key metadataKey_;
    /// <summary>
    ///*
    /// An Hedera key for managing the token `metadata`.
    /// &lt;p>
    /// This key, if set, MAY authorize transactions to modify the
    /// `metadata` for this token.&lt;br/>
    /// If this key is not set, or is an empty `KeyList`, the `metadata`
    /// for this token SHALL NOT be modified.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.Key MetadataKey {
      get { return metadataKey_; }
      set {
        metadataKey_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as TokenCreateTransactionBody);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(TokenCreateTransactionBody other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (Symbol != other.Symbol) return false;
      if (Decimals != other.Decimals) return false;
      if (InitialSupply != other.InitialSupply) return false;
      if (!object.Equals(Treasury, other.Treasury)) return false;
      if (!object.Equals(AdminKey, other.AdminKey)) return false;
      if (!object.Equals(KycKey, other.KycKey)) return false;
      if (!object.Equals(FreezeKey, other.FreezeKey)) return false;
      if (!object.Equals(WipeKey, other.WipeKey)) return false;
      if (!object.Equals(SupplyKey, other.SupplyKey)) return false;
      if (FreezeDefault != other.FreezeDefault) return false;
      if (!object.Equals(Expiry, other.Expiry)) return false;
      if (!object.Equals(AutoRenewAccount, other.AutoRenewAccount)) return false;
      if (!object.Equals(AutoRenewPeriod, other.AutoRenewPeriod)) return false;
      if (Memo != other.Memo) return false;
      if (TokenType != other.TokenType) return false;
      if (SupplyType != other.SupplyType) return false;
      if (MaxSupply != other.MaxSupply) return false;
      if (!object.Equals(FeeScheduleKey, other.FeeScheduleKey)) return false;
      if(!customFees_.Equals(other.customFees_)) return false;
      if (!object.Equals(PauseKey, other.PauseKey)) return false;
      if (Metadata != other.Metadata) return false;
      if (!object.Equals(MetadataKey, other.MetadataKey)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (Symbol.Length != 0) hash ^= Symbol.GetHashCode();
      if (Decimals != 0) hash ^= Decimals.GetHashCode();
      if (InitialSupply != 0UL) hash ^= InitialSupply.GetHashCode();
      if (treasury_ != null) hash ^= Treasury.GetHashCode();
      if (adminKey_ != null) hash ^= AdminKey.GetHashCode();
      if (kycKey_ != null) hash ^= KycKey.GetHashCode();
      if (freezeKey_ != null) hash ^= FreezeKey.GetHashCode();
      if (wipeKey_ != null) hash ^= WipeKey.GetHashCode();
      if (supplyKey_ != null) hash ^= SupplyKey.GetHashCode();
      if (FreezeDefault != false) hash ^= FreezeDefault.GetHashCode();
      if (expiry_ != null) hash ^= Expiry.GetHashCode();
      if (autoRenewAccount_ != null) hash ^= AutoRenewAccount.GetHashCode();
      if (autoRenewPeriod_ != null) hash ^= AutoRenewPeriod.GetHashCode();
      if (Memo.Length != 0) hash ^= Memo.GetHashCode();
      if (TokenType != global::Proto.TokenType.FungibleCommon) hash ^= TokenType.GetHashCode();
      if (SupplyType != global::Proto.TokenSupplyType.Infinite) hash ^= SupplyType.GetHashCode();
      if (MaxSupply != 0L) hash ^= MaxSupply.GetHashCode();
      if (feeScheduleKey_ != null) hash ^= FeeScheduleKey.GetHashCode();
      hash ^= customFees_.GetHashCode();
      if (pauseKey_ != null) hash ^= PauseKey.GetHashCode();
      if (Metadata.Length != 0) hash ^= Metadata.GetHashCode();
      if (metadataKey_ != null) hash ^= MetadataKey.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (Symbol.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Symbol);
      }
      if (Decimals != 0) {
        output.WriteRawTag(24);
        output.WriteUInt32(Decimals);
      }
      if (InitialSupply != 0UL) {
        output.WriteRawTag(32);
        output.WriteUInt64(InitialSupply);
      }
      if (treasury_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(Treasury);
      }
      if (adminKey_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(AdminKey);
      }
      if (kycKey_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(KycKey);
      }
      if (freezeKey_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(FreezeKey);
      }
      if (wipeKey_ != null) {
        output.WriteRawTag(74);
        output.WriteMessage(WipeKey);
      }
      if (supplyKey_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(SupplyKey);
      }
      if (FreezeDefault != false) {
        output.WriteRawTag(88);
        output.WriteBool(FreezeDefault);
      }
      if (expiry_ != null) {
        output.WriteRawTag(106);
        output.WriteMessage(Expiry);
      }
      if (autoRenewAccount_ != null) {
        output.WriteRawTag(114);
        output.WriteMessage(AutoRenewAccount);
      }
      if (autoRenewPeriod_ != null) {
        output.WriteRawTag(122);
        output.WriteMessage(AutoRenewPeriod);
      }
      if (Memo.Length != 0) {
        output.WriteRawTag(130, 1);
        output.WriteString(Memo);
      }
      if (TokenType != global::Proto.TokenType.FungibleCommon) {
        output.WriteRawTag(136, 1);
        output.WriteEnum((int) TokenType);
      }
      if (SupplyType != global::Proto.TokenSupplyType.Infinite) {
        output.WriteRawTag(144, 1);
        output.WriteEnum((int) SupplyType);
      }
      if (MaxSupply != 0L) {
        output.WriteRawTag(152, 1);
        output.WriteInt64(MaxSupply);
      }
      if (feeScheduleKey_ != null) {
        output.WriteRawTag(162, 1);
        output.WriteMessage(FeeScheduleKey);
      }
      customFees_.WriteTo(output, _repeated_customFees_codec);
      if (pauseKey_ != null) {
        output.WriteRawTag(178, 1);
        output.WriteMessage(PauseKey);
      }
      if (Metadata.Length != 0) {
        output.WriteRawTag(186, 1);
        output.WriteBytes(Metadata);
      }
      if (metadataKey_ != null) {
        output.WriteRawTag(194, 1);
        output.WriteMessage(MetadataKey);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (Symbol.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Symbol);
      }
      if (Decimals != 0) {
        output.WriteRawTag(24);
        output.WriteUInt32(Decimals);
      }
      if (InitialSupply != 0UL) {
        output.WriteRawTag(32);
        output.WriteUInt64(InitialSupply);
      }
      if (treasury_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(Treasury);
      }
      if (adminKey_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(AdminKey);
      }
      if (kycKey_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(KycKey);
      }
      if (freezeKey_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(FreezeKey);
      }
      if (wipeKey_ != null) {
        output.WriteRawTag(74);
        output.WriteMessage(WipeKey);
      }
      if (supplyKey_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(SupplyKey);
      }
      if (FreezeDefault != false) {
        output.WriteRawTag(88);
        output.WriteBool(FreezeDefault);
      }
      if (expiry_ != null) {
        output.WriteRawTag(106);
        output.WriteMessage(Expiry);
      }
      if (autoRenewAccount_ != null) {
        output.WriteRawTag(114);
        output.WriteMessage(AutoRenewAccount);
      }
      if (autoRenewPeriod_ != null) {
        output.WriteRawTag(122);
        output.WriteMessage(AutoRenewPeriod);
      }
      if (Memo.Length != 0) {
        output.WriteRawTag(130, 1);
        output.WriteString(Memo);
      }
      if (TokenType != global::Proto.TokenType.FungibleCommon) {
        output.WriteRawTag(136, 1);
        output.WriteEnum((int) TokenType);
      }
      if (SupplyType != global::Proto.TokenSupplyType.Infinite) {
        output.WriteRawTag(144, 1);
        output.WriteEnum((int) SupplyType);
      }
      if (MaxSupply != 0L) {
        output.WriteRawTag(152, 1);
        output.WriteInt64(MaxSupply);
      }
      if (feeScheduleKey_ != null) {
        output.WriteRawTag(162, 1);
        output.WriteMessage(FeeScheduleKey);
      }
      customFees_.WriteTo(ref output, _repeated_customFees_codec);
      if (pauseKey_ != null) {
        output.WriteRawTag(178, 1);
        output.WriteMessage(PauseKey);
      }
      if (Metadata.Length != 0) {
        output.WriteRawTag(186, 1);
        output.WriteBytes(Metadata);
      }
      if (metadataKey_ != null) {
        output.WriteRawTag(194, 1);
        output.WriteMessage(MetadataKey);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (Symbol.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Symbol);
      }
      if (Decimals != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Decimals);
      }
      if (InitialSupply != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(InitialSupply);
      }
      if (treasury_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Treasury);
      }
      if (adminKey_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(AdminKey);
      }
      if (kycKey_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(KycKey);
      }
      if (freezeKey_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(FreezeKey);
      }
      if (wipeKey_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(WipeKey);
      }
      if (supplyKey_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SupplyKey);
      }
      if (FreezeDefault != false) {
        size += 1 + 1;
      }
      if (expiry_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Expiry);
      }
      if (autoRenewAccount_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(AutoRenewAccount);
      }
      if (autoRenewPeriod_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(AutoRenewPeriod);
      }
      if (Memo.Length != 0) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(Memo);
      }
      if (TokenType != global::Proto.TokenType.FungibleCommon) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) TokenType);
      }
      if (SupplyType != global::Proto.TokenSupplyType.Infinite) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) SupplyType);
      }
      if (MaxSupply != 0L) {
        size += 2 + pb::CodedOutputStream.ComputeInt64Size(MaxSupply);
      }
      if (feeScheduleKey_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(FeeScheduleKey);
      }
      size += customFees_.CalculateSize(_repeated_customFees_codec);
      if (pauseKey_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(PauseKey);
      }
      if (Metadata.Length != 0) {
        size += 2 + pb::CodedOutputStream.ComputeBytesSize(Metadata);
      }
      if (metadataKey_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(MetadataKey);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(TokenCreateTransactionBody other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.Symbol.Length != 0) {
        Symbol = other.Symbol;
      }
      if (other.Decimals != 0) {
        Decimals = other.Decimals;
      }
      if (other.InitialSupply != 0UL) {
        InitialSupply = other.InitialSupply;
      }
      if (other.treasury_ != null) {
        if (treasury_ == null) {
          Treasury = new global::Proto.AccountID();
        }
        Treasury.MergeFrom(other.Treasury);
      }
      if (other.adminKey_ != null) {
        if (adminKey_ == null) {
          AdminKey = new global::Proto.Key();
        }
        AdminKey.MergeFrom(other.AdminKey);
      }
      if (other.kycKey_ != null) {
        if (kycKey_ == null) {
          KycKey = new global::Proto.Key();
        }
        KycKey.MergeFrom(other.KycKey);
      }
      if (other.freezeKey_ != null) {
        if (freezeKey_ == null) {
          FreezeKey = new global::Proto.Key();
        }
        FreezeKey.MergeFrom(other.FreezeKey);
      }
      if (other.wipeKey_ != null) {
        if (wipeKey_ == null) {
          WipeKey = new global::Proto.Key();
        }
        WipeKey.MergeFrom(other.WipeKey);
      }
      if (other.supplyKey_ != null) {
        if (supplyKey_ == null) {
          SupplyKey = new global::Proto.Key();
        }
        SupplyKey.MergeFrom(other.SupplyKey);
      }
      if (other.FreezeDefault != false) {
        FreezeDefault = other.FreezeDefault;
      }
      if (other.expiry_ != null) {
        if (expiry_ == null) {
          Expiry = new global::Proto.Timestamp();
        }
        Expiry.MergeFrom(other.Expiry);
      }
      if (other.autoRenewAccount_ != null) {
        if (autoRenewAccount_ == null) {
          AutoRenewAccount = new global::Proto.AccountID();
        }
        AutoRenewAccount.MergeFrom(other.AutoRenewAccount);
      }
      if (other.autoRenewPeriod_ != null) {
        if (autoRenewPeriod_ == null) {
          AutoRenewPeriod = new global::Proto.Duration();
        }
        AutoRenewPeriod.MergeFrom(other.AutoRenewPeriod);
      }
      if (other.Memo.Length != 0) {
        Memo = other.Memo;
      }
      if (other.TokenType != global::Proto.TokenType.FungibleCommon) {
        TokenType = other.TokenType;
      }
      if (other.SupplyType != global::Proto.TokenSupplyType.Infinite) {
        SupplyType = other.SupplyType;
      }
      if (other.MaxSupply != 0L) {
        MaxSupply = other.MaxSupply;
      }
      if (other.feeScheduleKey_ != null) {
        if (feeScheduleKey_ == null) {
          FeeScheduleKey = new global::Proto.Key();
        }
        FeeScheduleKey.MergeFrom(other.FeeScheduleKey);
      }
      customFees_.Add(other.customFees_);
      if (other.pauseKey_ != null) {
        if (pauseKey_ == null) {
          PauseKey = new global::Proto.Key();
        }
        PauseKey.MergeFrom(other.PauseKey);
      }
      if (other.Metadata.Length != 0) {
        Metadata = other.Metadata;
      }
      if (other.metadataKey_ != null) {
        if (metadataKey_ == null) {
          MetadataKey = new global::Proto.Key();
        }
        MetadataKey.MergeFrom(other.MetadataKey);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            Symbol = input.ReadString();
            break;
          }
          case 24: {
            Decimals = input.ReadUInt32();
            break;
          }
          case 32: {
            InitialSupply = input.ReadUInt64();
            break;
          }
          case 42: {
            if (treasury_ == null) {
              Treasury = new global::Proto.AccountID();
            }
            input.ReadMessage(Treasury);
            break;
          }
          case 50: {
            if (adminKey_ == null) {
              AdminKey = new global::Proto.Key();
            }
            input.ReadMessage(AdminKey);
            break;
          }
          case 58: {
            if (kycKey_ == null) {
              KycKey = new global::Proto.Key();
            }
            input.ReadMessage(KycKey);
            break;
          }
          case 66: {
            if (freezeKey_ == null) {
              FreezeKey = new global::Proto.Key();
            }
            input.ReadMessage(FreezeKey);
            break;
          }
          case 74: {
            if (wipeKey_ == null) {
              WipeKey = new global::Proto.Key();
            }
            input.ReadMessage(WipeKey);
            break;
          }
          case 82: {
            if (supplyKey_ == null) {
              SupplyKey = new global::Proto.Key();
            }
            input.ReadMessage(SupplyKey);
            break;
          }
          case 88: {
            FreezeDefault = input.ReadBool();
            break;
          }
          case 106: {
            if (expiry_ == null) {
              Expiry = new global::Proto.Timestamp();
            }
            input.ReadMessage(Expiry);
            break;
          }
          case 114: {
            if (autoRenewAccount_ == null) {
              AutoRenewAccount = new global::Proto.AccountID();
            }
            input.ReadMessage(AutoRenewAccount);
            break;
          }
          case 122: {
            if (autoRenewPeriod_ == null) {
              AutoRenewPeriod = new global::Proto.Duration();
            }
            input.ReadMessage(AutoRenewPeriod);
            break;
          }
          case 130: {
            Memo = input.ReadString();
            break;
          }
          case 136: {
            TokenType = (global::Proto.TokenType) input.ReadEnum();
            break;
          }
          case 144: {
            SupplyType = (global::Proto.TokenSupplyType) input.ReadEnum();
            break;
          }
          case 152: {
            MaxSupply = input.ReadInt64();
            break;
          }
          case 162: {
            if (feeScheduleKey_ == null) {
              FeeScheduleKey = new global::Proto.Key();
            }
            input.ReadMessage(FeeScheduleKey);
            break;
          }
          case 170: {
            customFees_.AddEntriesFrom(input, _repeated_customFees_codec);
            break;
          }
          case 178: {
            if (pauseKey_ == null) {
              PauseKey = new global::Proto.Key();
            }
            input.ReadMessage(PauseKey);
            break;
          }
          case 186: {
            Metadata = input.ReadBytes();
            break;
          }
          case 194: {
            if (metadataKey_ == null) {
              MetadataKey = new global::Proto.Key();
            }
            input.ReadMessage(MetadataKey);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            Symbol = input.ReadString();
            break;
          }
          case 24: {
            Decimals = input.ReadUInt32();
            break;
          }
          case 32: {
            InitialSupply = input.ReadUInt64();
            break;
          }
          case 42: {
            if (treasury_ == null) {
              Treasury = new global::Proto.AccountID();
            }
            input.ReadMessage(Treasury);
            break;
          }
          case 50: {
            if (adminKey_ == null) {
              AdminKey = new global::Proto.Key();
            }
            input.ReadMessage(AdminKey);
            break;
          }
          case 58: {
            if (kycKey_ == null) {
              KycKey = new global::Proto.Key();
            }
            input.ReadMessage(KycKey);
            break;
          }
          case 66: {
            if (freezeKey_ == null) {
              FreezeKey = new global::Proto.Key();
            }
            input.ReadMessage(FreezeKey);
            break;
          }
          case 74: {
            if (wipeKey_ == null) {
              WipeKey = new global::Proto.Key();
            }
            input.ReadMessage(WipeKey);
            break;
          }
          case 82: {
            if (supplyKey_ == null) {
              SupplyKey = new global::Proto.Key();
            }
            input.ReadMessage(SupplyKey);
            break;
          }
          case 88: {
            FreezeDefault = input.ReadBool();
            break;
          }
          case 106: {
            if (expiry_ == null) {
              Expiry = new global::Proto.Timestamp();
            }
            input.ReadMessage(Expiry);
            break;
          }
          case 114: {
            if (autoRenewAccount_ == null) {
              AutoRenewAccount = new global::Proto.AccountID();
            }
            input.ReadMessage(AutoRenewAccount);
            break;
          }
          case 122: {
            if (autoRenewPeriod_ == null) {
              AutoRenewPeriod = new global::Proto.Duration();
            }
            input.ReadMessage(AutoRenewPeriod);
            break;
          }
          case 130: {
            Memo = input.ReadString();
            break;
          }
          case 136: {
            TokenType = (global::Proto.TokenType) input.ReadEnum();
            break;
          }
          case 144: {
            SupplyType = (global::Proto.TokenSupplyType) input.ReadEnum();
            break;
          }
          case 152: {
            MaxSupply = input.ReadInt64();
            break;
          }
          case 162: {
            if (feeScheduleKey_ == null) {
              FeeScheduleKey = new global::Proto.Key();
            }
            input.ReadMessage(FeeScheduleKey);
            break;
          }
          case 170: {
            customFees_.AddEntriesFrom(ref input, _repeated_customFees_codec);
            break;
          }
          case 178: {
            if (pauseKey_ == null) {
              PauseKey = new global::Proto.Key();
            }
            input.ReadMessage(PauseKey);
            break;
          }
          case 186: {
            Metadata = input.ReadBytes();
            break;
          }
          case 194: {
            if (metadataKey_ == null) {
              MetadataKey = new global::Proto.Key();
            }
            input.ReadMessage(MetadataKey);
            break;
          }
        }
      }
    }
    #endif

  }

  #endregion

}

#endregion Designer generated code
