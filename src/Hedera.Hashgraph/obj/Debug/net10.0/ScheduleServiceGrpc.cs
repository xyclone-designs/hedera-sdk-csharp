// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: schedule_service.proto
// </auto-generated>
// Original file comments:
// *
// # Schedule Service
// gRPC service definitions for the Schedule Service.
//
// ### Keywords
// The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
// "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
// document are to be interpreted as described in
// [RFC2119](https://www.ietf.org/rfc/rfc2119) and clarified in
// [RFC8174](https://www.ietf.org/rfc/rfc8174).
#pragma warning disable 0414, 1591, 8981, 0612
#region Designer generated code

using grpc = global::Grpc.Core;

namespace Hedera.Hashgraph.Proto {
  /// <summary>
  ///*
  /// Transactions and queries for the Schedule Service.&lt;br/>
  /// The Schedule Service enables transactions to be submitted without all
  /// required signatures and offers a `scheduleSign` transaction to provide
  /// additional signatures independently after the schedule is created. The
  /// scheduled transaction may be executed immediately when all required
  /// signatures are present, or at expiration if "long term" schedules
  /// are enabled in network configuration.
  ///
  /// ### Execution
  /// Scheduled transactions SHALL be executed under the following conditions.
  /// 1. If "long term" schedules are enabled and `wait_for_expiry` is set for
  ///    that schedule then the transaction SHALL NOT be executed before the
  ///    network consensus time matches or exceeds the `expiration_time` field
  ///    for that schedule.
  /// 1. If "long term" schedules are enabled and `wait_for_expiry` is _not_ set
  ///    for that schedule, then the transaction SHALL be executed when all
  ///    signatures required by the scheduled transaction are active for that
  ///    schedule. This MAY be immediately after the `scheduleCreate` or a
  ///    subsequent `scheduleSign` transaction, or MAY be at expiration if
  ///    the signature requirements are met at that time.
  /// 1. If "long term" schedules are _disabled_, then the scheduled transaction
  ///    SHALL be executed immediately after all signature requirements for the
  ///    scheduled transaction are met during the `scheduleCreate` or a subsequent
  ///    `scheduleSign` transaction. The scheduled transaction SHALL NOT be
  ///    on expiration when "long term" schedules are disabled.
  ///
  /// A schedule SHALL remain in state and MAY be queried with a `getScheduleInfo`
  /// transaction after execution, until the schedule expires.&lt;br/>
  /// When network consensus time matches or exceeds the `expiration_time` for
  /// a schedule, that schedule SHALL be removed from state, whether it has
  /// executed or not.&lt;br/>
  /// If "long term" schedules are _disabled_, the maximum expiration time SHALL
  /// be the consensus time of the `scheduleCreate` transaction extended by
  /// the network configuration value `ledger.scheduleTxExpiryTimeSecs`.
  ///
  /// ### Block Stream Effects
  /// When a scheduled transaction is executed, the timestamp in the transaction
  /// identifier for that transaction SHALL be 1 nanosecond after the consensus
  /// timestamp for the transaction that resulted in its execution. If execution
  /// occurred at expiration, that transaction may be almost any transaction,
  /// including another scheduled transaction that executed at expiration.&lt;br/>
  /// The transaction identifier for a scheduled transaction that is executed
  /// SHALL have the `scheduled` flag set and SHALL inherit the `accountID` and
  /// `transactionValidStart` values from the `scheduleCreate` that created the
  /// schedule.&lt;br/>
  /// The `scheduleRef` property of the record for a scheduled transaction SHALL
  /// be populated with the schedule identifier of the schedule that executed.
  /// </summary>
  public static partial class ScheduleService
  {
    static readonly string __ServiceName = "proto.ScheduleService";

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static void __Helper_SerializeMessage(global::Google.Protobuf.IMessage message, grpc::SerializationContext context)
    {
      #if !GRPC_DISABLE_PROTOBUF_BUFFER_SERIALIZATION
      if (message is global::Google.Protobuf.IBufferMessage)
      {
        context.SetPayloadLength(message.CalculateSize());
        global::Google.Protobuf.MessageExtensions.WriteTo(message, context.GetBufferWriter());
        context.Complete();
        return;
      }
      #endif
      context.Complete(global::Google.Protobuf.MessageExtensions.ToByteArray(message));
    }

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static class __Helper_MessageCache<T>
    {
      public static readonly bool IsBufferMessage = global::System.Reflection.IntrospectionExtensions.GetTypeInfo(typeof(global::Google.Protobuf.IBufferMessage)).IsAssignableFrom(typeof(T));
    }

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static T __Helper_DeserializeMessage<T>(grpc::DeserializationContext context, global::Google.Protobuf.MessageParser<T> parser) where T : global::Google.Protobuf.IMessage<T>
    {
      #if !GRPC_DISABLE_PROTOBUF_BUFFER_SERIALIZATION
      if (__Helper_MessageCache<T>.IsBufferMessage)
      {
        return parser.ParseFrom(context.PayloadAsReadOnlySequence());
      }
      #endif
      return parser.ParseFrom(context.PayloadAsNewBuffer());
    }

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::Hedera.Hashgraph.Proto.Transaction> __Marshaller_proto_Transaction = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Hedera.Hashgraph.Proto.Transaction.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::Hedera.Hashgraph.Proto.TransactionResponse> __Marshaller_proto_TransactionResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Hedera.Hashgraph.Proto.TransactionResponse.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::Hedera.Hashgraph.Proto.Query> __Marshaller_proto_Query = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Hedera.Hashgraph.Proto.Query.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::Hedera.Hashgraph.Proto.Response> __Marshaller_proto_Response = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Hedera.Hashgraph.Proto.Response.Parser));

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse> __Method_createSchedule = new grpc::Method<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "createSchedule",
        __Marshaller_proto_Transaction,
        __Marshaller_proto_TransactionResponse);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse> __Method_signSchedule = new grpc::Method<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "signSchedule",
        __Marshaller_proto_Transaction,
        __Marshaller_proto_TransactionResponse);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse> __Method_deleteSchedule = new grpc::Method<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "deleteSchedule",
        __Marshaller_proto_Transaction,
        __Marshaller_proto_TransactionResponse);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::Hedera.Hashgraph.Proto.Query, global::Hedera.Hashgraph.Proto.Response> __Method_getScheduleInfo = new grpc::Method<global::Hedera.Hashgraph.Proto.Query, global::Hedera.Hashgraph.Proto.Response>(
        grpc::MethodType.Unary,
        __ServiceName,
        "getScheduleInfo",
        __Marshaller_proto_Query,
        __Marshaller_proto_Response);

    /// <summary>Service descriptor</summary>
    public static global::Google.Protobuf.Reflection.ServiceDescriptor Descriptor
    {
      get { return global::Hedera.Hashgraph.Proto.ScheduleServiceReflection.Descriptor.Services[0]; }
    }

    /// <summary>Base class for server-side implementations of ScheduleService</summary>
    [grpc::BindServiceMethod(typeof(ScheduleService), "BindService")]
    public abstract partial class ScheduleServiceBase
    {
      /// <summary>
      ///*
      /// Create a new Schedule.
      /// &lt;p>
      /// If all signature requirements are met with this transaction, the
      /// scheduled transaction MAY execute immediately.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::Hedera.Hashgraph.Proto.TransactionResponse> createSchedule(global::Hedera.Hashgraph.Proto.Transaction request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///*
      /// Add signatures to an existing schedule.
      /// &lt;p>
      /// Signatures on this transaction SHALL be added to the set of active
      /// signatures on the schedule, and MAY result in execution of the
      /// scheduled transaction if all signature requirements are met.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::Hedera.Hashgraph.Proto.TransactionResponse> signSchedule(global::Hedera.Hashgraph.Proto.Transaction request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///*
      /// Mark an existing schedule deleted.
      /// &lt;p>
      /// Once deleted a schedule SHALL NOT be executed and any subsequent
      /// `scheduleSign` transaction SHALL fail.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::Hedera.Hashgraph.Proto.TransactionResponse> deleteSchedule(global::Hedera.Hashgraph.Proto.Transaction request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///*
      /// Retrieve the metadata for a schedule.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::Hedera.Hashgraph.Proto.Response> getScheduleInfo(global::Hedera.Hashgraph.Proto.Query request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

    }

    /// <summary>Client for ScheduleService</summary>
    public partial class ScheduleServiceClient : grpc::ClientBase<ScheduleServiceClient>
    {
      /// <summary>Creates a new client for ScheduleService</summary>
      /// <param name="channel">The channel to use to make remote calls.</param>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public ScheduleServiceClient(grpc::ChannelBase channel) : base(channel)
      {
      }
      /// <summary>Creates a new client for ScheduleService that uses a custom <c>CallInvoker</c>.</summary>
      /// <param name="callInvoker">The callInvoker to use to make remote calls.</param>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public ScheduleServiceClient(grpc::CallInvoker callInvoker) : base(callInvoker)
      {
      }
      /// <summary>Protected parameterless constructor to allow creation of test doubles.</summary>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      protected ScheduleServiceClient() : base()
      {
      }
      /// <summary>Protected constructor to allow creation of configured clients.</summary>
      /// <param name="configuration">The client configuration.</param>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      protected ScheduleServiceClient(ClientBaseConfiguration configuration) : base(configuration)
      {
      }

      /// <summary>
      ///*
      /// Create a new Schedule.
      /// &lt;p>
      /// If all signature requirements are met with this transaction, the
      /// scheduled transaction MAY execute immediately.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Hedera.Hashgraph.Proto.TransactionResponse createSchedule(global::Hedera.Hashgraph.Proto.Transaction request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return createSchedule(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      /// Create a new Schedule.
      /// &lt;p>
      /// If all signature requirements are met with this transaction, the
      /// scheduled transaction MAY execute immediately.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Hedera.Hashgraph.Proto.TransactionResponse createSchedule(global::Hedera.Hashgraph.Proto.Transaction request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_createSchedule, null, options, request);
      }
      /// <summary>
      ///*
      /// Create a new Schedule.
      /// &lt;p>
      /// If all signature requirements are met with this transaction, the
      /// scheduled transaction MAY execute immediately.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Hedera.Hashgraph.Proto.TransactionResponse> createScheduleAsync(global::Hedera.Hashgraph.Proto.Transaction request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return createScheduleAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      /// Create a new Schedule.
      /// &lt;p>
      /// If all signature requirements are met with this transaction, the
      /// scheduled transaction MAY execute immediately.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Hedera.Hashgraph.Proto.TransactionResponse> createScheduleAsync(global::Hedera.Hashgraph.Proto.Transaction request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_createSchedule, null, options, request);
      }
      /// <summary>
      ///*
      /// Add signatures to an existing schedule.
      /// &lt;p>
      /// Signatures on this transaction SHALL be added to the set of active
      /// signatures on the schedule, and MAY result in execution of the
      /// scheduled transaction if all signature requirements are met.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Hedera.Hashgraph.Proto.TransactionResponse signSchedule(global::Hedera.Hashgraph.Proto.Transaction request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return signSchedule(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      /// Add signatures to an existing schedule.
      /// &lt;p>
      /// Signatures on this transaction SHALL be added to the set of active
      /// signatures on the schedule, and MAY result in execution of the
      /// scheduled transaction if all signature requirements are met.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Hedera.Hashgraph.Proto.TransactionResponse signSchedule(global::Hedera.Hashgraph.Proto.Transaction request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_signSchedule, null, options, request);
      }
      /// <summary>
      ///*
      /// Add signatures to an existing schedule.
      /// &lt;p>
      /// Signatures on this transaction SHALL be added to the set of active
      /// signatures on the schedule, and MAY result in execution of the
      /// scheduled transaction if all signature requirements are met.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Hedera.Hashgraph.Proto.TransactionResponse> signScheduleAsync(global::Hedera.Hashgraph.Proto.Transaction request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return signScheduleAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      /// Add signatures to an existing schedule.
      /// &lt;p>
      /// Signatures on this transaction SHALL be added to the set of active
      /// signatures on the schedule, and MAY result in execution of the
      /// scheduled transaction if all signature requirements are met.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Hedera.Hashgraph.Proto.TransactionResponse> signScheduleAsync(global::Hedera.Hashgraph.Proto.Transaction request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_signSchedule, null, options, request);
      }
      /// <summary>
      ///*
      /// Mark an existing schedule deleted.
      /// &lt;p>
      /// Once deleted a schedule SHALL NOT be executed and any subsequent
      /// `scheduleSign` transaction SHALL fail.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Hedera.Hashgraph.Proto.TransactionResponse deleteSchedule(global::Hedera.Hashgraph.Proto.Transaction request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return deleteSchedule(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      /// Mark an existing schedule deleted.
      /// &lt;p>
      /// Once deleted a schedule SHALL NOT be executed and any subsequent
      /// `scheduleSign` transaction SHALL fail.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Hedera.Hashgraph.Proto.TransactionResponse deleteSchedule(global::Hedera.Hashgraph.Proto.Transaction request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_deleteSchedule, null, options, request);
      }
      /// <summary>
      ///*
      /// Mark an existing schedule deleted.
      /// &lt;p>
      /// Once deleted a schedule SHALL NOT be executed and any subsequent
      /// `scheduleSign` transaction SHALL fail.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Hedera.Hashgraph.Proto.TransactionResponse> deleteScheduleAsync(global::Hedera.Hashgraph.Proto.Transaction request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return deleteScheduleAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      /// Mark an existing schedule deleted.
      /// &lt;p>
      /// Once deleted a schedule SHALL NOT be executed and any subsequent
      /// `scheduleSign` transaction SHALL fail.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Hedera.Hashgraph.Proto.TransactionResponse> deleteScheduleAsync(global::Hedera.Hashgraph.Proto.Transaction request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_deleteSchedule, null, options, request);
      }
      /// <summary>
      ///*
      /// Retrieve the metadata for a schedule.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Hedera.Hashgraph.Proto.Response getScheduleInfo(global::Hedera.Hashgraph.Proto.Query request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return getScheduleInfo(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      /// Retrieve the metadata for a schedule.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::Hedera.Hashgraph.Proto.Response getScheduleInfo(global::Hedera.Hashgraph.Proto.Query request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_getScheduleInfo, null, options, request);
      }
      /// <summary>
      ///*
      /// Retrieve the metadata for a schedule.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Hedera.Hashgraph.Proto.Response> getScheduleInfoAsync(global::Hedera.Hashgraph.Proto.Query request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return getScheduleInfoAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      /// Retrieve the metadata for a schedule.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::Hedera.Hashgraph.Proto.Response> getScheduleInfoAsync(global::Hedera.Hashgraph.Proto.Query request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_getScheduleInfo, null, options, request);
      }
      /// <summary>Creates a new instance of client from given <c>ClientBaseConfiguration</c>.</summary>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      protected override ScheduleServiceClient NewInstance(ClientBaseConfiguration configuration)
      {
        return new ScheduleServiceClient(configuration);
      }
    }

    /// <summary>Creates service definition that can be registered with a server</summary>
    /// <param name="serviceImpl">An object implementing the server-side handling logic.</param>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public static grpc::ServerServiceDefinition BindService(ScheduleServiceBase serviceImpl)
    {
      return grpc::ServerServiceDefinition.CreateBuilder()
          .AddMethod(__Method_createSchedule, serviceImpl.createSchedule)
          .AddMethod(__Method_signSchedule, serviceImpl.signSchedule)
          .AddMethod(__Method_deleteSchedule, serviceImpl.deleteSchedule)
          .AddMethod(__Method_getScheduleInfo, serviceImpl.getScheduleInfo).Build();
    }

    /// <summary>Register service method with a service binder with or without implementation. Useful when customizing the service binding logic.
    /// Note: this method is part of an experimental API that can change or be removed without any prior notice.</summary>
    /// <param name="serviceBinder">Service methods will be bound by calling <c>AddMethod</c> on this object.</param>
    /// <param name="serviceImpl">An object implementing the server-side handling logic.</param>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public static void BindService(grpc::ServiceBinderBase serviceBinder, ScheduleServiceBase serviceImpl)
    {
      serviceBinder.AddMethod(__Method_createSchedule, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse>(serviceImpl.createSchedule));
      serviceBinder.AddMethod(__Method_signSchedule, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse>(serviceImpl.signSchedule));
      serviceBinder.AddMethod(__Method_deleteSchedule, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::Hedera.Hashgraph.Proto.Transaction, global::Hedera.Hashgraph.Proto.TransactionResponse>(serviceImpl.deleteSchedule));
      serviceBinder.AddMethod(__Method_getScheduleInfo, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::Hedera.Hashgraph.Proto.Query, global::Hedera.Hashgraph.Proto.Response>(serviceImpl.getScheduleInfo));
    }

  }
}
#endregion
