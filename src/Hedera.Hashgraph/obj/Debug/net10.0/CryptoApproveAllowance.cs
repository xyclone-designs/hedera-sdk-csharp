// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: crypto_approve_allowance.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021, 8981
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Hedera.Hashgraph.Proto {

  /// <summary>Holder for reflection information generated from crypto_approve_allowance.proto</summary>
  public static partial class CryptoApproveAllowanceReflection {

    #region Descriptor
    /// <summary>File descriptor for crypto_approve_allowance.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static CryptoApproveAllowanceReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "Ch5jcnlwdG9fYXBwcm92ZV9hbGxvd2FuY2UucHJvdG8SBXByb3RvGhFiYXNp",
            "Y190eXBlcy5wcm90bxoeZ29vZ2xlL3Byb3RvYnVmL3dyYXBwZXJzLnByb3Rv",
            "IrUBCiVDcnlwdG9BcHByb3ZlQWxsb3dhbmNlVHJhbnNhY3Rpb25Cb2R5EjAK",
            "EGNyeXB0b0FsbG93YW5jZXMYASADKAsyFi5wcm90by5DcnlwdG9BbGxvd2Fu",
            "Y2USKgoNbmZ0QWxsb3dhbmNlcxgCIAMoCzITLnByb3RvLk5mdEFsbG93YW5j",
            "ZRIuCg90b2tlbkFsbG93YW5jZXMYAyADKAsyFS5wcm90by5Ub2tlbkFsbG93",
            "YW5jZSJlCg9DcnlwdG9BbGxvd2FuY2USHwoFb3duZXIYASABKAsyEC5wcm90",
            "by5BY2NvdW50SUQSIQoHc3BlbmRlchgCIAEoCzIQLnByb3RvLkFjY291bnRJ",
            "RBIOCgZhbW91bnQYAyABKAMi7wEKDE5mdEFsbG93YW5jZRIfCgd0b2tlbklk",
            "GAEgASgLMg4ucHJvdG8uVG9rZW5JRBIfCgVvd25lchgCIAEoCzIQLnByb3Rv",
            "LkFjY291bnRJRBIhCgdzcGVuZGVyGAMgASgLMhAucHJvdG8uQWNjb3VudElE",
            "EhYKDnNlcmlhbF9udW1iZXJzGAQgAygDEjQKEGFwcHJvdmVkX2Zvcl9hbGwY",
            "BSABKAsyGi5nb29nbGUucHJvdG9idWYuQm9vbFZhbHVlEiwKEmRlbGVnYXRp",
            "bmdfc3BlbmRlchgGIAEoCzIQLnByb3RvLkFjY291bnRJRCKFAQoOVG9rZW5B",
            "bGxvd2FuY2USHwoHdG9rZW5JZBgBIAEoCzIOLnByb3RvLlRva2VuSUQSHwoF",
            "b3duZXIYAiABKAsyEC5wcm90by5BY2NvdW50SUQSIQoHc3BlbmRlchgDIAEo",
            "CzIQLnByb3RvLkFjY291bnRJRBIOCgZhbW91bnQYBCABKANCOQoeY29tLmhl",
            "ZGVyYS5oYXNoZ3JhcGguc2RrLnByb3RvqgIWSGVkZXJhLkhhc2hncmFwaC5Q",
            "cm90b2IGcHJvdG8z"));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Hedera.Hashgraph.Proto.BasicTypesReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.WrappersReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Hedera.Hashgraph.Proto.CryptoApproveAllowanceTransactionBody), global::Hedera.Hashgraph.Proto.CryptoApproveAllowanceTransactionBody.Parser, new[]{ "CryptoAllowances", "NftAllowances", "TokenAllowances" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Hedera.Hashgraph.Proto.CryptoAllowance), global::Hedera.Hashgraph.Proto.CryptoAllowance.Parser, new[]{ "Owner", "Spender", "Amount" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Hedera.Hashgraph.Proto.NftAllowance), global::Hedera.Hashgraph.Proto.NftAllowance.Parser, new[]{ "TokenId", "Owner", "Spender", "SerialNumbers", "ApprovedForAll", "DelegatingSpender" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Hedera.Hashgraph.Proto.TokenAllowance), global::Hedera.Hashgraph.Proto.TokenAllowance.Parser, new[]{ "TokenId", "Owner", "Spender", "Amount" }, null, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  ///*
  /// Create ("Approve") allowances for one account to transfer tokens owned
  /// by a different account.&lt;br/>
  /// An allowance permits a "spender" account to independently transfer tokens
  /// owned by a separate "owner" account. Each such allowance permits spending
  /// any amount, up to a specified limit, for fungible/common tokens; a single
  /// specified non-fungible/unique token, or all non-fungible/unique tokens
  /// of a particular token type held by the "owner" account.
  ///
  /// If the "owner" account is not specified for any allowance in this
  /// transaction (the `owner` field is not set), the `payer` account for this
  /// transaction SHALL be owner for that allowance.&lt;br/>
  /// Each `owner` account specified in any allowance approved in this
  /// transaction MUST sign this transaction.&lt;br/>
  /// If the `amount` field for any fungible/common allowance in this
  /// transaction is `0`, then that allowance SHOULD match an existing,
  /// previously approved, allowance which SHALL be removed.&lt;br/>
  /// There are three lists in this message. Each list MAY be empty, but
  /// _at least one_ list MUST contain _at least one_ entry.
  ///
  /// Example for the `payer` rule.&lt;br/>
  ///  - Given an account `0.0.X` that pays for this transaction, and owner
  ///    is not specified in an allowance of `200` HBAR to spender account
  ///    `0.0.Y`. At consensus the spender account `0.0.Y` will have a new
  ///    allowance to spend `200` HBAR from the balance of account `0.0.X`.
  ///
  /// ### Block Stream Effects
  /// None
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class CryptoApproveAllowanceTransactionBody : pb::IMessage<CryptoApproveAllowanceTransactionBody>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<CryptoApproveAllowanceTransactionBody> _parser = new pb::MessageParser<CryptoApproveAllowanceTransactionBody>(() => new CryptoApproveAllowanceTransactionBody());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<CryptoApproveAllowanceTransactionBody> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Hedera.Hashgraph.Proto.CryptoApproveAllowanceReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public CryptoApproveAllowanceTransactionBody() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public CryptoApproveAllowanceTransactionBody(CryptoApproveAllowanceTransactionBody other) : this() {
      cryptoAllowances_ = other.cryptoAllowances_.Clone();
      nftAllowances_ = other.nftAllowances_.Clone();
      tokenAllowances_ = other.tokenAllowances_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public CryptoApproveAllowanceTransactionBody Clone() {
      return new CryptoApproveAllowanceTransactionBody(this);
    }

    /// <summary>Field number for the "cryptoAllowances" field.</summary>
    public const int CryptoAllowancesFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Hedera.Hashgraph.Proto.CryptoAllowance> _repeated_cryptoAllowances_codec
        = pb::FieldCodec.ForMessage(10, global::Hedera.Hashgraph.Proto.CryptoAllowance.Parser);
    private readonly pbc::RepeatedField<global::Hedera.Hashgraph.Proto.CryptoAllowance> cryptoAllowances_ = new pbc::RepeatedField<global::Hedera.Hashgraph.Proto.CryptoAllowance>();
    /// <summary>
    ///*
    /// List of hbar allowances approved by the account owner.
    /// &lt;p>
    /// This list MAY be empty, provided at least one other list is
    /// not empty.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Hedera.Hashgraph.Proto.CryptoAllowance> CryptoAllowances {
      get { return cryptoAllowances_; }
    }

    /// <summary>Field number for the "nftAllowances" field.</summary>
    public const int NftAllowancesFieldNumber = 2;
    private static readonly pb::FieldCodec<global::Hedera.Hashgraph.Proto.NftAllowance> _repeated_nftAllowances_codec
        = pb::FieldCodec.ForMessage(18, global::Hedera.Hashgraph.Proto.NftAllowance.Parser);
    private readonly pbc::RepeatedField<global::Hedera.Hashgraph.Proto.NftAllowance> nftAllowances_ = new pbc::RepeatedField<global::Hedera.Hashgraph.Proto.NftAllowance>();
    /// <summary>
    ///*
    /// List of non-fungible token allowances approved by the account owner.
    /// &lt;p>
    /// This list MAY be empty, provided at least one other list is
    /// not empty.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Hedera.Hashgraph.Proto.NftAllowance> NftAllowances {
      get { return nftAllowances_; }
    }

    /// <summary>Field number for the "tokenAllowances" field.</summary>
    public const int TokenAllowancesFieldNumber = 3;
    private static readonly pb::FieldCodec<global::Hedera.Hashgraph.Proto.TokenAllowance> _repeated_tokenAllowances_codec
        = pb::FieldCodec.ForMessage(26, global::Hedera.Hashgraph.Proto.TokenAllowance.Parser);
    private readonly pbc::RepeatedField<global::Hedera.Hashgraph.Proto.TokenAllowance> tokenAllowances_ = new pbc::RepeatedField<global::Hedera.Hashgraph.Proto.TokenAllowance>();
    /// <summary>
    ///*
    /// List of fungible token allowances approved by the account owner.
    /// &lt;p>
    /// This list MAY be empty, provided at least one other list is
    /// not empty.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Hedera.Hashgraph.Proto.TokenAllowance> TokenAllowances {
      get { return tokenAllowances_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as CryptoApproveAllowanceTransactionBody);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(CryptoApproveAllowanceTransactionBody other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!cryptoAllowances_.Equals(other.cryptoAllowances_)) return false;
      if(!nftAllowances_.Equals(other.nftAllowances_)) return false;
      if(!tokenAllowances_.Equals(other.tokenAllowances_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= cryptoAllowances_.GetHashCode();
      hash ^= nftAllowances_.GetHashCode();
      hash ^= tokenAllowances_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      cryptoAllowances_.WriteTo(output, _repeated_cryptoAllowances_codec);
      nftAllowances_.WriteTo(output, _repeated_nftAllowances_codec);
      tokenAllowances_.WriteTo(output, _repeated_tokenAllowances_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      cryptoAllowances_.WriteTo(ref output, _repeated_cryptoAllowances_codec);
      nftAllowances_.WriteTo(ref output, _repeated_nftAllowances_codec);
      tokenAllowances_.WriteTo(ref output, _repeated_tokenAllowances_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += cryptoAllowances_.CalculateSize(_repeated_cryptoAllowances_codec);
      size += nftAllowances_.CalculateSize(_repeated_nftAllowances_codec);
      size += tokenAllowances_.CalculateSize(_repeated_tokenAllowances_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(CryptoApproveAllowanceTransactionBody other) {
      if (other == null) {
        return;
      }
      cryptoAllowances_.Add(other.cryptoAllowances_);
      nftAllowances_.Add(other.nftAllowances_);
      tokenAllowances_.Add(other.tokenAllowances_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            cryptoAllowances_.AddEntriesFrom(input, _repeated_cryptoAllowances_codec);
            break;
          }
          case 18: {
            nftAllowances_.AddEntriesFrom(input, _repeated_nftAllowances_codec);
            break;
          }
          case 26: {
            tokenAllowances_.AddEntriesFrom(input, _repeated_tokenAllowances_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            cryptoAllowances_.AddEntriesFrom(ref input, _repeated_cryptoAllowances_codec);
            break;
          }
          case 18: {
            nftAllowances_.AddEntriesFrom(ref input, _repeated_nftAllowances_codec);
            break;
          }
          case 26: {
            tokenAllowances_.AddEntriesFrom(ref input, _repeated_tokenAllowances_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// An approved allowance of hbar transfers.
  /// This message specifies one allowance for a single, unique, combination
  /// of owner, spender, and amount.
  ///
  /// If `owner` is not set, the effective `owner` SHALL be the `payer` for the
  /// enclosing transaction.&lt;br/>
  /// The `spender` MUST be specified and MUST be a valid account.&lt;br/>
  /// The `amount` MUST be a whole number, and SHOULD be greater than `0` unless
  /// this allowance is intended to _remove_ a previously approved allowance.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class CryptoAllowance : pb::IMessage<CryptoAllowance>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<CryptoAllowance> _parser = new pb::MessageParser<CryptoAllowance>(() => new CryptoAllowance());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<CryptoAllowance> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Hedera.Hashgraph.Proto.CryptoApproveAllowanceReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public CryptoAllowance() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public CryptoAllowance(CryptoAllowance other) : this() {
      owner_ = other.owner_ != null ? other.owner_.Clone() : null;
      spender_ = other.spender_ != null ? other.spender_.Clone() : null;
      amount_ = other.amount_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public CryptoAllowance Clone() {
      return new CryptoAllowance(this);
    }

    /// <summary>Field number for the "owner" field.</summary>
    public const int OwnerFieldNumber = 1;
    private global::Hedera.Hashgraph.Proto.AccountID owner_;
    /// <summary>
    ///*
    /// An owner account identifier.&lt;br/>
    /// This is the account identifier of the account granting an allowance
    /// for the `spender` to transfer tokens held by this account.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Hedera.Hashgraph.Proto.AccountID Owner {
      get { return owner_; }
      set {
        owner_ = value;
      }
    }

    /// <summary>Field number for the "spender" field.</summary>
    public const int SpenderFieldNumber = 2;
    private global::Hedera.Hashgraph.Proto.AccountID spender_;
    /// <summary>
    ///*
    /// A spender account identifier.&lt;br/>
    /// This is the account identifier of the account permitted to transfer
    /// tokens held by the `owner`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Hedera.Hashgraph.Proto.AccountID Spender {
      get { return spender_; }
      set {
        spender_ = value;
      }
    }

    /// <summary>Field number for the "amount" field.</summary>
    public const int AmountFieldNumber = 3;
    private long amount_;
    /// <summary>
    ///*
    /// An amount of tinybar (10&lt;sup>-8&lt;/sup> HBAR).&lt;br/>
    /// This is the amount of HBAR held by the `owner` that the
    /// `spender` is permitted to transfer.
    /// &lt;p>
    /// This value MUST be a whole number.&lt;br/>
    /// This value MUST be greater than 0 to create a new allowance.&lt;br/>
    /// This value MAY be exactly `0` to _remove_ an existing allowance.&lt;br/>
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long Amount {
      get { return amount_; }
      set {
        amount_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as CryptoAllowance);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(CryptoAllowance other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Owner, other.Owner)) return false;
      if (!object.Equals(Spender, other.Spender)) return false;
      if (Amount != other.Amount) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (owner_ != null) hash ^= Owner.GetHashCode();
      if (spender_ != null) hash ^= Spender.GetHashCode();
      if (Amount != 0L) hash ^= Amount.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (owner_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Owner);
      }
      if (spender_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Spender);
      }
      if (Amount != 0L) {
        output.WriteRawTag(24);
        output.WriteInt64(Amount);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (owner_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Owner);
      }
      if (spender_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Spender);
      }
      if (Amount != 0L) {
        output.WriteRawTag(24);
        output.WriteInt64(Amount);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (owner_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Owner);
      }
      if (spender_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Spender);
      }
      if (Amount != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(Amount);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(CryptoAllowance other) {
      if (other == null) {
        return;
      }
      if (other.owner_ != null) {
        if (owner_ == null) {
          Owner = new global::Hedera.Hashgraph.Proto.AccountID();
        }
        Owner.MergeFrom(other.Owner);
      }
      if (other.spender_ != null) {
        if (spender_ == null) {
          Spender = new global::Hedera.Hashgraph.Proto.AccountID();
        }
        Spender.MergeFrom(other.Spender);
      }
      if (other.Amount != 0L) {
        Amount = other.Amount;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (owner_ == null) {
              Owner = new global::Hedera.Hashgraph.Proto.AccountID();
            }
            input.ReadMessage(Owner);
            break;
          }
          case 18: {
            if (spender_ == null) {
              Spender = new global::Hedera.Hashgraph.Proto.AccountID();
            }
            input.ReadMessage(Spender);
            break;
          }
          case 24: {
            Amount = input.ReadInt64();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (owner_ == null) {
              Owner = new global::Hedera.Hashgraph.Proto.AccountID();
            }
            input.ReadMessage(Owner);
            break;
          }
          case 18: {
            if (spender_ == null) {
              Spender = new global::Hedera.Hashgraph.Proto.AccountID();
            }
            input.ReadMessage(Spender);
            break;
          }
          case 24: {
            Amount = input.ReadInt64();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// An approved allowance of non-fungible tokens.&lt;br/>
  /// This type of allowance may permit transfers for one or more individual
  /// unique tokens, or may permit transfers for all unique tokens of the
  /// specified type.
  ///
  /// If `owner` is not set, the effective `owner` SHALL be the `payer` for the
  /// enclosing transaction.&lt;br/>
  /// The `spender` MUST be specified and MUST be a valid account.&lt;br/>
  /// If `approve_for_all` is set, then `serial_numbers` SHOULD be empty
  /// and SHALL be ignored.
  /// If `approve_for_all` is unset, then `serial_numbers` MUST NOT be empty.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class NftAllowance : pb::IMessage<NftAllowance>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<NftAllowance> _parser = new pb::MessageParser<NftAllowance>(() => new NftAllowance());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<NftAllowance> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Hedera.Hashgraph.Proto.CryptoApproveAllowanceReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NftAllowance() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NftAllowance(NftAllowance other) : this() {
      tokenId_ = other.tokenId_ != null ? other.tokenId_.Clone() : null;
      owner_ = other.owner_ != null ? other.owner_.Clone() : null;
      spender_ = other.spender_ != null ? other.spender_.Clone() : null;
      serialNumbers_ = other.serialNumbers_.Clone();
      ApprovedForAll = other.ApprovedForAll;
      delegatingSpender_ = other.delegatingSpender_ != null ? other.delegatingSpender_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NftAllowance Clone() {
      return new NftAllowance(this);
    }

    /// <summary>Field number for the "tokenId" field.</summary>
    public const int TokenIdFieldNumber = 1;
    private global::Hedera.Hashgraph.Proto.TokenID tokenId_;
    /// <summary>
    ///*
    /// A token identifier.&lt;br/>
    /// This identifies the type of token the `spender` is permitted to
    /// transfer from the `owner`.
    /// &lt;p>
    /// The identified token type MUST be a non-fungible/unique token.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Hedera.Hashgraph.Proto.TokenID TokenId {
      get { return tokenId_; }
      set {
        tokenId_ = value;
      }
    }

    /// <summary>Field number for the "owner" field.</summary>
    public const int OwnerFieldNumber = 2;
    private global::Hedera.Hashgraph.Proto.AccountID owner_;
    /// <summary>
    ///*
    /// An owner account identifier.&lt;br/>
    /// This is the account identifier of the account granting an allowance
    /// for the `spender` to transfer tokens held by this account.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Hedera.Hashgraph.Proto.AccountID Owner {
      get { return owner_; }
      set {
        owner_ = value;
      }
    }

    /// <summary>Field number for the "spender" field.</summary>
    public const int SpenderFieldNumber = 3;
    private global::Hedera.Hashgraph.Proto.AccountID spender_;
    /// <summary>
    ///*
    /// A spender account identifier.&lt;br/>
    /// This is the account identifier of the account permitted to transfer
    /// tokens held by the `owner`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Hedera.Hashgraph.Proto.AccountID Spender {
      get { return spender_; }
      set {
        spender_ = value;
      }
    }

    /// <summary>Field number for the "serial_numbers" field.</summary>
    public const int SerialNumbersFieldNumber = 4;
    private static readonly pb::FieldCodec<long> _repeated_serialNumbers_codec
        = pb::FieldCodec.ForInt64(34);
    private readonly pbc::RepeatedField<long> serialNumbers_ = new pbc::RepeatedField<long>();
    /// <summary>
    ///*
    /// A list of token serial numbers.&lt;br/>
    /// The list of serial numbers that the spender is permitted to transfer.
    /// &lt;p>
    /// The `owner` MUST currently hold each token identified in this list.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<long> SerialNumbers {
      get { return serialNumbers_; }
    }

    /// <summary>Field number for the "approved_for_all" field.</summary>
    public const int ApprovedForAllFieldNumber = 5;
    private static readonly pb::FieldCodec<bool?> _single_approvedForAll_codec = pb::FieldCodec.ForStructWrapper<bool>(42);
    private bool? approvedForAll_;
    /// <summary>
    ///*
    /// A flag indicating this allowance applies to all tokens of the
    /// specified (non-fungible/unique) type.
    /// &lt;p>
    /// If true, the `spender` SHALL be permitted to transfer any or all
    /// of the `owner`'s tokens of the specified token type.
    /// This SHALL apply not only to currently owned tokens, but to all
    /// such tokens acquired in the future, unless the
    /// allowance is `delete`d.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool? ApprovedForAll {
      get { return approvedForAll_; }
      set {
        approvedForAll_ = value;
      }
    }


    /// <summary>Field number for the "delegating_spender" field.</summary>
    public const int DelegatingSpenderFieldNumber = 6;
    private global::Hedera.Hashgraph.Proto.AccountID delegatingSpender_;
    /// <summary>
    ///*
    /// A spender-owner account identifier.&lt;br/>
    /// This account identifier identifies a `spender` for whom an existing
    /// `approved_for_all` allowance was previously created. This enables
    /// an account with such broad access to grant allowances to transfer
    /// individual tokens from the original owner without involving that
    /// original owner.
    /// &lt;p>
    /// If this is set, the account identified MUST sign this transaction, but
    /// the `owner` account MAY NOT sign this transaction.&lt;br/>
    /// If this is set, there MUST exist an active `approved_for_all`
    /// allowance from the `owner` for the `delegating_spender` to transfer
    /// all tokens of the type identified by the `tokenId` field.&lt;br/>
    /// If this value is set, the `approved_for_all` flag MUST be `false`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Hedera.Hashgraph.Proto.AccountID DelegatingSpender {
      get { return delegatingSpender_; }
      set {
        delegatingSpender_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as NftAllowance);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(NftAllowance other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(TokenId, other.TokenId)) return false;
      if (!object.Equals(Owner, other.Owner)) return false;
      if (!object.Equals(Spender, other.Spender)) return false;
      if(!serialNumbers_.Equals(other.serialNumbers_)) return false;
      if (ApprovedForAll != other.ApprovedForAll) return false;
      if (!object.Equals(DelegatingSpender, other.DelegatingSpender)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (tokenId_ != null) hash ^= TokenId.GetHashCode();
      if (owner_ != null) hash ^= Owner.GetHashCode();
      if (spender_ != null) hash ^= Spender.GetHashCode();
      hash ^= serialNumbers_.GetHashCode();
      if (approvedForAll_ != null) hash ^= ApprovedForAll.GetHashCode();
      if (delegatingSpender_ != null) hash ^= DelegatingSpender.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (tokenId_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(TokenId);
      }
      if (owner_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Owner);
      }
      if (spender_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Spender);
      }
      serialNumbers_.WriteTo(output, _repeated_serialNumbers_codec);
      if (approvedForAll_ != null) {
        _single_approvedForAll_codec.WriteTagAndValue(output, ApprovedForAll);
      }
      if (delegatingSpender_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(DelegatingSpender);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (tokenId_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(TokenId);
      }
      if (owner_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Owner);
      }
      if (spender_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Spender);
      }
      serialNumbers_.WriteTo(ref output, _repeated_serialNumbers_codec);
      if (approvedForAll_ != null) {
        _single_approvedForAll_codec.WriteTagAndValue(ref output, ApprovedForAll);
      }
      if (delegatingSpender_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(DelegatingSpender);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (tokenId_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TokenId);
      }
      if (owner_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Owner);
      }
      if (spender_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Spender);
      }
      size += serialNumbers_.CalculateSize(_repeated_serialNumbers_codec);
      if (approvedForAll_ != null) {
        size += _single_approvedForAll_codec.CalculateSizeWithTag(ApprovedForAll);
      }
      if (delegatingSpender_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(DelegatingSpender);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(NftAllowance other) {
      if (other == null) {
        return;
      }
      if (other.tokenId_ != null) {
        if (tokenId_ == null) {
          TokenId = new global::Hedera.Hashgraph.Proto.TokenID();
        }
        TokenId.MergeFrom(other.TokenId);
      }
      if (other.owner_ != null) {
        if (owner_ == null) {
          Owner = new global::Hedera.Hashgraph.Proto.AccountID();
        }
        Owner.MergeFrom(other.Owner);
      }
      if (other.spender_ != null) {
        if (spender_ == null) {
          Spender = new global::Hedera.Hashgraph.Proto.AccountID();
        }
        Spender.MergeFrom(other.Spender);
      }
      serialNumbers_.Add(other.serialNumbers_);
      if (other.approvedForAll_ != null) {
        if (approvedForAll_ == null || other.ApprovedForAll != false) {
          ApprovedForAll = other.ApprovedForAll;
        }
      }
      if (other.delegatingSpender_ != null) {
        if (delegatingSpender_ == null) {
          DelegatingSpender = new global::Hedera.Hashgraph.Proto.AccountID();
        }
        DelegatingSpender.MergeFrom(other.DelegatingSpender);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (tokenId_ == null) {
              TokenId = new global::Hedera.Hashgraph.Proto.TokenID();
            }
            input.ReadMessage(TokenId);
            break;
          }
          case 18: {
            if (owner_ == null) {
              Owner = new global::Hedera.Hashgraph.Proto.AccountID();
            }
            input.ReadMessage(Owner);
            break;
          }
          case 26: {
            if (spender_ == null) {
              Spender = new global::Hedera.Hashgraph.Proto.AccountID();
            }
            input.ReadMessage(Spender);
            break;
          }
          case 34:
          case 32: {
            serialNumbers_.AddEntriesFrom(input, _repeated_serialNumbers_codec);
            break;
          }
          case 42: {
            bool? value = _single_approvedForAll_codec.Read(input);
            if (approvedForAll_ == null || value != false) {
              ApprovedForAll = value;
            }
            break;
          }
          case 50: {
            if (delegatingSpender_ == null) {
              DelegatingSpender = new global::Hedera.Hashgraph.Proto.AccountID();
            }
            input.ReadMessage(DelegatingSpender);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (tokenId_ == null) {
              TokenId = new global::Hedera.Hashgraph.Proto.TokenID();
            }
            input.ReadMessage(TokenId);
            break;
          }
          case 18: {
            if (owner_ == null) {
              Owner = new global::Hedera.Hashgraph.Proto.AccountID();
            }
            input.ReadMessage(Owner);
            break;
          }
          case 26: {
            if (spender_ == null) {
              Spender = new global::Hedera.Hashgraph.Proto.AccountID();
            }
            input.ReadMessage(Spender);
            break;
          }
          case 34:
          case 32: {
            serialNumbers_.AddEntriesFrom(ref input, _repeated_serialNumbers_codec);
            break;
          }
          case 42: {
            bool? value = _single_approvedForAll_codec.Read(ref input);
            if (approvedForAll_ == null || value != false) {
              ApprovedForAll = value;
            }
            break;
          }
          case 50: {
            if (delegatingSpender_ == null) {
              DelegatingSpender = new global::Hedera.Hashgraph.Proto.AccountID();
            }
            input.ReadMessage(DelegatingSpender);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// An approved allowance of fungible/common token transfers.
  /// This message specifies one allowance for a single, unique, combination
  /// of token, owner, spender, and amount.
  ///
  /// If `owner` is not set, the effective `owner` SHALL be the `payer` for the
  /// enclosing transaction.&lt;br/>
  /// The `tokenId` MUST be specified and MUST be a valid
  /// fungible/common token type.&lt;br/>
  /// The `spender` MUST be specified and MUST be a valid account.&lt;br/>
  /// The `amount` MUST be a whole number, and SHOULD be greater than `0` unless
  /// this allowance is intended to _remove_ a previously approved allowance.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class TokenAllowance : pb::IMessage<TokenAllowance>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<TokenAllowance> _parser = new pb::MessageParser<TokenAllowance>(() => new TokenAllowance());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<TokenAllowance> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Hedera.Hashgraph.Proto.CryptoApproveAllowanceReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TokenAllowance() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TokenAllowance(TokenAllowance other) : this() {
      tokenId_ = other.tokenId_ != null ? other.tokenId_.Clone() : null;
      owner_ = other.owner_ != null ? other.owner_.Clone() : null;
      spender_ = other.spender_ != null ? other.spender_.Clone() : null;
      amount_ = other.amount_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TokenAllowance Clone() {
      return new TokenAllowance(this);
    }

    /// <summary>Field number for the "tokenId" field.</summary>
    public const int TokenIdFieldNumber = 1;
    private global::Hedera.Hashgraph.Proto.TokenID tokenId_;
    /// <summary>
    ///*
    /// A token identifier.&lt;br/>
    /// This identifies the type of token the `spender` is permitted to
    /// transfer from the `owner`.
    /// &lt;p>
    /// The identified token type MUST be a fungible/common token.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Hedera.Hashgraph.Proto.TokenID TokenId {
      get { return tokenId_; }
      set {
        tokenId_ = value;
      }
    }

    /// <summary>Field number for the "owner" field.</summary>
    public const int OwnerFieldNumber = 2;
    private global::Hedera.Hashgraph.Proto.AccountID owner_;
    /// <summary>
    ///*
    /// An owner account identifier.&lt;br/>
    /// This is the account identifier of the account granting an allowance
    /// for the `spender` to transfer tokens held by this account.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Hedera.Hashgraph.Proto.AccountID Owner {
      get { return owner_; }
      set {
        owner_ = value;
      }
    }

    /// <summary>Field number for the "spender" field.</summary>
    public const int SpenderFieldNumber = 3;
    private global::Hedera.Hashgraph.Proto.AccountID spender_;
    /// <summary>
    ///*
    /// A spender account identifier.&lt;br/>
    /// This is the account identifier of the account permitted to transfer
    /// tokens held by the `owner`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Hedera.Hashgraph.Proto.AccountID Spender {
      get { return spender_; }
      set {
        spender_ = value;
      }
    }

    /// <summary>Field number for the "amount" field.</summary>
    public const int AmountFieldNumber = 4;
    private long amount_;
    /// <summary>
    ///*
    /// An amount of fractional tokens (10&lt;sup>-decimals&lt;/sup> tokens).&lt;br/>
    /// This is the amount of tokens held by the `owner` that the
    /// `spender` is permitted to transfer.
    /// &lt;p>
    /// This value MUST be a whole number.&lt;br/>
    /// This value MUST be greater than 0 to create a new allowance.&lt;br/>
    /// This value MAY be exactly `0` to _remove_ an existing allowance.&lt;br/>
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long Amount {
      get { return amount_; }
      set {
        amount_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as TokenAllowance);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(TokenAllowance other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(TokenId, other.TokenId)) return false;
      if (!object.Equals(Owner, other.Owner)) return false;
      if (!object.Equals(Spender, other.Spender)) return false;
      if (Amount != other.Amount) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (tokenId_ != null) hash ^= TokenId.GetHashCode();
      if (owner_ != null) hash ^= Owner.GetHashCode();
      if (spender_ != null) hash ^= Spender.GetHashCode();
      if (Amount != 0L) hash ^= Amount.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (tokenId_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(TokenId);
      }
      if (owner_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Owner);
      }
      if (spender_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Spender);
      }
      if (Amount != 0L) {
        output.WriteRawTag(32);
        output.WriteInt64(Amount);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (tokenId_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(TokenId);
      }
      if (owner_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Owner);
      }
      if (spender_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Spender);
      }
      if (Amount != 0L) {
        output.WriteRawTag(32);
        output.WriteInt64(Amount);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (tokenId_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TokenId);
      }
      if (owner_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Owner);
      }
      if (spender_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Spender);
      }
      if (Amount != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(Amount);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(TokenAllowance other) {
      if (other == null) {
        return;
      }
      if (other.tokenId_ != null) {
        if (tokenId_ == null) {
          TokenId = new global::Hedera.Hashgraph.Proto.TokenID();
        }
        TokenId.MergeFrom(other.TokenId);
      }
      if (other.owner_ != null) {
        if (owner_ == null) {
          Owner = new global::Hedera.Hashgraph.Proto.AccountID();
        }
        Owner.MergeFrom(other.Owner);
      }
      if (other.spender_ != null) {
        if (spender_ == null) {
          Spender = new global::Hedera.Hashgraph.Proto.AccountID();
        }
        Spender.MergeFrom(other.Spender);
      }
      if (other.Amount != 0L) {
        Amount = other.Amount;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (tokenId_ == null) {
              TokenId = new global::Hedera.Hashgraph.Proto.TokenID();
            }
            input.ReadMessage(TokenId);
            break;
          }
          case 18: {
            if (owner_ == null) {
              Owner = new global::Hedera.Hashgraph.Proto.AccountID();
            }
            input.ReadMessage(Owner);
            break;
          }
          case 26: {
            if (spender_ == null) {
              Spender = new global::Hedera.Hashgraph.Proto.AccountID();
            }
            input.ReadMessage(Spender);
            break;
          }
          case 32: {
            Amount = input.ReadInt64();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (tokenId_ == null) {
              TokenId = new global::Hedera.Hashgraph.Proto.TokenID();
            }
            input.ReadMessage(TokenId);
            break;
          }
          case 18: {
            if (owner_ == null) {
              Owner = new global::Hedera.Hashgraph.Proto.AccountID();
            }
            input.ReadMessage(Owner);
            break;
          }
          case 26: {
            if (spender_ == null) {
              Spender = new global::Hedera.Hashgraph.Proto.AccountID();
            }
            input.ReadMessage(Spender);
            break;
          }
          case 32: {
            Amount = input.ReadInt64();
            break;
          }
        }
      }
    }
    #endif

  }

  #endregion

}

#endregion Designer generated code
