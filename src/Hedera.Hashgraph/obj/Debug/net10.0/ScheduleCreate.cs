// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: schedule_create.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021, 8981
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Proto {

  /// <summary>Holder for reflection information generated from schedule_create.proto</summary>
  public static partial class ScheduleCreateReflection {

    #region Descriptor
    /// <summary>File descriptor for schedule_create.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static ScheduleCreateReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "ChVzY2hlZHVsZV9jcmVhdGUucHJvdG8SBXByb3RvGhFiYXNpY190eXBlcy5w",
            "cm90bxoPdGltZXN0YW1wLnByb3RvGiJzY2hlZHVsYWJsZV90cmFuc2FjdGlv",
            "bl9ib2R5LnByb3RvIv4BCh1TY2hlZHVsZUNyZWF0ZVRyYW5zYWN0aW9uQm9k",
            "eRJDChhzY2hlZHVsZWRUcmFuc2FjdGlvbkJvZHkYASABKAsyIS5wcm90by5T",
            "Y2hlZHVsYWJsZVRyYW5zYWN0aW9uQm9keRIMCgRtZW1vGAIgASgJEhwKCGFk",
            "bWluS2V5GAMgASgLMgoucHJvdG8uS2V5EigKDnBheWVyQWNjb3VudElEGAQg",
            "ASgLMhAucHJvdG8uQWNjb3VudElEEikKD2V4cGlyYXRpb25fdGltZRgFIAEo",
            "CzIQLnByb3RvLlRpbWVzdGFtcBIXCg93YWl0X2Zvcl9leHBpcnkYDSABKAhC",
            "IgoeY29tLmhlZGVyYS5oYXNoZ3JhcGguc2RrLnByb3RvUAFiBnByb3RvMw=="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Proto.BasicTypesReflection.Descriptor, global::Proto.TimestampReflection.Descriptor, global::Proto.SchedulableTransactionBodyReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Proto.ScheduleCreateTransactionBody), global::Proto.ScheduleCreateTransactionBody.Parser, new[]{ "ScheduledTransactionBody", "Memo", "AdminKey", "PayerAccountID", "ExpirationTime", "WaitForExpiry" }, null, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  ///*
  /// Create a new Schedule.
  ///
  /// #### Requirements
  /// This transaction SHALL create a new _schedule_ entity in network state.&lt;br/>
  /// The schedule created SHALL contain the `scheduledTransactionBody` to be
  /// executed.&lt;br/>
  /// If successful the receipt SHALL contain a `scheduleID` with the full
  /// identifier of the schedule created.&lt;br/>
  /// When a schedule _executes_ successfully, the receipt SHALL include a
  /// `scheduledTransactionID` with the `TransactionID` of the transaction that
  /// executed.&lt;br/>
  /// When a scheduled transaction is executed the network SHALL charge the
  /// regular _service_ fee for the transaction to the `payerAccountID` for
  /// that schedule, but SHALL NOT charge node or network fees.&lt;br/>
  /// If the `payerAccountID` field is not set, the effective `payerAccountID`
  /// SHALL be the `payer` for this create transaction.&lt;br/>
  /// If an `adminKey` is not specified, or is an empty `KeyList`, the schedule
  /// created SHALL be immutable.&lt;br/>
  /// An immutable schedule MAY be signed, and MAY execute, but SHALL NOT be
  /// deleted.&lt;br/>
  /// If two schedules have the same values for all fields except `payerAccountID`
  /// then those two schedules SHALL be deemed "identical".&lt;br/>
  /// If a `scheduleCreate` requests a new schedule that is identical to an
  /// existing schedule, the transaction SHALL fail and SHALL return a status
  /// code of `IDENTICAL_SCHEDULE_ALREADY_CREATED` in the receipt.&lt;br/>
  /// The receipt for a duplicate schedule SHALL include the `ScheduleID` of the
  /// existing schedule and the `TransactionID` of the earlier `scheduleCreate`
  /// so that the earlier schedule may be queried and/or referred to in a
  /// subsequent `scheduleSign`.
  ///
  /// #### Signature Requirements
  /// A `scheduleSign` transaction SHALL be used to add additional signatures
  /// to an existing schedule.&lt;br/>
  /// Each signature SHALL "activate" the corresponding cryptographic("primitive")
  /// key for that schedule.&lt;br/>
  /// Signature requirements SHALL be met when the set of active keys includes
  /// all keys required by the scheduled transaction.&lt;br/>
  /// A scheduled transaction for a "long term" schedule SHALL NOT execute if
  /// the signature requirements for that transaction are not met when the
  /// network consensus time reaches the schedule `expiration_time`.&lt;br/>
  /// A "short term" schedule SHALL execute immediately once signature
  /// requirements are met. This MAY be immediately when created.
  ///
  /// #### Long Term Schedules
  /// A "short term" schedule SHALL have the flag `wait_for_expiry` _unset_.&lt;br/>
  /// A "long term" schedule SHALL have the flag  `wait_for_expiry` _set_.&lt;br/>
  /// A "long term" schedule SHALL NOT be accepted if the network configuration
  /// `scheduling.longTermEnabled` is not enabled.&lt;br/>
  /// A "long term" schedule SHALL execute when the current consensus time
  /// matches or exceeds the `expiration_time` for that schedule, if the
  /// signature requirements for the scheduled transaction
  /// are met at that instant.&lt;br/>
  /// A "long term" schedule SHALL NOT execute before the current consensus time
  /// matches or exceeds the `expiration_time` for that schedule.&lt;br/>
  /// A "long term" schedule SHALL expire, and be removed from state, after the
  /// network consensus time exceeds the schedule `expiration_time`.&lt;br/>
  /// A short term schedule SHALL expire, and be removed from state,
  /// after the network consensus time exceeds the current network
  /// configuration for `ledger.scheduleTxExpiryTimeSecs`.
  ///
  /// > Note
  /// >> Long term schedules are not (as of release 0.56.0) enabled. Any schedule
  /// >> created currently MUST NOT set the `wait_for_expiry` flag.&lt;br/>
  /// >> When long term schedules are not enabled, schedules SHALL NOT be
  /// >> executed at expiration, and MUST meet signature requirements strictly
  /// >> before expiration to be executed.
  ///
  /// ### Block Stream Effects
  /// If the scheduled transaction is executed immediately, the transaction
  /// record SHALL include a `scheduleRef` with the schedule identifier of the
  /// schedule created.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class ScheduleCreateTransactionBody : pb::IMessage<ScheduleCreateTransactionBody>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ScheduleCreateTransactionBody> _parser = new pb::MessageParser<ScheduleCreateTransactionBody>(() => new ScheduleCreateTransactionBody());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ScheduleCreateTransactionBody> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Proto.ScheduleCreateReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ScheduleCreateTransactionBody() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ScheduleCreateTransactionBody(ScheduleCreateTransactionBody other) : this() {
      scheduledTransactionBody_ = other.scheduledTransactionBody_ != null ? other.scheduledTransactionBody_.Clone() : null;
      memo_ = other.memo_;
      adminKey_ = other.adminKey_ != null ? other.adminKey_.Clone() : null;
      payerAccountID_ = other.payerAccountID_ != null ? other.payerAccountID_.Clone() : null;
      expirationTime_ = other.expirationTime_ != null ? other.expirationTime_.Clone() : null;
      waitForExpiry_ = other.waitForExpiry_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ScheduleCreateTransactionBody Clone() {
      return new ScheduleCreateTransactionBody(this);
    }

    /// <summary>Field number for the "scheduledTransactionBody" field.</summary>
    public const int ScheduledTransactionBodyFieldNumber = 1;
    private global::Proto.SchedulableTransactionBody scheduledTransactionBody_;
    /// <summary>
    ///*
    /// A scheduled transaction.
    /// &lt;p>
    /// This value is REQUIRED.&lt;br/>
    /// This transaction body MUST be one of the types enabled in the
    /// network configuration value `scheduling.whitelist`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.SchedulableTransactionBody ScheduledTransactionBody {
      get { return scheduledTransactionBody_; }
      set {
        scheduledTransactionBody_ = value;
      }
    }

    /// <summary>Field number for the "memo" field.</summary>
    public const int MemoFieldNumber = 2;
    private string memo_ = "";
    /// <summary>
    ///*
    /// A short description of the schedule.
    /// &lt;p>
    /// This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
    /// (default 100) bytes when encoded as UTF-8.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Memo {
      get { return memo_; }
      set {
        memo_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "adminKey" field.</summary>
    public const int AdminKeyFieldNumber = 3;
    private global::Proto.Key adminKey_;
    /// <summary>
    ///*
    /// A `Key` required to delete this schedule.
    /// &lt;p>
    /// If this is not set, or is an empty `KeyList`, this schedule SHALL be
    /// immutable and SHALL NOT be deleted.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.Key AdminKey {
      get { return adminKey_; }
      set {
        adminKey_ = value;
      }
    }

    /// <summary>Field number for the "payerAccountID" field.</summary>
    public const int PayerAccountIDFieldNumber = 4;
    private global::Proto.AccountID payerAccountID_;
    /// <summary>
    ///*
    /// An account identifier of a `payer` for the scheduled transaction.
    /// &lt;p>
    /// This value MAY be unset. If unset, the `payer` for this `scheduleCreate`
    /// transaction SHALL be the `payer` for the scheduled transaction.&lt;br/>
    /// If this is set, the identified account SHALL be charged the fees
    /// required for the scheduled transaction when it is executed.&lt;br/>
    /// If the actual `payer` for the _scheduled_ transaction lacks
    /// sufficient HBAR balance to pay service fees for the scheduled
    /// transaction _when it executes_, the scheduled transaction
    /// SHALL fail with `INSUFFICIENT_PAYER_BALANCE`.&lt;br/>
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.AccountID PayerAccountID {
      get { return payerAccountID_; }
      set {
        payerAccountID_ = value;
      }
    }

    /// <summary>Field number for the "expiration_time" field.</summary>
    public const int ExpirationTimeFieldNumber = 5;
    private global::Proto.Timestamp expirationTime_;
    /// <summary>
    ///*
    /// An expiration time.
    /// &lt;p>
    /// If not set, the expiration SHALL default to the current consensus time
    /// advanced by either the network configuration value
    /// `scheduling.maxExpirationFutureSeconds`, if `wait_for_expiry` is set and
    /// "long term" schedules are enabled, or the network configuration value
    /// `ledger.scheduleTxExpiryTimeSecs` otherwise.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.Timestamp ExpirationTime {
      get { return expirationTime_; }
      set {
        expirationTime_ = value;
      }
    }

    /// <summary>Field number for the "wait_for_expiry" field.</summary>
    public const int WaitForExpiryFieldNumber = 13;
    private bool waitForExpiry_;
    /// <summary>
    ///*
    /// A flag to delay execution until expiration.
    /// &lt;p>
    /// If this flag is set the scheduled transaction SHALL NOT be evaluated for
    /// execution before the network consensus time matches or exceeds the
    /// `expiration_time`.&lt;br/>
    /// If this flag is not set, the scheduled transaction SHALL be executed
    /// immediately when all required signatures are received, whether in this
    /// `scheduleCreate` transaction or a later `scheduleSign` transaction.&lt;br/>
    /// This value SHALL NOT be used and MUST NOT be set when the network
    /// configuration value `scheduling.longTermEnabled` is not enabled.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool WaitForExpiry {
      get { return waitForExpiry_; }
      set {
        waitForExpiry_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ScheduleCreateTransactionBody);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ScheduleCreateTransactionBody other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(ScheduledTransactionBody, other.ScheduledTransactionBody)) return false;
      if (Memo != other.Memo) return false;
      if (!object.Equals(AdminKey, other.AdminKey)) return false;
      if (!object.Equals(PayerAccountID, other.PayerAccountID)) return false;
      if (!object.Equals(ExpirationTime, other.ExpirationTime)) return false;
      if (WaitForExpiry != other.WaitForExpiry) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (scheduledTransactionBody_ != null) hash ^= ScheduledTransactionBody.GetHashCode();
      if (Memo.Length != 0) hash ^= Memo.GetHashCode();
      if (adminKey_ != null) hash ^= AdminKey.GetHashCode();
      if (payerAccountID_ != null) hash ^= PayerAccountID.GetHashCode();
      if (expirationTime_ != null) hash ^= ExpirationTime.GetHashCode();
      if (WaitForExpiry != false) hash ^= WaitForExpiry.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (scheduledTransactionBody_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(ScheduledTransactionBody);
      }
      if (Memo.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Memo);
      }
      if (adminKey_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(AdminKey);
      }
      if (payerAccountID_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(PayerAccountID);
      }
      if (expirationTime_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(ExpirationTime);
      }
      if (WaitForExpiry != false) {
        output.WriteRawTag(104);
        output.WriteBool(WaitForExpiry);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (scheduledTransactionBody_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(ScheduledTransactionBody);
      }
      if (Memo.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Memo);
      }
      if (adminKey_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(AdminKey);
      }
      if (payerAccountID_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(PayerAccountID);
      }
      if (expirationTime_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(ExpirationTime);
      }
      if (WaitForExpiry != false) {
        output.WriteRawTag(104);
        output.WriteBool(WaitForExpiry);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (scheduledTransactionBody_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ScheduledTransactionBody);
      }
      if (Memo.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Memo);
      }
      if (adminKey_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(AdminKey);
      }
      if (payerAccountID_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(PayerAccountID);
      }
      if (expirationTime_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ExpirationTime);
      }
      if (WaitForExpiry != false) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ScheduleCreateTransactionBody other) {
      if (other == null) {
        return;
      }
      if (other.scheduledTransactionBody_ != null) {
        if (scheduledTransactionBody_ == null) {
          ScheduledTransactionBody = new global::Proto.SchedulableTransactionBody();
        }
        ScheduledTransactionBody.MergeFrom(other.ScheduledTransactionBody);
      }
      if (other.Memo.Length != 0) {
        Memo = other.Memo;
      }
      if (other.adminKey_ != null) {
        if (adminKey_ == null) {
          AdminKey = new global::Proto.Key();
        }
        AdminKey.MergeFrom(other.AdminKey);
      }
      if (other.payerAccountID_ != null) {
        if (payerAccountID_ == null) {
          PayerAccountID = new global::Proto.AccountID();
        }
        PayerAccountID.MergeFrom(other.PayerAccountID);
      }
      if (other.expirationTime_ != null) {
        if (expirationTime_ == null) {
          ExpirationTime = new global::Proto.Timestamp();
        }
        ExpirationTime.MergeFrom(other.ExpirationTime);
      }
      if (other.WaitForExpiry != false) {
        WaitForExpiry = other.WaitForExpiry;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (scheduledTransactionBody_ == null) {
              ScheduledTransactionBody = new global::Proto.SchedulableTransactionBody();
            }
            input.ReadMessage(ScheduledTransactionBody);
            break;
          }
          case 18: {
            Memo = input.ReadString();
            break;
          }
          case 26: {
            if (adminKey_ == null) {
              AdminKey = new global::Proto.Key();
            }
            input.ReadMessage(AdminKey);
            break;
          }
          case 34: {
            if (payerAccountID_ == null) {
              PayerAccountID = new global::Proto.AccountID();
            }
            input.ReadMessage(PayerAccountID);
            break;
          }
          case 42: {
            if (expirationTime_ == null) {
              ExpirationTime = new global::Proto.Timestamp();
            }
            input.ReadMessage(ExpirationTime);
            break;
          }
          case 104: {
            WaitForExpiry = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (scheduledTransactionBody_ == null) {
              ScheduledTransactionBody = new global::Proto.SchedulableTransactionBody();
            }
            input.ReadMessage(ScheduledTransactionBody);
            break;
          }
          case 18: {
            Memo = input.ReadString();
            break;
          }
          case 26: {
            if (adminKey_ == null) {
              AdminKey = new global::Proto.Key();
            }
            input.ReadMessage(AdminKey);
            break;
          }
          case 34: {
            if (payerAccountID_ == null) {
              PayerAccountID = new global::Proto.AccountID();
            }
            input.ReadMessage(PayerAccountID);
            break;
          }
          case 42: {
            if (expirationTime_ == null) {
              ExpirationTime = new global::Proto.Timestamp();
            }
            input.ReadMessage(ExpirationTime);
            break;
          }
          case 104: {
            WaitForExpiry = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

  }

  #endregion

}

#endregion Designer generated code
