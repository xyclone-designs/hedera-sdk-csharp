// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: custom_fees.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021, 8981
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Hedera.Hashgraph.Proto {

  /// <summary>Holder for reflection information generated from custom_fees.proto</summary>
  public static partial class CustomFeesReflection {

    #region Descriptor
    /// <summary>File descriptor for custom_fees.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static CustomFeesReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "ChFjdXN0b21fZmVlcy5wcm90bxIFcHJvdG8aEWJhc2ljX3R5cGVzLnByb3Rv",
            "IoUBCg1GcmFjdGlvbmFsRmVlEioKEWZyYWN0aW9uYWxfYW1vdW50GAEgASgL",
            "Mg8ucHJvdG8uRnJhY3Rpb24SFgoObWluaW11bV9hbW91bnQYAiABKAMSFgoO",
            "bWF4aW11bV9hbW91bnQYAyABKAMSGAoQbmV0X29mX3RyYW5zZmVycxgEIAEo",
            "CCJJCghGaXhlZEZlZRIOCgZhbW91bnQYASABKAMSLQoVZGVub21pbmF0aW5n",
            "X3Rva2VuX2lkGAIgASgLMg4ucHJvdG8uVG9rZW5JRCJlCgpSb3lhbHR5RmVl",
            "EjAKF2V4Y2hhbmdlX3ZhbHVlX2ZyYWN0aW9uGAEgASgLMg8ucHJvdG8uRnJh",
            "Y3Rpb24SJQoMZmFsbGJhY2tfZmVlGAIgASgLMg8ucHJvdG8uRml4ZWRGZWUi",
            "6QEKCUN1c3RvbUZlZRIkCglmaXhlZF9mZWUYASABKAsyDy5wcm90by5GaXhl",
            "ZEZlZUgAEi4KDmZyYWN0aW9uYWxfZmVlGAIgASgLMhQucHJvdG8uRnJhY3Rp",
            "b25hbEZlZUgAEigKC3JveWFsdHlfZmVlGAQgASgLMhEucHJvdG8uUm95YWx0",
            "eUZlZUgAEjIKGGZlZV9jb2xsZWN0b3JfYWNjb3VudF9pZBgDIAEoCzIQLnBy",
            "b3RvLkFjY291bnRJRBIhChlhbGxfY29sbGVjdG9yc19hcmVfZXhlbXB0GAUg",
            "ASgIQgUKA2ZlZSKvAQoRQXNzZXNzZWRDdXN0b21GZWUSDgoGYW1vdW50GAEg",
            "ASgDEiAKCHRva2VuX2lkGAIgASgLMg4ucHJvdG8uVG9rZW5JRBIyChhmZWVf",
            "Y29sbGVjdG9yX2FjY291bnRfaWQYAyABKAsyEC5wcm90by5BY2NvdW50SUQS",
            "NAoaZWZmZWN0aXZlX3BheWVyX2FjY291bnRfaWQYBCADKAsyEC5wcm90by5B",
            "Y2NvdW50SUQiaAoORml4ZWRDdXN0b21GZWUSIgoJZml4ZWRfZmVlGAEgASgL",
            "Mg8ucHJvdG8uRml4ZWRGZWUSMgoYZmVlX2NvbGxlY3Rvcl9hY2NvdW50X2lk",
            "GAIgASgLMhAucHJvdG8uQWNjb3VudElEIjkKEkZpeGVkQ3VzdG9tRmVlTGlz",
            "dBIjCgRmZWVzGAEgAygLMhUucHJvdG8uRml4ZWRDdXN0b21GZWUiLAoQRmVl",
            "RXhlbXB0S2V5TGlzdBIYCgRrZXlzGAEgAygLMgoucHJvdG8uS2V5IlUKDkN1",
            "c3RvbUZlZUxpbWl0EiQKCmFjY291bnRfaWQYASABKAsyEC5wcm90by5BY2Nv",
            "dW50SUQSHQoEZmVlcxgCIAMoCzIPLnByb3RvLkZpeGVkRmVlQjkKHmNvbS5o",
            "ZWRlcmEuaGFzaGdyYXBoLnNkay5wcm90b6oCFkhlZGVyYS5IYXNoZ3JhcGgu",
            "UHJvdG9iBnByb3RvMw=="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Hedera.Hashgraph.Proto.BasicTypesReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Hedera.Hashgraph.Proto.FractionalFee), global::Hedera.Hashgraph.Proto.FractionalFee.Parser, new[]{ "FractionalAmount", "MinimumAmount", "MaximumAmount", "NetOfTransfers" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Hedera.Hashgraph.Proto.FixedFee), global::Hedera.Hashgraph.Proto.FixedFee.Parser, new[]{ "Amount", "DenominatingTokenId" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Hedera.Hashgraph.Proto.RoyaltyFee), global::Hedera.Hashgraph.Proto.RoyaltyFee.Parser, new[]{ "ExchangeValueFraction", "FallbackFee" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Hedera.Hashgraph.Proto.CustomFee), global::Hedera.Hashgraph.Proto.CustomFee.Parser, new[]{ "FixedFee", "FractionalFee", "RoyaltyFee", "FeeCollectorAccountId", "AllCollectorsAreExempt" }, new[]{ "Fee" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Hedera.Hashgraph.Proto.AssessedCustomFee), global::Hedera.Hashgraph.Proto.AssessedCustomFee.Parser, new[]{ "Amount", "TokenId", "FeeCollectorAccountId", "EffectivePayerAccountId" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Hedera.Hashgraph.Proto.FixedCustomFee), global::Hedera.Hashgraph.Proto.FixedCustomFee.Parser, new[]{ "FixedFee", "FeeCollectorAccountId" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Hedera.Hashgraph.Proto.FixedCustomFeeList), global::Hedera.Hashgraph.Proto.FixedCustomFeeList.Parser, new[]{ "Fees" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Hedera.Hashgraph.Proto.FeeExemptKeyList), global::Hedera.Hashgraph.Proto.FeeExemptKeyList.Parser, new[]{ "Keys" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Hedera.Hashgraph.Proto.CustomFeeLimit), global::Hedera.Hashgraph.Proto.CustomFeeLimit.Parser, new[]{ "AccountId", "Fees" }, null, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  ///*
  /// A descriptor for a fee based on a portion of the tokens transferred.
  ///
  /// This fee option describes fees as a fraction of the amount of
  /// fungible/common token(s) transferred.  The fee also describes a minimum
  /// and maximum amount, both of which are OPTIONAL.
  ///
  /// This type of fee SHALL be assessed only for fungible/common tokens.&lt;br/>
  /// This type of fee MUST NOT be defined for a non-fungible/unique
  /// token type.&lt;br/>
  /// This fee SHALL be paid with the same type of tokens as those
  /// transferred.&lt;br/>
  /// The fee MAY be subtracted from the transferred tokens, or MAY be assessed
  /// to the sender in addition to the tokens actually transferred, based on
  /// the `net_of_transfers` field.
  ///
  /// When a single transaction sends tokens from one sender to multiple
  /// recipients, and the `net_of_transfers` flag is false, the network
  /// SHALL attempt to evenly assess the total fee across all recipients
  /// proportionally. This may be inexact and, particularly when there are
  /// large differences between recipients, MAY result in small deviations
  /// from an ideal "fair" distribution.&lt;br/>
  /// If the sender lacks sufficient tokens to pay fees, or the assessment
  /// of custom fees reduces the net amount transferred to or below zero,
  /// the transaction MAY fail due to insufficient funds to pay all fees.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class FractionalFee : pb::IMessage<FractionalFee>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<FractionalFee> _parser = new pb::MessageParser<FractionalFee>(() => new FractionalFee());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<FractionalFee> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Hedera.Hashgraph.Proto.CustomFeesReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public FractionalFee() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public FractionalFee(FractionalFee other) : this() {
      fractionalAmount_ = other.fractionalAmount_ != null ? other.fractionalAmount_.Clone() : null;
      minimumAmount_ = other.minimumAmount_;
      maximumAmount_ = other.maximumAmount_;
      netOfTransfers_ = other.netOfTransfers_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public FractionalFee Clone() {
      return new FractionalFee(this);
    }

    /// <summary>Field number for the "fractional_amount" field.</summary>
    public const int FractionalAmountFieldNumber = 1;
    private global::Hedera.Hashgraph.Proto.Fraction fractionalAmount_;
    /// <summary>
    ///*
    /// A Fraction of the transferred tokens to assess as a fee.&lt;br/>
    /// This value MUST be less than or equal to one.&lt;br/>
    /// This value MUST be greater than zero.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Hedera.Hashgraph.Proto.Fraction FractionalAmount {
      get { return fractionalAmount_; }
      set {
        fractionalAmount_ = value;
      }
    }

    /// <summary>Field number for the "minimum_amount" field.</summary>
    public const int MinimumAmountFieldNumber = 2;
    private long minimumAmount_;
    /// <summary>
    ///*
    /// A minimum fee to charge, in units of 10&lt;sup>-decimals&lt;/sup> tokens.
    /// &lt;p>
    /// This value is OPTIONAL, with a default of `0` indicating no minimum.&lt;br/>
    /// If set, this value MUST be greater than zero.&lt;br/>
    /// If set, all transfers SHALL pay at least this amount.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long MinimumAmount {
      get { return minimumAmount_; }
      set {
        minimumAmount_ = value;
      }
    }

    /// <summary>Field number for the "maximum_amount" field.</summary>
    public const int MaximumAmountFieldNumber = 3;
    private long maximumAmount_;
    /// <summary>
    ///*
    /// A maximum fee to charge, in units of 10&lt;sup>-decimals&lt;/sup> tokens.
    /// &lt;p>
    /// This value is OPTIONAL, with a default of `0` indicating no maximum.&lt;br/>
    /// If set, this value MUST be greater than zero.&lt;br/>
    /// If set, any fee charged SHALL NOT exceed this value.&lt;br/>
    /// This value SHOULD be strictly greater than `minimum_amount`.
    /// If this amount is less than or equal to `minimum_amount`, then
    /// the fee charged SHALL always be equal to this value and
    /// `fractional_amount` SHALL NOT have any effect.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long MaximumAmount {
      get { return maximumAmount_; }
      set {
        maximumAmount_ = value;
      }
    }

    /// <summary>Field number for the "net_of_transfers" field.</summary>
    public const int NetOfTransfersFieldNumber = 4;
    private bool netOfTransfers_;
    /// <summary>
    ///*
    /// Flag requesting to assess the calculated fee against the sender,
    /// without reducing the amount transferred.&lt;br/>
    /// #### Effects of this flag
    /// &lt;ol>
    ///   &lt;li>If this value is true
    ///     &lt;ul>
    ///       &lt;li>The receiver of a transfer SHALL receive the entire
    ///           amount sent.&lt;/li>
    ///       &lt;li>The fee SHALL be charged to the sender as an additional
    ///           amount, increasing the token transfer debit.&lt;/li>
    ///     &lt;/ul>
    ///   &lt;/li>
    ///   &lt;li>If this value is false
    ///     &lt;ul>
    ///       &lt;li>The receiver of a transfer SHALL receive the amount sent
    ///           _after_ deduction of the calculated fee.&lt;/li>
    ///     &lt;/ul>
    ///   &lt;/li>
    /// &lt;/ol>
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool NetOfTransfers {
      get { return netOfTransfers_; }
      set {
        netOfTransfers_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as FractionalFee);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(FractionalFee other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(FractionalAmount, other.FractionalAmount)) return false;
      if (MinimumAmount != other.MinimumAmount) return false;
      if (MaximumAmount != other.MaximumAmount) return false;
      if (NetOfTransfers != other.NetOfTransfers) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (fractionalAmount_ != null) hash ^= FractionalAmount.GetHashCode();
      if (MinimumAmount != 0L) hash ^= MinimumAmount.GetHashCode();
      if (MaximumAmount != 0L) hash ^= MaximumAmount.GetHashCode();
      if (NetOfTransfers != false) hash ^= NetOfTransfers.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (fractionalAmount_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(FractionalAmount);
      }
      if (MinimumAmount != 0L) {
        output.WriteRawTag(16);
        output.WriteInt64(MinimumAmount);
      }
      if (MaximumAmount != 0L) {
        output.WriteRawTag(24);
        output.WriteInt64(MaximumAmount);
      }
      if (NetOfTransfers != false) {
        output.WriteRawTag(32);
        output.WriteBool(NetOfTransfers);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (fractionalAmount_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(FractionalAmount);
      }
      if (MinimumAmount != 0L) {
        output.WriteRawTag(16);
        output.WriteInt64(MinimumAmount);
      }
      if (MaximumAmount != 0L) {
        output.WriteRawTag(24);
        output.WriteInt64(MaximumAmount);
      }
      if (NetOfTransfers != false) {
        output.WriteRawTag(32);
        output.WriteBool(NetOfTransfers);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (fractionalAmount_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(FractionalAmount);
      }
      if (MinimumAmount != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(MinimumAmount);
      }
      if (MaximumAmount != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(MaximumAmount);
      }
      if (NetOfTransfers != false) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(FractionalFee other) {
      if (other == null) {
        return;
      }
      if (other.fractionalAmount_ != null) {
        if (fractionalAmount_ == null) {
          FractionalAmount = new global::Hedera.Hashgraph.Proto.Fraction();
        }
        FractionalAmount.MergeFrom(other.FractionalAmount);
      }
      if (other.MinimumAmount != 0L) {
        MinimumAmount = other.MinimumAmount;
      }
      if (other.MaximumAmount != 0L) {
        MaximumAmount = other.MaximumAmount;
      }
      if (other.NetOfTransfers != false) {
        NetOfTransfers = other.NetOfTransfers;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (fractionalAmount_ == null) {
              FractionalAmount = new global::Hedera.Hashgraph.Proto.Fraction();
            }
            input.ReadMessage(FractionalAmount);
            break;
          }
          case 16: {
            MinimumAmount = input.ReadInt64();
            break;
          }
          case 24: {
            MaximumAmount = input.ReadInt64();
            break;
          }
          case 32: {
            NetOfTransfers = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (fractionalAmount_ == null) {
              FractionalAmount = new global::Hedera.Hashgraph.Proto.Fraction();
            }
            input.ReadMessage(FractionalAmount);
            break;
          }
          case 16: {
            MinimumAmount = input.ReadInt64();
            break;
          }
          case 24: {
            MaximumAmount = input.ReadInt64();
            break;
          }
          case 32: {
            NetOfTransfers = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// A fixed fee to assess for each token transfer, regardless of the
  /// amount transferred.&lt;br/>
  /// This fee type describes a fixed fee for each transfer of a token type.
  ///
  /// The fee SHALL be charged to the `sender` for the token transfer
  /// transaction.&lt;br/>
  /// This fee MAY be assessed in HBAR, the token type transferred, or any
  /// other token type, as determined by the `denominating_token_id` field.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class FixedFee : pb::IMessage<FixedFee>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<FixedFee> _parser = new pb::MessageParser<FixedFee>(() => new FixedFee());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<FixedFee> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Hedera.Hashgraph.Proto.CustomFeesReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public FixedFee() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public FixedFee(FixedFee other) : this() {
      amount_ = other.amount_;
      denominatingTokenId_ = other.denominatingTokenId_ != null ? other.denominatingTokenId_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public FixedFee Clone() {
      return new FixedFee(this);
    }

    /// <summary>Field number for the "amount" field.</summary>
    public const int AmountFieldNumber = 1;
    private long amount_;
    /// <summary>
    ///*
    /// The amount to assess for each transfer.
    /// &lt;p>
    /// This value MUST be greater than `0`.&lt;br/>
    /// This amount is expressed in units of 10&lt;sup>-decimals&lt;/sup> tokens.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long Amount {
      get { return amount_; }
      set {
        amount_ = value;
      }
    }

    /// <summary>Field number for the "denominating_token_id" field.</summary>
    public const int DenominatingTokenIdFieldNumber = 2;
    private global::Hedera.Hashgraph.Proto.TokenID denominatingTokenId_;
    /// <summary>
    ///*
    /// The token type used to pay the assessed fee.
    /// &lt;p>
    /// If this is unset, the fee SHALL be assessed in HBAR.&lt;br/>
    /// If this is set, the fee SHALL be assessed in the token identified.
    /// This MAY be any token type. Custom fees assessed in other token types
    /// are more likely to fail, however, and it is RECOMMENDED that token
    /// creators denominate custom fees in the transferred token, HBAR, or
    /// well documented and closely related token types.&lt;br/>
    /// If this value is set to `0.0.0` in the `tokenCreate` transaction, it
    /// SHALL be replaced with the `TokenID` of the newly created token.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Hedera.Hashgraph.Proto.TokenID DenominatingTokenId {
      get { return denominatingTokenId_; }
      set {
        denominatingTokenId_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as FixedFee);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(FixedFee other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Amount != other.Amount) return false;
      if (!object.Equals(DenominatingTokenId, other.DenominatingTokenId)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Amount != 0L) hash ^= Amount.GetHashCode();
      if (denominatingTokenId_ != null) hash ^= DenominatingTokenId.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Amount != 0L) {
        output.WriteRawTag(8);
        output.WriteInt64(Amount);
      }
      if (denominatingTokenId_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(DenominatingTokenId);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Amount != 0L) {
        output.WriteRawTag(8);
        output.WriteInt64(Amount);
      }
      if (denominatingTokenId_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(DenominatingTokenId);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Amount != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(Amount);
      }
      if (denominatingTokenId_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(DenominatingTokenId);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(FixedFee other) {
      if (other == null) {
        return;
      }
      if (other.Amount != 0L) {
        Amount = other.Amount;
      }
      if (other.denominatingTokenId_ != null) {
        if (denominatingTokenId_ == null) {
          DenominatingTokenId = new global::Hedera.Hashgraph.Proto.TokenID();
        }
        DenominatingTokenId.MergeFrom(other.DenominatingTokenId);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Amount = input.ReadInt64();
            break;
          }
          case 18: {
            if (denominatingTokenId_ == null) {
              DenominatingTokenId = new global::Hedera.Hashgraph.Proto.TokenID();
            }
            input.ReadMessage(DenominatingTokenId);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Amount = input.ReadInt64();
            break;
          }
          case 18: {
            if (denominatingTokenId_ == null) {
              DenominatingTokenId = new global::Hedera.Hashgraph.Proto.TokenID();
            }
            input.ReadMessage(DenominatingTokenId);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// A fee to assess during a CryptoTransfer that changes ownership of a
  /// non-fungible/unique (NFT) token.&lt;br/>
  /// This message defines the fraction of the fungible value exchanged for an
  /// NFT that the ledger should collect as a royalty.
  /// "Fungible value" includes both HBAR (â„) and units of fungible HTS tokens.
  /// When the NFT sender does not receive any fungible value, the ledger will
  /// assess the fallback fee, if present, to the new NFT owner. Royalty fees
  /// can only be added to non-fungible/unique tokens.
  ///
  /// #### Important Note
  /// > Users should be aware that native royalty fees are _strictly_ a
  /// > convenience feature, SHALL NOT be guaranteed, and the network SHALL NOT
  /// > enforce _inescapable_ royalties on the exchange of a unique NFT.&lt;br/>
  /// > For _one_ example, if the counterparties agree to split their value
  /// > transfer and NFT exchange into separate transactions, the network cannot
  /// > possibly determine the value exchanged. Even trustless transactions,
  /// > using a smart contract or other form of escrow, can arrange such split
  /// > transactions as a single _logical_ transfer.
  ///
  /// Counterparties that wish to _respect_ creator royalties MUST follow the
  /// pattern the network recognizes.
  /// &lt;div style="margin-left: 2em; margin-top: -0.8em">
  /// A single transaction MUST contain all three elements, transfer of the NFT,
  /// debit of fungible value from the receiver, and credit of fungible value to
  /// the sender, in order for the network to accurately assess royalty fees.
  /// &lt;/div>
  /// &lt;div style="margin-left: 1em; margin-top: -0.8em">
  /// Two examples are presented here.
  /// &lt;div style="margin-left: 1em">
  /// The NFT sender and receiver MUST both sign a single `cryptoTransfer` that
  /// transfers the NFT from sender to receiver, debits the fungible value from
  /// the receiver, and credits the sender with the fungible value the receiver
  /// is exchanging for the NFT.&lt;br/>
  /// A marketplace using an approved spender account for an escrow transaction
  /// MUST credit the account selling the NFT in the same `cryptoTransfer`
  /// transaction that transfers the NFT to, and deducts fungible value from,
  /// the buying account.
  /// &lt;/div>&lt;/div>
  /// This type of fee MAY NOT produce accurate results if multiple transfers
  /// are executed in a single transaction. It is RECOMMENDED that each
  /// NFT subject to royalty fees be transferred separately and without
  /// unrelated fungible token transfers.
  ///
  /// The network SHALL NOT consider third-party transfers, including
  /// "approved spender" accounts, in collecting royalty fees. An honest
  /// broker MUST ensure that transfer of an NFT and payment delivered to
  /// the sender are present in the same transaction.
  /// There is an
  /// [open suggestion](https://github.com/hashgraph/hedera-improvement-proposal/discussions/578)
  /// that proposes to broaden the scope of transfers from which the network
  /// automatically collects royalties to cover related third parties. If this
  /// interests or concerns you, please add your voice to that discussion.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class RoyaltyFee : pb::IMessage<RoyaltyFee>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<RoyaltyFee> _parser = new pb::MessageParser<RoyaltyFee>(() => new RoyaltyFee());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<RoyaltyFee> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Hedera.Hashgraph.Proto.CustomFeesReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public RoyaltyFee() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public RoyaltyFee(RoyaltyFee other) : this() {
      exchangeValueFraction_ = other.exchangeValueFraction_ != null ? other.exchangeValueFraction_.Clone() : null;
      fallbackFee_ = other.fallbackFee_ != null ? other.fallbackFee_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public RoyaltyFee Clone() {
      return new RoyaltyFee(this);
    }

    /// <summary>Field number for the "exchange_value_fraction" field.</summary>
    public const int ExchangeValueFractionFieldNumber = 1;
    private global::Hedera.Hashgraph.Proto.Fraction exchangeValueFraction_;
    /// <summary>
    ///*
    /// The fraction of fungible value exchanged for an NFT to collect
    /// as royalty.
    /// &lt;p>
    /// This SHALL be applied once to the total fungible value transferred
    /// for the transaction.&lt;br/>
    /// There SHALL NOT be any adjustment based on multiple transfers
    /// involving the NFT sender as part of a single transaction.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Hedera.Hashgraph.Proto.Fraction ExchangeValueFraction {
      get { return exchangeValueFraction_; }
      set {
        exchangeValueFraction_ = value;
      }
    }

    /// <summary>Field number for the "fallback_fee" field.</summary>
    public const int FallbackFeeFieldNumber = 2;
    private global::Hedera.Hashgraph.Proto.FixedFee fallbackFee_;
    /// <summary>
    ///*
    /// A fixed fee to assess if no fungible value is known to be traded
    /// for the NFT.
    /// &lt;p>
    /// If an NFT is transferred without a corresponding transfer of
    /// _fungible_ value returned in the same transaction, the network
    /// SHALL charge this fee as a fallback.&lt;br/>
    /// Fallback fees MAY have unexpected effects when interacting with
    /// escrow, market transfers, and smart contracts.
    /// It is RECOMMENDED that developers carefully consider possible
    /// effects from fallback fees when designing systems that facilitate
    /// the transfer of NFTs.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Hedera.Hashgraph.Proto.FixedFee FallbackFee {
      get { return fallbackFee_; }
      set {
        fallbackFee_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as RoyaltyFee);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(RoyaltyFee other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(ExchangeValueFraction, other.ExchangeValueFraction)) return false;
      if (!object.Equals(FallbackFee, other.FallbackFee)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (exchangeValueFraction_ != null) hash ^= ExchangeValueFraction.GetHashCode();
      if (fallbackFee_ != null) hash ^= FallbackFee.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (exchangeValueFraction_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(ExchangeValueFraction);
      }
      if (fallbackFee_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(FallbackFee);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (exchangeValueFraction_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(ExchangeValueFraction);
      }
      if (fallbackFee_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(FallbackFee);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (exchangeValueFraction_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ExchangeValueFraction);
      }
      if (fallbackFee_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(FallbackFee);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(RoyaltyFee other) {
      if (other == null) {
        return;
      }
      if (other.exchangeValueFraction_ != null) {
        if (exchangeValueFraction_ == null) {
          ExchangeValueFraction = new global::Hedera.Hashgraph.Proto.Fraction();
        }
        ExchangeValueFraction.MergeFrom(other.ExchangeValueFraction);
      }
      if (other.fallbackFee_ != null) {
        if (fallbackFee_ == null) {
          FallbackFee = new global::Hedera.Hashgraph.Proto.FixedFee();
        }
        FallbackFee.MergeFrom(other.FallbackFee);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (exchangeValueFraction_ == null) {
              ExchangeValueFraction = new global::Hedera.Hashgraph.Proto.Fraction();
            }
            input.ReadMessage(ExchangeValueFraction);
            break;
          }
          case 18: {
            if (fallbackFee_ == null) {
              FallbackFee = new global::Hedera.Hashgraph.Proto.FixedFee();
            }
            input.ReadMessage(FallbackFee);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (exchangeValueFraction_ == null) {
              ExchangeValueFraction = new global::Hedera.Hashgraph.Proto.Fraction();
            }
            input.ReadMessage(ExchangeValueFraction);
            break;
          }
          case 18: {
            if (fallbackFee_ == null) {
              FallbackFee = new global::Hedera.Hashgraph.Proto.FixedFee();
            }
            input.ReadMessage(FallbackFee);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// A transfer fee to assess during a CryptoTransfer.&lt;br/>
  /// This fee applies to transactions that transfer units of the token to
  /// which the fee is attached. A custom fee may be either fixed or fractional,
  /// and must specify a fee collector account to receive the assessed fees.
  ///
  /// Custom fees MUST be greater than zero (0).
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class CustomFee : pb::IMessage<CustomFee>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<CustomFee> _parser = new pb::MessageParser<CustomFee>(() => new CustomFee());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<CustomFee> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Hedera.Hashgraph.Proto.CustomFeesReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public CustomFee() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public CustomFee(CustomFee other) : this() {
      feeCollectorAccountId_ = other.feeCollectorAccountId_ != null ? other.feeCollectorAccountId_.Clone() : null;
      allCollectorsAreExempt_ = other.allCollectorsAreExempt_;
      switch (other.FeeCase) {
        case FeeOneofCase.FixedFee:
          FixedFee = other.FixedFee.Clone();
          break;
        case FeeOneofCase.FractionalFee:
          FractionalFee = other.FractionalFee.Clone();
          break;
        case FeeOneofCase.RoyaltyFee:
          RoyaltyFee = other.RoyaltyFee.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public CustomFee Clone() {
      return new CustomFee(this);
    }

    /// <summary>Field number for the "fixed_fee" field.</summary>
    public const int FixedFeeFieldNumber = 1;
    /// <summary>
    ///*
    /// A fixed fee to be charged to the `sender` for every token transfer.
    /// &lt;p>
    /// This type of fee MAY be defined for any token type.&lt;br/>
    /// This type of fee MAY be more consistent and reliable than
    /// other types.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Hedera.Hashgraph.Proto.FixedFee FixedFee {
      get { return feeCase_ == FeeOneofCase.FixedFee ? (global::Hedera.Hashgraph.Proto.FixedFee) fee_ : null; }
      set {
        fee_ = value;
        feeCase_ = value == null ? FeeOneofCase.None : FeeOneofCase.FixedFee;
      }
    }

    /// <summary>Field number for the "fractional_fee" field.</summary>
    public const int FractionalFeeFieldNumber = 2;
    /// <summary>
    ///*
    /// A fee defined as a fraction of the tokens transferred.
    /// &lt;p>
    /// This type of fee MUST NOT be defined for a non-fungible/unique
    /// token type.&lt;br/>
    /// This fee MAY be charged to either sender, as an increase to the
    /// amount sent, or receiver, as a reduction to the amount received.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Hedera.Hashgraph.Proto.FractionalFee FractionalFee {
      get { return feeCase_ == FeeOneofCase.FractionalFee ? (global::Hedera.Hashgraph.Proto.FractionalFee) fee_ : null; }
      set {
        fee_ = value;
        feeCase_ = value == null ? FeeOneofCase.None : FeeOneofCase.FractionalFee;
      }
    }

    /// <summary>Field number for the "royalty_fee" field.</summary>
    public const int RoyaltyFeeFieldNumber = 4;
    /// <summary>
    ///*
    /// A fee charged as royalty for any transfer of a
    /// non-fungible/unique token.
    /// &lt;p>
    /// This type of fee MUST NOT be defined for a
    /// fungible/common token type.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Hedera.Hashgraph.Proto.RoyaltyFee RoyaltyFee {
      get { return feeCase_ == FeeOneofCase.RoyaltyFee ? (global::Hedera.Hashgraph.Proto.RoyaltyFee) fee_ : null; }
      set {
        fee_ = value;
        feeCase_ = value == null ? FeeOneofCase.None : FeeOneofCase.RoyaltyFee;
      }
    }

    /// <summary>Field number for the "fee_collector_account_id" field.</summary>
    public const int FeeCollectorAccountIdFieldNumber = 3;
    private global::Hedera.Hashgraph.Proto.AccountID feeCollectorAccountId_;
    /// <summary>
    ///*
    /// The account to receive the custom fee.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Hedera.Hashgraph.Proto.AccountID FeeCollectorAccountId {
      get { return feeCollectorAccountId_; }
      set {
        feeCollectorAccountId_ = value;
      }
    }

    /// <summary>Field number for the "all_collectors_are_exempt" field.</summary>
    public const int AllCollectorsAreExemptFieldNumber = 5;
    private bool allCollectorsAreExempt_;
    /// <summary>
    ///*
    /// Flag indicating to exempt all custom fee collector accounts for this
    /// token type from paying this custom fee when sending tokens.
    /// &lt;p>
    /// The treasury account for a token, and the account identified by the
    /// `fee_collector_account_id` field of this `CustomFee` are always exempt
    /// from this custom fee to avoid redundant and unnecessary transfers.
    /// If this value is `true` then the account(s) identified in
    /// `fee_collector_account_id` for _all_ custom fee definitions for this
    /// token type SHALL also be exempt from this custom fee.
    /// This behavior is specified in HIP-573.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool AllCollectorsAreExempt {
      get { return allCollectorsAreExempt_; }
      set {
        allCollectorsAreExempt_ = value;
      }
    }

    private object fee_;
    /// <summary>Enum of possible cases for the "fee" oneof.</summary>
    public enum FeeOneofCase {
      None = 0,
      FixedFee = 1,
      FractionalFee = 2,
      RoyaltyFee = 4,
    }
    private FeeOneofCase feeCase_ = FeeOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public FeeOneofCase FeeCase {
      get { return feeCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearFee() {
      feeCase_ = FeeOneofCase.None;
      fee_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as CustomFee);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(CustomFee other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(FixedFee, other.FixedFee)) return false;
      if (!object.Equals(FractionalFee, other.FractionalFee)) return false;
      if (!object.Equals(RoyaltyFee, other.RoyaltyFee)) return false;
      if (!object.Equals(FeeCollectorAccountId, other.FeeCollectorAccountId)) return false;
      if (AllCollectorsAreExempt != other.AllCollectorsAreExempt) return false;
      if (FeeCase != other.FeeCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (feeCase_ == FeeOneofCase.FixedFee) hash ^= FixedFee.GetHashCode();
      if (feeCase_ == FeeOneofCase.FractionalFee) hash ^= FractionalFee.GetHashCode();
      if (feeCase_ == FeeOneofCase.RoyaltyFee) hash ^= RoyaltyFee.GetHashCode();
      if (feeCollectorAccountId_ != null) hash ^= FeeCollectorAccountId.GetHashCode();
      if (AllCollectorsAreExempt != false) hash ^= AllCollectorsAreExempt.GetHashCode();
      hash ^= (int) feeCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (feeCase_ == FeeOneofCase.FixedFee) {
        output.WriteRawTag(10);
        output.WriteMessage(FixedFee);
      }
      if (feeCase_ == FeeOneofCase.FractionalFee) {
        output.WriteRawTag(18);
        output.WriteMessage(FractionalFee);
      }
      if (feeCollectorAccountId_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(FeeCollectorAccountId);
      }
      if (feeCase_ == FeeOneofCase.RoyaltyFee) {
        output.WriteRawTag(34);
        output.WriteMessage(RoyaltyFee);
      }
      if (AllCollectorsAreExempt != false) {
        output.WriteRawTag(40);
        output.WriteBool(AllCollectorsAreExempt);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (feeCase_ == FeeOneofCase.FixedFee) {
        output.WriteRawTag(10);
        output.WriteMessage(FixedFee);
      }
      if (feeCase_ == FeeOneofCase.FractionalFee) {
        output.WriteRawTag(18);
        output.WriteMessage(FractionalFee);
      }
      if (feeCollectorAccountId_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(FeeCollectorAccountId);
      }
      if (feeCase_ == FeeOneofCase.RoyaltyFee) {
        output.WriteRawTag(34);
        output.WriteMessage(RoyaltyFee);
      }
      if (AllCollectorsAreExempt != false) {
        output.WriteRawTag(40);
        output.WriteBool(AllCollectorsAreExempt);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (feeCase_ == FeeOneofCase.FixedFee) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(FixedFee);
      }
      if (feeCase_ == FeeOneofCase.FractionalFee) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(FractionalFee);
      }
      if (feeCase_ == FeeOneofCase.RoyaltyFee) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RoyaltyFee);
      }
      if (feeCollectorAccountId_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(FeeCollectorAccountId);
      }
      if (AllCollectorsAreExempt != false) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(CustomFee other) {
      if (other == null) {
        return;
      }
      if (other.feeCollectorAccountId_ != null) {
        if (feeCollectorAccountId_ == null) {
          FeeCollectorAccountId = new global::Hedera.Hashgraph.Proto.AccountID();
        }
        FeeCollectorAccountId.MergeFrom(other.FeeCollectorAccountId);
      }
      if (other.AllCollectorsAreExempt != false) {
        AllCollectorsAreExempt = other.AllCollectorsAreExempt;
      }
      switch (other.FeeCase) {
        case FeeOneofCase.FixedFee:
          if (FixedFee == null) {
            FixedFee = new global::Hedera.Hashgraph.Proto.FixedFee();
          }
          FixedFee.MergeFrom(other.FixedFee);
          break;
        case FeeOneofCase.FractionalFee:
          if (FractionalFee == null) {
            FractionalFee = new global::Hedera.Hashgraph.Proto.FractionalFee();
          }
          FractionalFee.MergeFrom(other.FractionalFee);
          break;
        case FeeOneofCase.RoyaltyFee:
          if (RoyaltyFee == null) {
            RoyaltyFee = new global::Hedera.Hashgraph.Proto.RoyaltyFee();
          }
          RoyaltyFee.MergeFrom(other.RoyaltyFee);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            global::Hedera.Hashgraph.Proto.FixedFee subBuilder = new global::Hedera.Hashgraph.Proto.FixedFee();
            if (feeCase_ == FeeOneofCase.FixedFee) {
              subBuilder.MergeFrom(FixedFee);
            }
            input.ReadMessage(subBuilder);
            FixedFee = subBuilder;
            break;
          }
          case 18: {
            global::Hedera.Hashgraph.Proto.FractionalFee subBuilder = new global::Hedera.Hashgraph.Proto.FractionalFee();
            if (feeCase_ == FeeOneofCase.FractionalFee) {
              subBuilder.MergeFrom(FractionalFee);
            }
            input.ReadMessage(subBuilder);
            FractionalFee = subBuilder;
            break;
          }
          case 26: {
            if (feeCollectorAccountId_ == null) {
              FeeCollectorAccountId = new global::Hedera.Hashgraph.Proto.AccountID();
            }
            input.ReadMessage(FeeCollectorAccountId);
            break;
          }
          case 34: {
            global::Hedera.Hashgraph.Proto.RoyaltyFee subBuilder = new global::Hedera.Hashgraph.Proto.RoyaltyFee();
            if (feeCase_ == FeeOneofCase.RoyaltyFee) {
              subBuilder.MergeFrom(RoyaltyFee);
            }
            input.ReadMessage(subBuilder);
            RoyaltyFee = subBuilder;
            break;
          }
          case 40: {
            AllCollectorsAreExempt = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            global::Hedera.Hashgraph.Proto.FixedFee subBuilder = new global::Hedera.Hashgraph.Proto.FixedFee();
            if (feeCase_ == FeeOneofCase.FixedFee) {
              subBuilder.MergeFrom(FixedFee);
            }
            input.ReadMessage(subBuilder);
            FixedFee = subBuilder;
            break;
          }
          case 18: {
            global::Hedera.Hashgraph.Proto.FractionalFee subBuilder = new global::Hedera.Hashgraph.Proto.FractionalFee();
            if (feeCase_ == FeeOneofCase.FractionalFee) {
              subBuilder.MergeFrom(FractionalFee);
            }
            input.ReadMessage(subBuilder);
            FractionalFee = subBuilder;
            break;
          }
          case 26: {
            if (feeCollectorAccountId_ == null) {
              FeeCollectorAccountId = new global::Hedera.Hashgraph.Proto.AccountID();
            }
            input.ReadMessage(FeeCollectorAccountId);
            break;
          }
          case 34: {
            global::Hedera.Hashgraph.Proto.RoyaltyFee subBuilder = new global::Hedera.Hashgraph.Proto.RoyaltyFee();
            if (feeCase_ == FeeOneofCase.RoyaltyFee) {
              subBuilder.MergeFrom(RoyaltyFee);
            }
            input.ReadMessage(subBuilder);
            RoyaltyFee = subBuilder;
            break;
          }
          case 40: {
            AllCollectorsAreExempt = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// Description of a transfer added to a `cryptoTransfer` transaction that
  /// satisfies custom fee requirements.
  ///
  /// It is important to note that this is not the actual transfer. The transfer
  /// of value SHALL be merged into the original transaction to minimize the
  /// number of actual transfers. This descriptor presents the fee assessed
  /// separately in the record stream so that the details of the fee assessed
  /// are not hidden in this process.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class AssessedCustomFee : pb::IMessage<AssessedCustomFee>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<AssessedCustomFee> _parser = new pb::MessageParser<AssessedCustomFee>(() => new AssessedCustomFee());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<AssessedCustomFee> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Hedera.Hashgraph.Proto.CustomFeesReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AssessedCustomFee() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AssessedCustomFee(AssessedCustomFee other) : this() {
      amount_ = other.amount_;
      tokenId_ = other.tokenId_ != null ? other.tokenId_.Clone() : null;
      feeCollectorAccountId_ = other.feeCollectorAccountId_ != null ? other.feeCollectorAccountId_.Clone() : null;
      effectivePayerAccountId_ = other.effectivePayerAccountId_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AssessedCustomFee Clone() {
      return new AssessedCustomFee(this);
    }

    /// <summary>Field number for the "amount" field.</summary>
    public const int AmountFieldNumber = 1;
    private long amount_;
    /// <summary>
    ///*
    /// An amount of tokens assessed for this custom fee.
    /// &lt;p>
    /// This shall be expressed in units of 10&lt;sup>-decimals&lt;/sup> tokens.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long Amount {
      get { return amount_; }
      set {
        amount_ = value;
      }
    }

    /// <summary>Field number for the "token_id" field.</summary>
    public const int TokenIdFieldNumber = 2;
    private global::Hedera.Hashgraph.Proto.TokenID tokenId_;
    /// <summary>
    ///*
    /// The token transferred to satisfy this fee.
    /// &lt;p>
    /// If the token transferred is HBAR, this field SHALL NOT be set.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Hedera.Hashgraph.Proto.TokenID TokenId {
      get { return tokenId_; }
      set {
        tokenId_ = value;
      }
    }

    /// <summary>Field number for the "fee_collector_account_id" field.</summary>
    public const int FeeCollectorAccountIdFieldNumber = 3;
    private global::Hedera.Hashgraph.Proto.AccountID feeCollectorAccountId_;
    /// <summary>
    ///*
    /// An account that received the fee assessed.
    /// &lt;p>
    /// This SHALL NOT be the sender or receiver of the original
    /// cryptoTransfer transaction.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Hedera.Hashgraph.Proto.AccountID FeeCollectorAccountId {
      get { return feeCollectorAccountId_; }
      set {
        feeCollectorAccountId_ = value;
      }
    }

    /// <summary>Field number for the "effective_payer_account_id" field.</summary>
    public const int EffectivePayerAccountIdFieldNumber = 4;
    private static readonly pb::FieldCodec<global::Hedera.Hashgraph.Proto.AccountID> _repeated_effectivePayerAccountId_codec
        = pb::FieldCodec.ForMessage(34, global::Hedera.Hashgraph.Proto.AccountID.Parser);
    private readonly pbc::RepeatedField<global::Hedera.Hashgraph.Proto.AccountID> effectivePayerAccountId_ = new pbc::RepeatedField<global::Hedera.Hashgraph.Proto.AccountID>();
    /// <summary>
    ///*
    /// An account that provided the tokens assessed as a fee.
    /// &lt;p>
    /// This SHALL be the account that _would have_ had a higher balance
    /// absent the fee. In most cases this SHALL be the `sender`, but
    /// some _fractional_ fees reduce the amount transferred, and in those
    /// cases the `receiver` SHALL be the effective payer for the fee.&lt;br/>
    /// There are currently no situations where a third party pays a custom
    /// fee. This MAY change in a future release.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Hedera.Hashgraph.Proto.AccountID> EffectivePayerAccountId {
      get { return effectivePayerAccountId_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as AssessedCustomFee);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(AssessedCustomFee other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Amount != other.Amount) return false;
      if (!object.Equals(TokenId, other.TokenId)) return false;
      if (!object.Equals(FeeCollectorAccountId, other.FeeCollectorAccountId)) return false;
      if(!effectivePayerAccountId_.Equals(other.effectivePayerAccountId_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Amount != 0L) hash ^= Amount.GetHashCode();
      if (tokenId_ != null) hash ^= TokenId.GetHashCode();
      if (feeCollectorAccountId_ != null) hash ^= FeeCollectorAccountId.GetHashCode();
      hash ^= effectivePayerAccountId_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Amount != 0L) {
        output.WriteRawTag(8);
        output.WriteInt64(Amount);
      }
      if (tokenId_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(TokenId);
      }
      if (feeCollectorAccountId_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(FeeCollectorAccountId);
      }
      effectivePayerAccountId_.WriteTo(output, _repeated_effectivePayerAccountId_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Amount != 0L) {
        output.WriteRawTag(8);
        output.WriteInt64(Amount);
      }
      if (tokenId_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(TokenId);
      }
      if (feeCollectorAccountId_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(FeeCollectorAccountId);
      }
      effectivePayerAccountId_.WriteTo(ref output, _repeated_effectivePayerAccountId_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Amount != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(Amount);
      }
      if (tokenId_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TokenId);
      }
      if (feeCollectorAccountId_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(FeeCollectorAccountId);
      }
      size += effectivePayerAccountId_.CalculateSize(_repeated_effectivePayerAccountId_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(AssessedCustomFee other) {
      if (other == null) {
        return;
      }
      if (other.Amount != 0L) {
        Amount = other.Amount;
      }
      if (other.tokenId_ != null) {
        if (tokenId_ == null) {
          TokenId = new global::Hedera.Hashgraph.Proto.TokenID();
        }
        TokenId.MergeFrom(other.TokenId);
      }
      if (other.feeCollectorAccountId_ != null) {
        if (feeCollectorAccountId_ == null) {
          FeeCollectorAccountId = new global::Hedera.Hashgraph.Proto.AccountID();
        }
        FeeCollectorAccountId.MergeFrom(other.FeeCollectorAccountId);
      }
      effectivePayerAccountId_.Add(other.effectivePayerAccountId_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Amount = input.ReadInt64();
            break;
          }
          case 18: {
            if (tokenId_ == null) {
              TokenId = new global::Hedera.Hashgraph.Proto.TokenID();
            }
            input.ReadMessage(TokenId);
            break;
          }
          case 26: {
            if (feeCollectorAccountId_ == null) {
              FeeCollectorAccountId = new global::Hedera.Hashgraph.Proto.AccountID();
            }
            input.ReadMessage(FeeCollectorAccountId);
            break;
          }
          case 34: {
            effectivePayerAccountId_.AddEntriesFrom(input, _repeated_effectivePayerAccountId_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Amount = input.ReadInt64();
            break;
          }
          case 18: {
            if (tokenId_ == null) {
              TokenId = new global::Hedera.Hashgraph.Proto.TokenID();
            }
            input.ReadMessage(TokenId);
            break;
          }
          case 26: {
            if (feeCollectorAccountId_ == null) {
              FeeCollectorAccountId = new global::Hedera.Hashgraph.Proto.AccountID();
            }
            input.ReadMessage(FeeCollectorAccountId);
            break;
          }
          case 34: {
            effectivePayerAccountId_.AddEntriesFrom(ref input, _repeated_effectivePayerAccountId_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// A custom fee definition for a consensus topic.
  /// &lt;p>
  /// This fee definition is specific to an Hedera Consensus Service (HCS) topic
  /// and SHOULD NOT be used in any other context.&lt;br/>
  /// All fields for this message are REQUIRED.&lt;br/>
  /// Only "fixed" fee definitions are supported because there is no basis for
  /// a fractional fee on a consensus submit transaction.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class FixedCustomFee : pb::IMessage<FixedCustomFee>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<FixedCustomFee> _parser = new pb::MessageParser<FixedCustomFee>(() => new FixedCustomFee());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<FixedCustomFee> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Hedera.Hashgraph.Proto.CustomFeesReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public FixedCustomFee() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public FixedCustomFee(FixedCustomFee other) : this() {
      fixedFee_ = other.fixedFee_ != null ? other.fixedFee_.Clone() : null;
      feeCollectorAccountId_ = other.feeCollectorAccountId_ != null ? other.feeCollectorAccountId_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public FixedCustomFee Clone() {
      return new FixedCustomFee(this);
    }

    /// <summary>Field number for the "fixed_fee" field.</summary>
    public const int FixedFeeFieldNumber = 1;
    private global::Hedera.Hashgraph.Proto.FixedFee fixedFee_;
    /// <summary>
    ///*
    /// A fixed custom fee.
    /// &lt;p>
    /// The amount of HBAR or other token described by this `FixedFee` SHALL
    /// be charged to the transction payer for each message submitted to a
    /// topic that assigns this consensus custom fee.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Hedera.Hashgraph.Proto.FixedFee FixedFee {
      get { return fixedFee_; }
      set {
        fixedFee_ = value;
      }
    }

    /// <summary>Field number for the "fee_collector_account_id" field.</summary>
    public const int FeeCollectorAccountIdFieldNumber = 2;
    private global::Hedera.Hashgraph.Proto.AccountID feeCollectorAccountId_;
    /// <summary>
    ///*
    /// A collection account identifier.
    /// &lt;p>
    /// All amounts collected for this consensus custom fee SHALL be transferred
    /// to the account identified by this field.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Hedera.Hashgraph.Proto.AccountID FeeCollectorAccountId {
      get { return feeCollectorAccountId_; }
      set {
        feeCollectorAccountId_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as FixedCustomFee);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(FixedCustomFee other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(FixedFee, other.FixedFee)) return false;
      if (!object.Equals(FeeCollectorAccountId, other.FeeCollectorAccountId)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (fixedFee_ != null) hash ^= FixedFee.GetHashCode();
      if (feeCollectorAccountId_ != null) hash ^= FeeCollectorAccountId.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (fixedFee_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(FixedFee);
      }
      if (feeCollectorAccountId_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(FeeCollectorAccountId);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (fixedFee_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(FixedFee);
      }
      if (feeCollectorAccountId_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(FeeCollectorAccountId);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (fixedFee_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(FixedFee);
      }
      if (feeCollectorAccountId_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(FeeCollectorAccountId);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(FixedCustomFee other) {
      if (other == null) {
        return;
      }
      if (other.fixedFee_ != null) {
        if (fixedFee_ == null) {
          FixedFee = new global::Hedera.Hashgraph.Proto.FixedFee();
        }
        FixedFee.MergeFrom(other.FixedFee);
      }
      if (other.feeCollectorAccountId_ != null) {
        if (feeCollectorAccountId_ == null) {
          FeeCollectorAccountId = new global::Hedera.Hashgraph.Proto.AccountID();
        }
        FeeCollectorAccountId.MergeFrom(other.FeeCollectorAccountId);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (fixedFee_ == null) {
              FixedFee = new global::Hedera.Hashgraph.Proto.FixedFee();
            }
            input.ReadMessage(FixedFee);
            break;
          }
          case 18: {
            if (feeCollectorAccountId_ == null) {
              FeeCollectorAccountId = new global::Hedera.Hashgraph.Proto.AccountID();
            }
            input.ReadMessage(FeeCollectorAccountId);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (fixedFee_ == null) {
              FixedFee = new global::Hedera.Hashgraph.Proto.FixedFee();
            }
            input.ReadMessage(FixedFee);
            break;
          }
          case 18: {
            if (feeCollectorAccountId_ == null) {
              FeeCollectorAccountId = new global::Hedera.Hashgraph.Proto.AccountID();
            }
            input.ReadMessage(FeeCollectorAccountId);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// A wrapper around a consensus custom fee list.&lt;br/>
  /// This wrapper exists to enable an update transaction to differentiate between
  ///  a field that is not set and an empty list of custom fees.
  /// &lt;p>
  /// An _unset_ field of this type SHALL NOT modify existing values.&lt;br/>
  /// A _set_ field of this type with an empty `fees` list SHALL remove any
  ///  existing values.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class FixedCustomFeeList : pb::IMessage<FixedCustomFeeList>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<FixedCustomFeeList> _parser = new pb::MessageParser<FixedCustomFeeList>(() => new FixedCustomFeeList());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<FixedCustomFeeList> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Hedera.Hashgraph.Proto.CustomFeesReflection.Descriptor.MessageTypes[6]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public FixedCustomFeeList() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public FixedCustomFeeList(FixedCustomFeeList other) : this() {
      fees_ = other.fees_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public FixedCustomFeeList Clone() {
      return new FixedCustomFeeList(this);
    }

    /// <summary>Field number for the "fees" field.</summary>
    public const int FeesFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Hedera.Hashgraph.Proto.FixedCustomFee> _repeated_fees_codec
        = pb::FieldCodec.ForMessage(10, global::Hedera.Hashgraph.Proto.FixedCustomFee.Parser);
    private readonly pbc::RepeatedField<global::Hedera.Hashgraph.Proto.FixedCustomFee> fees_ = new pbc::RepeatedField<global::Hedera.Hashgraph.Proto.FixedCustomFee>();
    /// <summary>
    ///*
    /// A set of custom fee definitions.&lt;br/>
    /// These are fees to be assessed for each submit to a topic.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Hedera.Hashgraph.Proto.FixedCustomFee> Fees {
      get { return fees_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as FixedCustomFeeList);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(FixedCustomFeeList other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!fees_.Equals(other.fees_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= fees_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      fees_.WriteTo(output, _repeated_fees_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      fees_.WriteTo(ref output, _repeated_fees_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += fees_.CalculateSize(_repeated_fees_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(FixedCustomFeeList other) {
      if (other == null) {
        return;
      }
      fees_.Add(other.fees_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            fees_.AddEntriesFrom(input, _repeated_fees_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            fees_.AddEntriesFrom(ref input, _repeated_fees_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// A wrapper for fee exempt key list.&lt;br/>
  /// This wrapper exists to enable an update transaction to differentiate between
  /// a field that is not set and an empty list of keys.
  /// &lt;p>
  /// An _unset_ field of this type SHALL NOT modify existing values.&lt;br/>
  /// A _set_ field of this type with an empty `keys` list SHALL remove any
  /// existing values.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class FeeExemptKeyList : pb::IMessage<FeeExemptKeyList>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<FeeExemptKeyList> _parser = new pb::MessageParser<FeeExemptKeyList>(() => new FeeExemptKeyList());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<FeeExemptKeyList> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Hedera.Hashgraph.Proto.CustomFeesReflection.Descriptor.MessageTypes[7]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public FeeExemptKeyList() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public FeeExemptKeyList(FeeExemptKeyList other) : this() {
      keys_ = other.keys_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public FeeExemptKeyList Clone() {
      return new FeeExemptKeyList(this);
    }

    /// <summary>Field number for the "keys" field.</summary>
    public const int KeysFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Hedera.Hashgraph.Proto.Key> _repeated_keys_codec
        = pb::FieldCodec.ForMessage(10, global::Hedera.Hashgraph.Proto.Key.Parser);
    private readonly pbc::RepeatedField<global::Hedera.Hashgraph.Proto.Key> keys_ = new pbc::RepeatedField<global::Hedera.Hashgraph.Proto.Key>();
    /// <summary>
    ///*
    /// A set of keys.&lt;br/>
    /// The keys in this list are permitted to submit messages to the
    /// topic without paying the topic's custom fees.
    /// &lt;p>
    /// If a submit transaction is signed by _any_ key included in this set,
    /// custom fees SHALL NOT be charged for that transaction.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Hedera.Hashgraph.Proto.Key> Keys {
      get { return keys_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as FeeExemptKeyList);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(FeeExemptKeyList other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!keys_.Equals(other.keys_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= keys_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      keys_.WriteTo(output, _repeated_keys_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      keys_.WriteTo(ref output, _repeated_keys_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += keys_.CalculateSize(_repeated_keys_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(FeeExemptKeyList other) {
      if (other == null) {
        return;
      }
      keys_.Add(other.keys_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            keys_.AddEntriesFrom(input, _repeated_keys_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            keys_.AddEntriesFrom(ref input, _repeated_keys_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// A maximum custom fee that the user is willing to pay.
  /// &lt;p>
  /// This message is used to specify the maximum custom fee that given user is
  /// willing to pay.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class CustomFeeLimit : pb::IMessage<CustomFeeLimit>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<CustomFeeLimit> _parser = new pb::MessageParser<CustomFeeLimit>(() => new CustomFeeLimit());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<CustomFeeLimit> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Hedera.Hashgraph.Proto.CustomFeesReflection.Descriptor.MessageTypes[8]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public CustomFeeLimit() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public CustomFeeLimit(CustomFeeLimit other) : this() {
      accountId_ = other.accountId_ != null ? other.accountId_.Clone() : null;
      fees_ = other.fees_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public CustomFeeLimit Clone() {
      return new CustomFeeLimit(this);
    }

    /// <summary>Field number for the "account_id" field.</summary>
    public const int AccountIdFieldNumber = 1;
    private global::Hedera.Hashgraph.Proto.AccountID accountId_;
    /// <summary>
    ///*
    /// A payer account identifier.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Hedera.Hashgraph.Proto.AccountID AccountId {
      get { return accountId_; }
      set {
        accountId_ = value;
      }
    }

    /// <summary>Field number for the "fees" field.</summary>
    public const int FeesFieldNumber = 2;
    private static readonly pb::FieldCodec<global::Hedera.Hashgraph.Proto.FixedFee> _repeated_fees_codec
        = pb::FieldCodec.ForMessage(18, global::Hedera.Hashgraph.Proto.FixedFee.Parser);
    private readonly pbc::RepeatedField<global::Hedera.Hashgraph.Proto.FixedFee> fees_ = new pbc::RepeatedField<global::Hedera.Hashgraph.Proto.FixedFee>();
    /// <summary>
    ///*
    /// The maximum fees that the user is willing to pay for the message.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Hedera.Hashgraph.Proto.FixedFee> Fees {
      get { return fees_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as CustomFeeLimit);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(CustomFeeLimit other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(AccountId, other.AccountId)) return false;
      if(!fees_.Equals(other.fees_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (accountId_ != null) hash ^= AccountId.GetHashCode();
      hash ^= fees_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (accountId_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(AccountId);
      }
      fees_.WriteTo(output, _repeated_fees_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (accountId_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(AccountId);
      }
      fees_.WriteTo(ref output, _repeated_fees_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (accountId_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(AccountId);
      }
      size += fees_.CalculateSize(_repeated_fees_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(CustomFeeLimit other) {
      if (other == null) {
        return;
      }
      if (other.accountId_ != null) {
        if (accountId_ == null) {
          AccountId = new global::Hedera.Hashgraph.Proto.AccountID();
        }
        AccountId.MergeFrom(other.AccountId);
      }
      fees_.Add(other.fees_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (accountId_ == null) {
              AccountId = new global::Hedera.Hashgraph.Proto.AccountID();
            }
            input.ReadMessage(AccountId);
            break;
          }
          case 18: {
            fees_.AddEntriesFrom(input, _repeated_fees_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (accountId_ == null) {
              AccountId = new global::Hedera.Hashgraph.Proto.AccountID();
            }
            input.ReadMessage(AccountId);
            break;
          }
          case 18: {
            fees_.AddEntriesFrom(ref input, _repeated_fees_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  #endregion

}

#endregion Designer generated code
