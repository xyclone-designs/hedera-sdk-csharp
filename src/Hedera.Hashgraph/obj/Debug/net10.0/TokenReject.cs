// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: token_reject.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021, 8981
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Proto {

  /// <summary>Holder for reflection information generated from token_reject.proto</summary>
  public static partial class TokenRejectReflection {

    #region Descriptor
    /// <summary>File descriptor for token_reject.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static TokenRejectReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "ChJ0b2tlbl9yZWplY3QucHJvdG8SBXByb3RvGhFiYXNpY190eXBlcy5wcm90",
            "byJoChpUb2tlblJlamVjdFRyYW5zYWN0aW9uQm9keRIfCgVvd25lchgBIAEo",
            "CzIQLnByb3RvLkFjY291bnRJRBIpCgpyZWplY3Rpb25zGAIgAygLMhUucHJv",
            "dG8uVG9rZW5SZWZlcmVuY2UiawoOVG9rZW5SZWZlcmVuY2USKAoOZnVuZ2li",
            "bGVfdG9rZW4YASABKAsyDi5wcm90by5Ub2tlbklESAASGwoDbmZ0GAIgASgL",
            "MgwucHJvdG8uTmZ0SURIAEISChB0b2tlbl9pZGVudGlmaWVyQiIKHmNvbS5o",
            "ZWRlcmEuaGFzaGdyYXBoLnNkay5wcm90b1ABYgZwcm90bzM="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Proto.BasicTypesReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Proto.TokenRejectTransactionBody), global::Proto.TokenRejectTransactionBody.Parser, new[]{ "Owner", "Rejections" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Proto.TokenReference), global::Proto.TokenReference.Parser, new[]{ "FungibleToken", "Nft" }, new[]{ "TokenIdentifier" }, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  ///*
  /// Reject undesired token(s).&lt;br/>
  /// Transfer one or more token balances held by the requesting account to the
  /// treasury for each token type.
  ///
  /// Each transfer SHALL be one of the following
  /// - A single non-fungible/unique token.
  /// - The full balance held for a fungible/common token.
  /// A single `tokenReject` transaction SHALL support a maximum
  /// of 10 transfers.&lt;br/>
  /// A token that is `pause`d MUST NOT be rejected.&lt;br/>
  /// If the `owner` account is `frozen` with respect to the identified token(s)
  /// the token(s) MUST NOT be rejected.&lt;br/>
  /// The `payer` for this transaction, and `owner` if set, SHALL NOT be charged
  /// any custom fees or other fees beyond the `tokenReject` transaction fee.
  ///
  /// ### Block Stream Effects
  /// - Each successful transfer from `payer` to `treasury` SHALL be recorded in
  ///   the `token_transfer_list` for the transaction record.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class TokenRejectTransactionBody : pb::IMessage<TokenRejectTransactionBody>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<TokenRejectTransactionBody> _parser = new pb::MessageParser<TokenRejectTransactionBody>(() => new TokenRejectTransactionBody());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<TokenRejectTransactionBody> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Proto.TokenRejectReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TokenRejectTransactionBody() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TokenRejectTransactionBody(TokenRejectTransactionBody other) : this() {
      owner_ = other.owner_ != null ? other.owner_.Clone() : null;
      rejections_ = other.rejections_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TokenRejectTransactionBody Clone() {
      return new TokenRejectTransactionBody(this);
    }

    /// <summary>Field number for the "owner" field.</summary>
    public const int OwnerFieldNumber = 1;
    private global::Proto.AccountID owner_;
    /// <summary>
    ///*
    /// An account identifier.&lt;br/>
    /// This OPTIONAL field identifies the account holding the
    /// tokens to be rejected.
    /// &lt;p>
    /// If set, this account MUST sign this transaction.
    /// If not set, the `payer` for this transaction SHALL be the effective
    /// `owner` for this transaction.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.AccountID Owner {
      get { return owner_; }
      set {
        owner_ = value;
      }
    }

    /// <summary>Field number for the "rejections" field.</summary>
    public const int RejectionsFieldNumber = 2;
    private static readonly pb::FieldCodec<global::Proto.TokenReference> _repeated_rejections_codec
        = pb::FieldCodec.ForMessage(18, global::Proto.TokenReference.Parser);
    private readonly pbc::RepeatedField<global::Proto.TokenReference> rejections_ = new pbc::RepeatedField<global::Proto.TokenReference>();
    /// <summary>
    ///*
    /// A list of one or more token rejections.
    /// &lt;p>
    /// On success each rejected token serial number or balance SHALL be
    /// transferred from the requesting account to the treasury account for
    /// that token type.&lt;br/>
    /// After rejection the requesting account SHALL continue to be associated
    /// with the token.&lt;br/>
    /// If dissociation is desired then a separate `TokenDissociate` transaction
    /// MUST be submitted to remove the association.&lt;br/>
    /// This list MUST contain at least one (1) entry and MUST NOT contain more
    /// than ten (10) entries.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Proto.TokenReference> Rejections {
      get { return rejections_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as TokenRejectTransactionBody);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(TokenRejectTransactionBody other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Owner, other.Owner)) return false;
      if(!rejections_.Equals(other.rejections_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (owner_ != null) hash ^= Owner.GetHashCode();
      hash ^= rejections_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (owner_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Owner);
      }
      rejections_.WriteTo(output, _repeated_rejections_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (owner_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Owner);
      }
      rejections_.WriteTo(ref output, _repeated_rejections_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (owner_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Owner);
      }
      size += rejections_.CalculateSize(_repeated_rejections_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(TokenRejectTransactionBody other) {
      if (other == null) {
        return;
      }
      if (other.owner_ != null) {
        if (owner_ == null) {
          Owner = new global::Proto.AccountID();
        }
        Owner.MergeFrom(other.Owner);
      }
      rejections_.Add(other.rejections_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (owner_ == null) {
              Owner = new global::Proto.AccountID();
            }
            input.ReadMessage(Owner);
            break;
          }
          case 18: {
            rejections_.AddEntriesFrom(input, _repeated_rejections_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (owner_ == null) {
              Owner = new global::Proto.AccountID();
            }
            input.ReadMessage(Owner);
            break;
          }
          case 18: {
            rejections_.AddEntriesFrom(ref input, _repeated_rejections_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///*
  /// A union token identifier.
  ///
  /// Identify a fungible/common token type, or a single
  /// non-fungible/unique token serial.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class TokenReference : pb::IMessage<TokenReference>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<TokenReference> _parser = new pb::MessageParser<TokenReference>(() => new TokenReference());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<TokenReference> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Proto.TokenRejectReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TokenReference() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TokenReference(TokenReference other) : this() {
      switch (other.TokenIdentifierCase) {
        case TokenIdentifierOneofCase.FungibleToken:
          FungibleToken = other.FungibleToken.Clone();
          break;
        case TokenIdentifierOneofCase.Nft:
          Nft = other.Nft.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TokenReference Clone() {
      return new TokenReference(this);
    }

    /// <summary>Field number for the "fungible_token" field.</summary>
    public const int FungibleTokenFieldNumber = 1;
    /// <summary>
    ///*
    /// A fungible/common token type.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.TokenID FungibleToken {
      get { return tokenIdentifierCase_ == TokenIdentifierOneofCase.FungibleToken ? (global::Proto.TokenID) tokenIdentifier_ : null; }
      set {
        tokenIdentifier_ = value;
        tokenIdentifierCase_ = value == null ? TokenIdentifierOneofCase.None : TokenIdentifierOneofCase.FungibleToken;
      }
    }

    /// <summary>Field number for the "nft" field.</summary>
    public const int NftFieldNumber = 2;
    /// <summary>
    ///*
    /// A single specific serialized non-fungible/unique token.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Proto.NftID Nft {
      get { return tokenIdentifierCase_ == TokenIdentifierOneofCase.Nft ? (global::Proto.NftID) tokenIdentifier_ : null; }
      set {
        tokenIdentifier_ = value;
        tokenIdentifierCase_ = value == null ? TokenIdentifierOneofCase.None : TokenIdentifierOneofCase.Nft;
      }
    }

    private object tokenIdentifier_;
    /// <summary>Enum of possible cases for the "token_identifier" oneof.</summary>
    public enum TokenIdentifierOneofCase {
      None = 0,
      FungibleToken = 1,
      Nft = 2,
    }
    private TokenIdentifierOneofCase tokenIdentifierCase_ = TokenIdentifierOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TokenIdentifierOneofCase TokenIdentifierCase {
      get { return tokenIdentifierCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearTokenIdentifier() {
      tokenIdentifierCase_ = TokenIdentifierOneofCase.None;
      tokenIdentifier_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as TokenReference);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(TokenReference other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(FungibleToken, other.FungibleToken)) return false;
      if (!object.Equals(Nft, other.Nft)) return false;
      if (TokenIdentifierCase != other.TokenIdentifierCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (tokenIdentifierCase_ == TokenIdentifierOneofCase.FungibleToken) hash ^= FungibleToken.GetHashCode();
      if (tokenIdentifierCase_ == TokenIdentifierOneofCase.Nft) hash ^= Nft.GetHashCode();
      hash ^= (int) tokenIdentifierCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (tokenIdentifierCase_ == TokenIdentifierOneofCase.FungibleToken) {
        output.WriteRawTag(10);
        output.WriteMessage(FungibleToken);
      }
      if (tokenIdentifierCase_ == TokenIdentifierOneofCase.Nft) {
        output.WriteRawTag(18);
        output.WriteMessage(Nft);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (tokenIdentifierCase_ == TokenIdentifierOneofCase.FungibleToken) {
        output.WriteRawTag(10);
        output.WriteMessage(FungibleToken);
      }
      if (tokenIdentifierCase_ == TokenIdentifierOneofCase.Nft) {
        output.WriteRawTag(18);
        output.WriteMessage(Nft);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (tokenIdentifierCase_ == TokenIdentifierOneofCase.FungibleToken) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(FungibleToken);
      }
      if (tokenIdentifierCase_ == TokenIdentifierOneofCase.Nft) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Nft);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(TokenReference other) {
      if (other == null) {
        return;
      }
      switch (other.TokenIdentifierCase) {
        case TokenIdentifierOneofCase.FungibleToken:
          if (FungibleToken == null) {
            FungibleToken = new global::Proto.TokenID();
          }
          FungibleToken.MergeFrom(other.FungibleToken);
          break;
        case TokenIdentifierOneofCase.Nft:
          if (Nft == null) {
            Nft = new global::Proto.NftID();
          }
          Nft.MergeFrom(other.Nft);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            global::Proto.TokenID subBuilder = new global::Proto.TokenID();
            if (tokenIdentifierCase_ == TokenIdentifierOneofCase.FungibleToken) {
              subBuilder.MergeFrom(FungibleToken);
            }
            input.ReadMessage(subBuilder);
            FungibleToken = subBuilder;
            break;
          }
          case 18: {
            global::Proto.NftID subBuilder = new global::Proto.NftID();
            if (tokenIdentifierCase_ == TokenIdentifierOneofCase.Nft) {
              subBuilder.MergeFrom(Nft);
            }
            input.ReadMessage(subBuilder);
            Nft = subBuilder;
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            global::Proto.TokenID subBuilder = new global::Proto.TokenID();
            if (tokenIdentifierCase_ == TokenIdentifierOneofCase.FungibleToken) {
              subBuilder.MergeFrom(FungibleToken);
            }
            input.ReadMessage(subBuilder);
            FungibleToken = subBuilder;
            break;
          }
          case 18: {
            global::Proto.NftID subBuilder = new global::Proto.NftID();
            if (tokenIdentifierCase_ == TokenIdentifierOneofCase.Nft) {
              subBuilder.MergeFrom(Nft);
            }
            input.ReadMessage(subBuilder);
            Nft = subBuilder;
            break;
          }
        }
      }
    }
    #endif

  }

  #endregion

}

#endregion Designer generated code
