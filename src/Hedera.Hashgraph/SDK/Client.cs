// SPDX-License-Identifier: Apache-2.0
using Google.Protobuf.WellKnownTypes;
using Hedera.Hashgraph.SDK.Account;
using Hedera.Hashgraph.SDK.Exceptions;
using Hedera.Hashgraph.SDK.File;
using Hedera.Hashgraph.SDK.HBar;
using Hedera.Hashgraph.SDK.Ids;
using Hedera.Hashgraph.SDK.Keys;
using Hedera.Hashgraph.SDK.Logging;
using Hedera.Hashgraph.SDK.Networking;
using Hedera.Hashgraph.SDK.Queries;

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.Json;
using System.Text.Json.Nodes;
using System.Threading;
using System.Threading.Tasks;

namespace Hedera.Hashgraph.SDK
{
	/// <summary>
	/// Managed client for use on the Hedera Hashgraph Network.
	/// </summary>
	public sealed partial class Client : IDisposable
    {
		private readonly ExecutorService executor;
        private readonly AtomicReference<Duration> grpcDeadline = new (DEFAULT_GRPC_DEADLINE);
        private readonly HashSet<SubscriptionHandle> subscriptions = ConcurrentDictionary.NewKeySet();

		private volatile Duration maxBackoff = DEFAULT_MAX_BACKOFF;
		private volatile Duration minBackoff = DEFAULT_MIN_BACKOFF;
 

        private Task NetworkUpdateFuture;
        

        /// <summary>
        /// Constructor.
        /// </summary>
        /// <param name="executor">the executor</param>
        /// <param name="Network">the Network</param>
        /// <param name="mirrorNetwork">the mirror Network</param>
        /// <param name="shouldShutdownExecutor"></param>
        internal Client(ExecutorService executor, Network Network, MirrorNetwork mirrorNetwork, Duration NetworkUpdateInitialDelay, bool shouldShutdownExecutor, Duration NetworkUpdatePeriod, long shard, long realm)
        {
            executor = executor;
            Network = Network;
            mirrorNetwork = mirrorNetwork;
            shouldShutdownExecutor = shouldShutdownExecutor;
            NetworkUpdatePeriod = NetworkUpdatePeriod;
            shard = shard;
            realm = realm;
            ScheduleNetworkUpdate(NetworkUpdateInitialDelay);
        }

		/// <summary>
		/// Extract the executor.
		/// </summary>
		/// <returns>the executor service</returns>
		private static ExecutorService CreateExecutor()
        {
            var threadFactory = new ThreadFactoryBuilder().SetNameFormat("hedera-sdk-%d").SetDaemon(true).Build();
            int nThreads = Runtime.GetRuntime().AvailableProcessors();
            
            return new ThreadPoolExecutor(nThreads, nThreads, 0, TimeUnit.MILLISECONDS, new LinkedBlockingQueue(), threadFactory, new CallerRunsPolicy());
        }

		public Logger Logger_ { get; set; } = new(LogLevel.Silent);
		public Network Network_ { get; internal set; }
		public MirrorNetwork MirrorNetwork_ { get; internal set; }

		/// <summary>
		/// Current name of the Network; corresponds to ledger ID in entity ID checksum calculations.
		/// </summary>
		/// <remarks>@deprecated Use <see cref="LedgerId"/> instead.</remarks>
		public NetworkName NetworkName
		{
			get
			{
				lock (this)
				{
					var ledgerId = Network_.LedgerId;

					return ledgerId.ToNetworkName();
				}
			}
			set
			{
				lock (this)
				{
					Network_.LedgerId = LedgerId.FromNetworkName(value);
				}
			}
		}
		/// <summary>
		/// Replace all nodes in this Client with the nodes in the Address Book
		/// and update the address book if necessary.
		/// </summary>
		public NodeAddressBook NetworkFromAddressBook
		{
			set
			{
				lock (this)
				{
					Network_.SetNetwork(Network.AddressBookToNetwork(value.NodeAddresses));
					Network_.SetAddressBook(value);
				}
			}
		}

		/// <summary>
		/// Enable or disable automatic entity ID checksum validation.
		/// </summary>
		public bool AutoValidateChecksums
		{
			get { lock (this) return field; }
			set
			{
				lock (this)
				{
					field = value;
				}
			}
		}
		/// <summary>
		/// Should the transaction ID be regenerated by default.
		/// </summary>
		public bool DefaultRegenerateTransactionId
		{
			get { lock (this) return field; }
			set
			{
				lock (this)
				{
					field = value;
				}
			}
		} = true;
		/// <summary>
		/// Build the REST base URL for the next healthy mirror node.
		/// Returns a string like `https://host[:port]/api/v1`.
		/// If the selected mirror node is a local host (localhost/127.0.0.1) returns `http://localhost:{5551|8545}/api/v1`.
		/// </summary>
		public string MirrorRestBaseUrl
		{
			get
			{
				try
				{
					return mirrorNetwork.GetRestBaseUrl();
				}
				catch (ThreadInterruptedException e)
				{
					Thread.CurrentThread.Interrupt();
					throw new InvalidOperationException("Interrupted while retrieving mirror base URL", e);
				}
			}
		}
		/// <summary>
		/// Set if transport security should be used to connect to mirror nodes.
		/// <br/>
		/// If transport security is enabled all connections to mirror nodes will use TLS.
		/// </summary>
		/// <remarks>
		/// @deprecated Mirror nodes can only be accessed using TLS.
		/// </remarks>
		public bool MirrorTransportSecurity
		{
			// No-op setter preserved for API compatibility
			set { /* intentionally ignored */ }
		}
		/// <summary>
		/// Is tls enabled for mirror nodes.
		/// </summary>
		public bool MirrorTransportSecurityEnabled
		{
			get => mirrorNetwork.IsTransportSecurity;
		}
		/// <summary>
		/// Is tls enabled for consensus nodes.
		/// </summary>
		public bool TransportSecurity
		{
			get => Network_.TransportSecurity;
			set => Network_.TransportSecurity = value;
		}
		/// <summary>
		/// Is certificate verification enabled.
		/// </summary>
		public bool VerifyCertificates
		{
			get => Network_.VerifyCertificates;
			set => Network_.VerifyCertificates = value;
		}

		/// <summary>
		/// Get the current default realm for new Client instances.
		/// </summary>
		/// <returns>the default realm</returns>
		public long Realm { get; private set; }
		/// <summary>
		/// Get the current default shard for new Client instances.
		/// </summary>
		/// <returns>the default shard</returns>
		public long Shard { get; private set; }

		/// <summary>
		/// Max number of attempts a request executed with this client will do.
		/// </summary>
		public int MaxAttempts
		{
			get { lock (this) return field; }
			set
			{
				lock (this)
				{
					if (value <= 0)
					{
						throw new ArgumentException("MaxAttempts must be greater than zero");
					}

					field = value;
				}
			}
		} = DEFAULT_MAX_ATTEMPTS;
		/// <summary>
		/// Max number of times any node in the Network can receive a bad gRPC status before being removed.
		/// </summary>
		public int MaxNodeAttempts
		{
			get
			{
				lock (this)
				{
					return Network_.GetMaxNodeAttempts();
				}
			}
			set
			{
				lock (this) Network_.MaxNodeAttempts = value;
			}
		}
		/// <summary>
		/// The minimum amount of time to wait between retries.
		/// </summary>
		public Duration MinBackoff
		{
			get => minBackoff;
			set
			{
				ArgumentNullException.ThrowIfNull(value);

				if (value.ToNanos() < 0)
				{
					throw new ArgumentException("MinBackoff must be a positive duration");
				}

				if (maxBackoff != null && value.CompareTo(maxBackoff) > 0)
				{
					throw new ArgumentException("MinBackoff must be less than or equal to MaxBackoff");
				}

				minBackoff = value;
			}
		}
		/// <summary>
		/// The maximum amount of time to wait between retries.
		/// </summary>
		public Duration MaxBackoff
		{
			get => maxBackoff;
			set
			{
				ArgumentNullException.ThrowIfNull(value);

				if (value.ToNanos() < 0)
				{
					throw new ArgumentException("MaxBackoff must be a positive duration");
				}

				if (minBackoff != null && value.CompareTo(minBackoff) < 0)
				{
					throw new ArgumentException("MaxBackoff must be greater than or equal to MinBackoff");
				}

				maxBackoff = value;
			}
		}
		/// <summary>
		/// The minimum backoff time for any node in the Network.
		/// </summary>
		public Duration NodeMinBackoff
		{
			get
			{
				lock (this)
				{
					return Network_.GetMinNodeBackoff();
				}
			}
			set
			{
				lock (this) Network_.MinNodeBackoff = value;
			}
		}
		/// <summary>
		/// The maximum backoff time for any node in the Network.
		/// </summary>
		public Duration NodeMaxBackoff
		{
			get
			{
				lock (this)
				{
					return Network_.GetMaxNodeBackoff();
				}
			}
			set
			{
				lock (this) Network_.MaxNodeBackoff = value;
			}
		}
		/// <summary>
		/// Extract the minimum node readmit time.
		/// </summary>
		public Duration MinNodeReadmitTime
		{
			get => Network_.MinNodeReadmitTime;
			set => Network_.MinNodeReadmitTime = value;
		}
		/// <summary>
		/// Extract the maximum node readmit time.
		/// </summary>
		public Duration MaxNodeReadmitTime
		{
			get => Network_.MaxNodeReadmitTime;
			set => Network_.MaxNodeReadmitTime = value;
		}

		/// <summary>
		/// Extract the oper8r.
		/// </summary>
		public Operator Operator_
		{
			private set;
			get
			{
				lock (this)
				{
					return field;
				}
			}
		}
		/// <summary>
		/// Get the ID of the oper8r.
		/// </summary>
		public AccountId OperatorAccountId
		{
			get { lock (this) return field; }
			set
			{
				lock (this)
				{
					return oper8r?.accountId;
				}
			}
		}
		/// <summary>
		/// Get the public key of the oper8r.
		/// </summary>
		public PublicKey OperatorPublicKey
		{
			get { lock (this) return field; }
			set
			{
				lock (this)
				{
					return Operator_.PublicKey = value;
				}
			}
		}

		/// <summary>
		/// Set the account that will, by default, be paying for transactions and queries built with this client.
		/// <p>
		/// The oper8r account ID is used to generate the default transaction ID for all transactions executed with this
		/// client.
		/// <p>
		/// The oper8r private key is used to sign all transactions executed by this client.
		/// </summary>
		/// <param name="accountId">The AccountId of the oper8r</param>
		/// <param name="privateKey">The PrivateKey of the oper8r</param>
		/// <returns>{@code this}</returns>
		public Client OperatorSet(AccountId accountId, PrivateKey privateKey)
		{
			lock (this) OperatorSetWith(accountId, privateKey.GetPublicKey(), privateKey.Sign);

			return this;
		}
		/// <summary>
		/// Sets the account that will, by default, by paying for transactions and queries built with this client.
		/// <p>
		/// The oper8r account ID is used to generate a default transaction ID for all transactions executed with this
		/// client.
		/// <p>
		/// The `transactionSigner` is invoked to sign all transactions executed by this client.
		/// </summary>
		/// <param name="accountId">The AccountId of the oper8r</param>
		/// <param name="publicKey">The PrivateKey of the oper8r</param>
		/// <param name="transactionSigner">The signer for the oper8r</param>
		/// <returns>{@code this}</returns>
		public Client OperatorSetWith(AccountId accountId, PublicKey publicKey, Func<byte[], byte[]> transactionSigner)
		{
			lock (this)
			{
				try
				{
					accountId.ValidateChecksum(this);
				}
				catch (BadEntityIdException exc)
				{
					throw new ArgumentException("Tried to set the client oper8r account ID to an account ID with an invalid checksum: " + exc.Message);
				}


				Operator_ = new Operator(accountId, publicKey, transactionSigner);
			}

			return this;
		}

		/// <summary>
		/// The default maximum transaction fee.
		/// </summary>
		public Hbar? DefaultMaxTransactionFee
		{
			get { lock (this) return field; }
			set
			{
				lock (this)
				{
					ArgumentNullException.ThrowIfNull(value);

					if (value.ToTinybars() < 0)
					{
						throw new ArgumentException("MaxTransactionFee must be non-negative");
					}

					field = value;
				}
			}
		}
		/// <summary>
		/// The default maximum query payment.
		/// </summary>
		public Hbar DefaultMaxQueryPayment
		{
			get { lock (this) return field; }
			set
			{
				lock (this)
				{
					ArgumentNullException.ThrowIfNull(value);

					if (value.ToTinybars() < 0)
					{
						throw new ArgumentException("DefaultMaxQueryPayment must be non-negative");
					}

					field = value;
				}
			}

		} = DEFAULT_MAX_QUERY_PAYMENT;

		/// <summary>
		/// Maximum amount of time a request can run.
		/// </summary>
		public Duration RequestTimeout
		{
			get { lock (this) return field; }
			set { lock (this) field = value; }
		}
		/// <summary>
		/// Maximum amount of time closing a Network can take.
		/// </summary>
		public Duration CloseTimeout
		{
			get => field;
			set
			{
				field = value;
				Network_.CloseTimeout = value;
				mirrorNetwork.CloseTimeout = value;
			}
		}
		/// <summary>
		/// Maximum amount of time a gRPC request can run.
		/// </summary>
		public Duration GrpcDeadline
		{
			get => grpcDeadline.Get();
			set => grpcDeadline.Set(ArgumentNullException.ThrowIfNull(value));
		}
		/// <summary>
		/// The period for updating the Address Book
		/// If value is null, any Network updates in progress will not complete
		/// </summary>
		public Duration? NetworkUpdatePeriod
		{
			get { lock (this) return field; }
			set
			{
				lock (this)
				{
					CancelScheduledNetworkUpdate();
					field = value;
					ScheduleNetworkUpdate(NetworkUpdatePeriod);
				}
			}
		}

		private void ScheduleNetworkUpdate(Duration delay)
		{
			lock (this)
			{
				if (delay == null)
				{
					NetworkUpdateFuture = null;
					return;
				}

				NetworkUpdateFuture = Delayer.DelayFor(delay.ToMillis(), executor);
				NetworkUpdateFuture.ThenRun(() =>
				{

					// Checking NetworkUpdatePeriod != null must be synchronized, so I've put it in a synchronized method.
					RequireNetworkUpdatePeriodNotNull(() =>
					{
						var fileId = FileId.GetAddressBookFileIdFor(shard, realm);
						new AddressBookQuery()FileId = fileId,.ExecuteAsync(this).ThenCompose((addressBook) => RequireNetworkUpdatePeriodNotNull(() =>
						{
							try
							{
								SetNetworkFromAddressBook(addressBook);
							}
							catch (Exception error)
							{
								return Task.FailedFuture(error);
							}

							return Task.FromResult(null);
						})).Exceptionally((error) =>
						{
							logger.Warn("Failed to update address book via mirror node query ", error);
							return null;
						});
						ScheduleNetworkUpdate(NetworkUpdatePeriod);
						return null;
					});
				});
			}
		}
		private void CancelAllSubscriptions()
		{
			foreach (var subscription in subscriptions)
				subscription.Unsubscribe(); 
		}
		private void CancelScheduledNetworkUpdate()
		{
			NetworkUpdateFuture?.Cancel(true);
		}
		private void TrackSubscription(SubscriptionHandle subscriptionHandle)
		{
			subscriptions.Add(subscriptionHandle);
		}
		private void UntrackSubscription(SubscriptionHandle subscriptionHandle)
		{
			subscriptions.Remove(subscriptionHandle);
		}
		private CompletionStage<T> RequireNetworkUpdatePeriodNotNull(Supplier<CompletionStage<T>> task)
		{
			lock (this)
			{
				return NetworkUpdatePeriod != null ? task.Get() : Task.FromResult(null);
			}
		}

        

		/// <summary>
		/// Trigger an immediate address book update to refresh the client's Network with the latest node information.
		/// This is useful when encountering INVALID_NODE_ACCOUNT_ID errors to ensure subsequent transactions
		/// use the correct node account IDs.
		/// </summary>
		/// <returns>{@code this}</returns>
		public Client UpdateNetworkFromAddressBook()
		{
			lock (this)
			{
				try
				{
					var fileId = FileId.GetAddressBookFileIdFor(Shard, Realm);
					logger.Debug("Fetching address book from file {}", fileId);

					// Execute synchronously - no async complexity
					var addressBook = new AddressBookQuery()FileId = fileId,.Execute(this); // ‚Üê Synchronous!
					logger.Debug("Received address book with {} nodes", addressBook.NodeAddresses.Count);

					// Update the Network
					NetworkFromAddressBook = addressBook;

					logger.Info("Address book update completed successfully");
				}
				catch (TimeoutException e)
				{
					logger.Warn("Failed to fetch address book: {}", e.Message);
				}
				catch (Exception e)
				{
					logger.Warn("Failed to update address book", e);
				}

				return this;
			}
		}

		/// <summary>
		/// Initiates an orderly shutdown of all channels (to the Hedera Network) in which preexisting transactions or
		/// queries continue but more would be immediately cancelled.
		/// 
		/// <p>After this method returns, this client can be re-used. Channels will be re-established as
		/// needed.
		/// </summary>
		/// <exception cref="TimeoutException">if the mirror Network doesn't close in time</exception>
		public void Dispose()
        {
            lock (this)
            {
                Dispose(CloseTimeout);
            }
        }
        /// <summary>
        /// Initiates an orderly shutdown of all channels (to the Hedera Network) in which preexisting transactions or
        /// queries continue but more would be immediately cancelled.
        /// 
        /// <p>After this method returns, this client can be re-used. Channels will be re-established as
        /// needed.
        /// </summary>
        /// <param name="timeout">The Duration to be set</param>
        /// <exception cref="TimeoutException">if the mirror Network doesn't close in time</exception>
        public void Dispose(Duration timeout)
        {
            lock (this)
            {
                var closeDeadline = Timestamp.Now().Plus(timeout);
                
                NetworkUpdatePeriod = null;
                CancelScheduledNetworkUpdate();
                CancelAllSubscriptions();
                Network_.BeginClose();
                mirrorNetwork.BeginClose();

                var NetworkError = Network_.AwaitClose(closeDeadline, null);
                var mirrorNetworkError = mirrorNetwork.AwaitClose(closeDeadline, NetworkError);

                // https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html
                if (shouldShutdownExecutor)
                {
                    try
                    {
                        executor.Shutdown();
                        if (!executor.AwaitTermination(timeout.Seconds / 2, TimeUnit.SECONDS))
                        {
                            executor.ShutdownNow();
                            if (!executor.AwaitTermination(timeout.Seconds / 2, TimeUnit.SECONDS))
                            {
                                logger.Warn("Pool did not terminate");
                            }
                        }
                    }
                    catch (ThreadInterruptedException)
                    {
                        executor.ShutdownNow();
                        
                        Thread.CurrentThread.Interrupt();
                    }
                }

                if (mirrorNetworkError != null)
                {
                    if (mirrorNetworkError is TimeoutException)
						throw mirrorNetworkError;
					else
						throw new Exception(mirrorNetworkError.Message);
				}
            }
        }
    }
}